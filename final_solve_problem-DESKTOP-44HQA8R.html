<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
    <title>Problem Solver ‚Äì Multi-Type Support</title>

    <!-- External Libraries -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mathquill/0.10.1/mathquill.min.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathquill/0.10.1/mathquill.min.js"></script>

    <!-- ‚ö° Cache-First Pyodide Loading -->
    <script>
      const CACHE_VERSION = 'problem-solver-v1';
      const PYODIDE_URL = 'https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js';

      function updateStatus(msg) {
        const el = document.getElementById('loadingStatus');
        if (el) el.innerHTML = `<div>${msg}</div>`;
        console.log(msg);
      }

      async function getCachedScript(url) {
        try {
          const cache = await caches.open(CACHE_VERSION);
          let response = await cache.match(url);
          
          if (!response) {
            updateStatus('üì• Downloading Pyodide (first time)...');
            response = await fetch(url);
            await cache.put(url, response.clone());
            updateStatus('‚úÖ Cached for next time!');
          } else {
            updateStatus('‚ö° Loading from cache...');
          }
          
          return await response.text();
        } catch (e) {
          updateStatus('‚ö†Ô∏è Cache unavailable, using CDN...');
          const response = await fetch(url);
          return await response.text();
        }
      }

      // Initialize Pyodide with caching
      async function initPyodide() {
        updateStatus('üîß Loading Pyodide...');
        
        const scriptText = await getCachedScript(PYODIDE_URL);
        const script = document.createElement('script');
        script.textContent = scriptText;
        document.head.appendChild(script);
        
        await new Promise(resolve => setTimeout(resolve, 100));
        
        window.pyodide = await loadPyodide({
          indexURL: 'https://cdn.jsdelivr.net/pyodide/v0.24.1/full/'
        });
        
        updateStatus('‚úÖ Pyodide ready!');
        updateStatus('üì¶ Loading packages (sympy, lark, brotli)...');
        
        await window.pyodide.loadPackage(['micropip']);
        await window.pyodide.runPythonAsync(`
import micropip
await micropip.install(['sympy', 'lark', 'Brotli'])
print("‚úÖ Packages installed")
        `);
        
        updateStatus('‚úÖ All packages loaded!');
        await setupPyScriptCompat();
        await executePyScripts();
      }

      async function setupPyScriptCompat() {
        updateStatus('üîß Setting up pyscript compatibility...');
        
        await window.pyodide.runPythonAsync(`
import sys
from types import ModuleType
from pyodide.ffi import to_js, create_proxy

pyscript = ModuleType('pyscript')
import js as _js
pyscript.document = _js.document
pyscript.window = _js.window
sys.modules['pyscript'] = pyscript

print("‚úÖ pyscript module created and registered")
        `);
        
        updateStatus('‚úÖ pyscript compatibility ready!');
      }

      async function executePyScripts() {
        updateStatus('üêç Running Python code...');
        
        const pyScripts = document.querySelectorAll('script[type="py"]');
        console.log(`Found ${pyScripts.length} Python scripts`);
        
        for (let i = 0; i < pyScripts.length; i++) {
          const script = pyScripts[i];
          const code = script.textContent;
          
          updateStatus(`üêç Executing Python script ${i + 1}/${pyScripts.length}...`);
          
          try {
            console.log('Executing Python code...');
            await window.pyodide.runPythonAsync(code);
            console.log('‚úÖ Python code executed successfully');
          } catch (e) {
            console.error('Python execution error:', e);
            updateStatus('‚ùå Python error: ' + e.message);
            alert('Python Error:\n' + e.message);
            throw e;
          }
        }
        
        updateStatus('‚úÖ Python app ready!');
        
        const overlay = document.getElementById('loadingOverlay');
        if (overlay) {
          overlay.style.opacity = '0';
          setTimeout(() => overlay.remove(), 400);
        }
      }

      window.addEventListener('load', async () => {
        try {
          await initPyodide();
        } catch (e) {
          updateStatus('‚ùå Error: ' + e.message);
          console.error('Initialization error:', e);
        }
      });
    </script>

    <!-- MathJax Configuration -->
    <script>
     window.MathJax = {
  tex: {
    inlineMath: [['\\(', '\\)'], ['$', '$']],
    displayMath: [['\\[', '\\]'], ['$$', '$$']]
  },
  asciimath: {
    delimiters: [['`', '`']]
  },
  loader: {
    load: ['input/tex', 'input/asciimath', 'output/chtml']
  },
  chtml: { 
    scale: 1.2 
  },
  startup: { 
    typeset: false,
    ready: () => {
      console.log('‚úÖ MathJax ready (LaTeX + AsciiMath)');
      MathJax.startup.defaultReady();
    }
  }
};
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" async></script>

    <style>
/* ========================================
   MATHQUILL FIELD STYLING - PROMINENT BORDERS
   ======================================== */

/* Base MathQuill field styling */
.math-input {
  min-height: 60px;
  border: 2px solid #cbd5e1 !important;  /* Visible gray border */
  border-radius: 8px;
  padding: 12px !important;
  background: #ffffff !important;
  transition: all 0.2s ease;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}

/* MathQuill field when focused */
.math-input:focus-within {
  border-color: #3b82f6 !important;  /* Blue when focused */
  box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
  background: #ffffff !important;
}

/* MathQuill field on hover */
.math-input:hover {
  border-color: #94a3b8 !important;  /* Darker gray on hover */
}

/* The actual MathQuill span inside */
.math-input .mq-editable-field {
  border: none !important;
  min-height: 40px;
}

/* Make cursor more visible */
.math-input .mq-cursor {
  border-left: 2px solid #3b82f6 !important;
  animation: blink 1s step-end infinite;
}

@keyframes blink {
  0%, 50% { opacity: 1; }
  51%, 100% { opacity: 0; }
}

/* ========================================
   SPECIFIC FREESTYLE FIELD STYLING
   ======================================== */

/* Problem input field */
#freestyleProblemInput {
  min-height: 60px;
  border: 2px solid #cbd5e1 !important;
  border-radius: 8px;
  padding: 12px !important;
  background: #f8fafc !important;  /* Light gray background */
}

#freestyleProblemInput:focus-within {
  border-color: #8b5cf6 !important;  /* Purple when focused */
  box-shadow: 0 0 0 3px rgba(139, 92, 246, 0.1);
  background: #ffffff !important;
}

/* Answer input field */
#freestyleAnswerInput {
  min-height: 60px;
  border: 2px solid #cbd5e1 !important;
  border-radius: 8px;
  padding: 12px !important;
  background: #fffbeb !important;  /* Light yellow background */
}

#freestyleAnswerInput:focus-within {
  border-color: #10b981 !important;  /* Green when focused */
  box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.1);
  background: #ffffff !important;
}

/* Mobile optimizations */
@media (max-width: 768px) {
  .math-input {
    min-height: 70px;
    padding: 14px !important;
    font-size: 18px;
  }
  
  #freestyleProblemInput,
  #freestyleAnswerInput {
    min-height: 70px;
    padding: 14px !important;
  }
}
/* Global History Styles */
.attempt-entry-wrapper {
  overflow-x: auto;
  overflow-y: hidden;
  max-width: 100%;
  -webkit-overflow-scrolling: touch;
  margin-bottom: 10px;
  padding: 10px;
  border-radius: 8px;
}

.attempt-entry-wrapper::-webkit-scrollbar {
  height: 6px;
  background: #f1f5f9;
  border-radius: 3px;
}

.attempt-entry-wrapper::-webkit-scrollbar-thumb {
  background: #cbd5e1;
  border-radius: 3px;
}

.attempt-entry-wrapper::-webkit-scrollbar-thumb:hover {
  background: #94a3b8;
}

@media (max-width: 768px) {
  .attempt-entry-wrapper::-webkit-scrollbar {
    height: 8px;
  }
}
    /* Base Styles */
    * { 
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body { 
      font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial; 
      margin: 0; 
      padding: 0;
      background: #f3f6fb; 
      color: #0b1020; 
      overflow-x: hidden;
    }

    #loadingOverlay { 
      position: fixed; 
      top: 0; 
      left: 0; 
      right: 0; 
      bottom: 0; 
      background: rgba(15,23,42,0.95); 
      z-index: 9999; 
      display: flex; 
      flex-direction: column; 
      align-items: center; 
      justify-content: center; 
      color: #fff; 
    }

    .spinner { 
      width: 60px; 
      height: 60px; 
      border: 4px solid rgba(59,130,246,0.3); 
      border-top-color: #3b82f6; 
      border-radius: 50%; 
      animation: spin 1s linear infinite; 
      margin-bottom: 20px; 
    }

    @keyframes spin { 
      to { transform: rotate(360deg); } 
    }

    .loading-text {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 12px;
    }

    #loadingStatus {
      font-size: 14px;
      color: #94a3b8;
      text-align: center;
      max-width: 80%;
    }

    .panel { 
      background: #fff; 
      padding: 16px;
      border-radius: 8px; 
      box-shadow: 0 6px 20px rgba(11,20,40,0.06); 
      margin-bottom: 12px;
    }

    .btn { 
      padding: 12px 20px; 
      border-radius: 8px; 
      border: none; 
      cursor: pointer; 
      background: #0b6efd; 
      color: #fff; 
      font-size: 16px; 
      font-weight: 500; 
      transition: all 0.2s ease;
      width: 100%;
      margin-bottom: 8px;
    }

    .btn:hover { 
      transform: translateY(-1px); 
      box-shadow: 0 4px 12px rgba(11,110,253,0.3); 
    }

    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }

    .btn.ghost { 
      background: transparent; 
      color: #0b6efd; 
      border: 1px solid #dbe9ff; 
    }

    /* Layout */
    .app-container {
      display: flex;
      min-height: 100vh;
    }

    /* Sidebar */
    .sidebar {
      width: 320px;
      background: #fff;
      box-shadow: 4px 0 12px rgba(0,0,0,0.1);
      padding: 16px;
      overflow-y: auto;
      flex-shrink: 0;
    }

    .nav-menu {
      margin-bottom: 20px;
    }

    .nav-item {
      display: flex;
      align-items: center;
      padding: 12px 16px;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s ease;
      margin-bottom: 4px;
      font-weight: 500;
    }

    .nav-item:hover {
      background: #f0f4ff;
    }

    .nav-item.active {
      background: #dbeafe;
      color: #1d4ed8;
    }

    .nav-icon {
      margin-right: 12px;
      font-size: 18px;
    }

    /* Main Content */
    .main-content {
      flex: 1;
      padding: 16px;
      max-width: 100%;
    }

    .page {
      display: none;
    }

    .page.active {
      display: block;
    }

    /* Accordion */
    .accordion-problem { 
      border: 2px solid #e2e8f0; 
      border-radius: 12px; 
      margin-bottom: 16px; 
      background: #ffffff; 
      box-shadow: 0 4px 12px rgba(0,0,0,0.08); 
      overflow: hidden; 
    }

    .accordion-problem.open { 
      border-color: #3b82f6; 
    }

    .accordion-problem.finished { 
      border-color: #10b981; 
      background: #f0fdf4; 
    }

    .accordion-header { 
      padding: 16px; 
      font-weight: 700; 
      cursor: pointer; 
      display: flex; 
      justify-content: space-between; 
      align-items: center; 
      background: #f0f4ff; 
      transition: background 0.2s ease;
      font-size: 16px;
      min-height: 60px;
    }

    .accordion-header:hover { 
      background: #dbeafe; 
    }

    .accordion-body { 
      max-height: 0; 
      overflow: hidden; 
      transition: max-height 0.3s ease-in-out; 
      padding: 0 16px; 
    }

    .accordion-problem.open .accordion-body { 
      max-height: 10000px; 
      padding: 16px; 
    }

    .progress-summary { 
      font-size: 14px; 
      color: #6b7280; 
      font-weight: 600; 
    }

    /* Step styling */
    .step {
      padding: 16px;
      font-size: 16px;
      display: none;
    }

    .step.active {
      display: block;
    }

    .step-description {
      background: #f0fdf4;
      padding: 16px;
      border-radius: 8px;
      margin-bottom: 12px;
      font-size: 16px;
      line-height: 1.6;
      overflow-x: auto;
    }

    .step-feedback {
      font-size: 15px;
      padding: 12px;
      border-radius: 6px;
      margin-top: 12px;
      font-weight: 600;
      overflow-x: auto;
    }

    /* Multiple Choice Styles */
    .mc-option {
      display: block;
      padding: 12px 16px;
      margin-bottom: 8px;
      border: 2px solid #e2e8f0;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s ease;
      background: #fff;
    }

    .mc-option:hover {
      border-color: #3b82f6;
      background: #f0f9ff;
    }

    .mc-option input[type="radio"],
    .mc-option input[type="checkbox"] {
      margin-right: 12px;
      width: 18px;
      height: 18px;
      cursor: pointer;
    }

    .mc-option.selected {
      border-color: #3b82f6;
      background: #dbeafe;
    }

    .mc-option.correct {
      border-color: #10b981;
      background: #d1fae5;
    }

    .mc-option.incorrect {
      border-color: #ef4444;
      background: #fee2e2;
    }

    /* True/False Buttons */
    .tf-buttons {
      display: flex;
      gap: 12px;
      margin: 16px 0;
    }

    .tf-btn {
      flex: 1;
      padding: 16px;
      border: 2px solid #e2e8f0;
      border-radius: 8px;
      cursor: pointer;
      font-size: 18px;
      font-weight: 600;
      text-align: center;
      transition: all 0.2s ease;
      background: #fff;
    }

    .tf-btn:hover {
      border-color: #3b82f6;
      background: #f0f9ff;
    }

    .tf-btn.selected {
      border-color: #3b82f6;
      background: #dbeafe;
    }

    .tf-btn.correct {
      border-color: #10b981;
      background: #d1fae5;
    }

    .tf-btn.incorrect {
      border-color: #ef4444;
      background: #fee2e2;
    }

    /* Fill-in-the-Blank */
    .fill-blank-input {
      width: 100%;
      padding: 12px;
      border: 2px solid #e2e8f0;
      border-radius: 8px;
      font-size: 16px;
      margin-bottom: 12px;
    }

    .fill-blank-input:focus {
      outline: none;
      border-color: #3b82f6;
    }

    /* Storage Indicator */
    .storage-indicator { 
      position: fixed; 
      bottom: 16px; 
      right: 16px; 
      padding: 10px 14px; 
      background: #10b981; 
      color: #fff; 
      border-radius: 8px; 
      font-size: 13px; 
      opacity: 0; 
      transition: opacity 0.3s; 
      pointer-events: none; 
      z-index: 1000;
      font-weight: 600;
    }

    .storage-indicator.show { 
      opacity: 1; 
    }

    /* Mobile Responsive */
    @media (max-width: 768px) {
      .app-container {
        flex-direction: column;
      }
      
      .sidebar {
        position: fixed;
        left: -100%;
        top: 0;
        width: 85%;
        max-width: 400px;
        height: 100vh;
        z-index: 1000;
        transition: left 0.3s ease;
      }
      
      .sidebar.open {
        left: 0;
      }
      
      .main-content {
        padding: 60px 8px 8px 8px;
      }
      
      .menu-btn {
        position: fixed;
        top: 8px;
        left: 8px;
        z-index: 1001;
        width: 50px;
        height: 50px;
        background: #0b6efd;
        color: #fff;
        border: none;
        border-radius: 12px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 26px;
        box-shadow: 0 4px 16px rgba(11,110,253,0.5);
        font-weight: bold;
      }
      
      .sidebar-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.6);
        z-index: 999;
        display: none;
      }
      
      .sidebar-overlay.show {
        display: block;
      }
    }

    @media (min-width: 769px) {
      .menu-btn,
      .sidebar-overlay {
        display: none !important;
      }
    }
/* Keyboard Accordion Styles */
.keyboard-accordion {
  border: 1px solid #e5e7eb;
  border-radius: 8px;
  overflow: hidden;
}

.keyboard-accordion-header {
  background: #f9fafb;
  padding: 12px 16px;
  cursor: pointer;
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-weight: 600;
  user-select: none;
  transition: background 0.2s;
}

.keyboard-accordion-header:hover {
  background: #f3f4f6;
}

.keyboard-accordion-body {
  display: none;
  background: #fff;
  border-top: 1px solid #e5e7eb;
}

.keyboard-accordion-icon {
  color: #6b7280;
  transition: transform 0.2s;
}

/* Input Button Styles */
.input-btn {
  padding: 10px;
  border: 1px solid #d1d5db;
  border-radius: 6px;
  background: #fff;
  font-size: 16px;
  cursor: pointer;
  transition: all 0.15s;
  font-family: system-ui, -apple-system, sans-serif;
}

.input-btn:hover {
  background: #f3f4f6;
  transform: scale(1.05);
}

.input-btn:active {
  transform: scale(0.95);
  background: #e5e7eb;
}

.input-btn.digit {
  background: #eff6ff;
  border-color: #bfdbfe;
}

.input-btn.operator {
  background: #fef3c7;
  border-color: #fde68a;
}

.input-btn.special {
  background: #e0e7ff;
  border-color: #c7d2fe;
}

.input-btn.symbol {
  background: #ddd6fe;
  border-color: #c4b5fd;
}

.input-btn.delete {
  background: #fee2e2;
  border-color: #fecaca;
  color: #991b1b;
  font-weight: 600;
}

.input-btn.navigation {
  background: #f3f4f6;
  border-color: #d1d5db;
}

/* Mobile Optimizations */
@media (max-width: 768px) {
  .input-btn {
    padding: 12px 8px;
    font-size: 14px;
  }
  
  #freestyleProblemDisplay {
    overflow-x: auto;
    -webkit-overflow-scrolling: touch;
  }
}

/* Credit notification animation */
@keyframes slideInRight {
  from {
    transform: translateX(100%);
    opacity: 0;
  }
  to {
    transform: translateX(0);
    opacity: 1;
  }
}

    @keyframes slideIn {
      from {
        transform: translateY(-10px);
        opacity: 0;
      }
      to {
        transform: translateY(0);
        opacity: 1;
      }
    }

    @keyframes slideInRight {
      from {
        transform: translateX(100%);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    @keyframes slideOutRight {
      from {
        transform: translateX(0);
        opacity: 1;
      }
      to {
        transform: translateX(100%);
        opacity: 0;
      }
    }

    </style>
  </head>
  <body>
    <!-- Loading Overlay -->
    <div id="loadingOverlay">
      <div class="spinner"></div>
      <div class="loading-text">‚ö° Loading Problem Solver...</div>
      <div id="loadingStatus">
        <div>‚è≥ Starting up...</div>
      </div>
    </div>

    <!-- Mobile Menu Button -->
    <button class="menu-btn" id="menuBtn">‚ò∞</button>
    <div class="sidebar-overlay" id="sidebarOverlay"></div>

    <!-- Main App Container -->
    <div class="app-container">
      <!-- Sidebar -->
      <aside class="sidebar" id="sidebar">
        <div class="sidebar-header">
          <h3>üßÆ Problem Solver</h3>
        </div>

        <!-- Problem Set Info -->
        <div id="problemSetInfo" class="panel" style="display: none">
          <div style="font-size: 16px; font-weight: 700; margin-bottom: 8px">Problem Set</div>
          <div id="currentProblemSetDescription" style="font-size: 14px; color: #64748b; margin-bottom: 8px">
            No problem set loaded
          </div>
          <div id="currentProblemSetUuid" style="font-family: monospace; font-size: 12px; color: #0369a1; background: #f0f9ff; padding: 8px; border-radius: 6px;">
            No UUID
          </div>
        </div>

        <!-- Navigation -->
        <nav class="nav-menu">
          <div class="nav-item active" data-page="problems">
            <span class="nav-icon">üßÆ</span>
            <span>Work on Problems</span>
          </div>
          <div class="nav-item" data-page="freestyle">
            <span class="nav-icon">‚úèÔ∏è</span>
            <span class="nav-text">Freestyle Practice</span>
          </div>
          <div class="nav-item" data-page="load">
            <span class="nav-icon">üìÇ</span>
            <span>Load Problem Set</span>
          </div>
          <div class="nav-item" data-page="export">
            <span class="nav-icon">üì§</span>
            <span>Submit Progress</span>
          </div>
        </nav>
      </aside>

      <!-- Main Content -->
      <main class="main-content">
        <!-- Problems Page -->
        <div id="problemsPage" class="page active">
          <div id="initialLoadPanel" class="panel">
            <h3>üìÇ Load Problem Set</h3>
            <p>No problems loaded. Use the sidebar to load a problem set.</p>
          </div>
          <div id="solveProblemsContainer"></div>
        </div>
        <!-- Freestyle Practice Page -->
        <div id="freestylePage" class="page">
          <div class="panel">
            <h3>‚úèÔ∏è Freestyle Practice</h3>
            <p style="color: #64748b; margin-bottom: 16px">
              Create and solve your own problem. Enter a mathematical expression, then try to solve it!
              <strong>Limit problems will be automatically validated.</strong>
            </p>

            <!-- Credit System Display -->
            <div id="creditDisplay" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 16px; border-radius: 12px; margin-bottom: 20px; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
              <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                <div style="font-size: 14px; font-weight: 600; opacity: 0.9;">üíé Give-Up Credits</div>
                <button id="showCreditHistory" class="btn ghost" style="padding: 4px 12px; font-size: 12px; background: rgba(255,255,255,0.2); color: white; border: 1px solid rgba(255,255,255,0.3);">
                  View History
                </button>
              </div>
              <div style="display: flex; align-items: baseline; gap: 12px;">
                <div style="font-size: 32px; font-weight: 700;" id="creditBalance">0</div>
                <div style="font-size: 14px; opacity: 0.8;">
                  <span id="creditEarned">0</span> earned ‚Ä¢ 
                  <span id="creditSpent">0</span> spent
                </div>
              </div>
              <div style="font-size: 12px; margin-top: 8px; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.2); opacity: 0.9;">
                ‚ÑπÔ∏è Earn credits by solving problems. Use them to reveal solutions when stuck!
              </div>
            </div>

            <!-- Credit History Modal (Hidden by default) -->
            <div id="creditHistoryModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 10000; align-items: center; justify-content: center;">
              <div style="background: white; border-radius: 12px; max-width: 600px; max-height: 80vh; overflow: hidden; display: flex; flex-direction: column; margin: 20px;">
                <div style="padding: 20px; border-bottom: 2px solid #e5e7eb;">
                  <div style="display: flex; justify-content: space-between; align-items: center;">
                    <h3 style="margin: 0;">üìä Credit History</h3>
                    <button id="closeCreditHistory" style="background: none; border: none; font-size: 24px; cursor: pointer; color: #64748b;">√ó</button>
                  </div>
                </div>
                <div id="creditHistoryContent" style="padding: 20px; overflow-y: auto; flex: 1;">
                  <!-- History will be populated here -->
                </div>
              </div>
            </div>

            <div style="margin-bottom: 20px">
              <label>üìù Problem Expression</label>
              <div
                style="
                  overflow-x: auto;
                  overflow-y: hidden;
                  max-width: 100%;
                  -webkit-overflow-scrolling: touch;
                  border: 2px solid #e6eef8;
                  border-radius: 8px;
                  padding: 10px;
                  background: #fff;
                ">
                <div
                  id="freestyleProblemInput"
                  class="math-input"
                  style="min-height: 60px; border: none; padding: 0"></div>
              </div>
              <button id="setFreestyleProblem" class="btn" style="margin-top: 10px">Set Problem</button>
            </div>

            <div id="freestyleSolveArea" style="display: none">
              <hr style="margin: 20px 0; border: none; border-top: 2px solid #e5e7eb" />

              <div style="background: #f0fdf4; padding: 16px; border-radius: 8px; margin-bottom: 16px">
                <div style="font-weight: 700; margin-bottom: 8px">Problem to Solve:</div>
                <div id="freestyleProblemDisplay" style="font-size: 20px"></div>
              </div>

              <div style="margin-bottom: 20px">
                <label>üéØ Your Solution</label>
                <div
                  style="
                    overflow-x: auto;
                    overflow-y: hidden;
                    max-width: 100%;
                    -webkit-overflow-scrolling: touch;
                    border: 2px solid #e6eef8;
                    border-radius: 8px;
                    padding: 10px;
                    background: #fff;
                  ">
                  <div
                    id="freestyleAnswerInput"
                    class="math-input"
                    style="min-height: 60px; border: none; padding: 0"></div>
                </div>

                <div style="display: flex; flex-direction: column; gap: 8px; margin-top: 12px">
                  <button id="freestyleSubmit" class="btn">Submit Attempt</button>
                  <button id="freestyleGiveUp" class="btn ghost" style="background: #f59e0b; color: #fff">
                    Give Up (Show Solution)
                  </button>
                  <button id="freestyleFinalize" class="btn ghost" disabled>Check Simplest Form</button>
                  <button id="freestyleReset" class="btn ghost" style="background: #dc2626; color: #fff">
                    Reset Problem
                  </button>
                </div>

                <div id="freestyleFeedback" style="margin-top: 16px; min-height: 20px"></div>
                <div id="freestyleHistory" style="margin-top: 16px; min-height: 20px"></div>
              </div>
            </div>

            <!-- Comprehensive Keyboard -->
            <div id="keyboardAccordionsContainer" style="margin-top: 16px">
              <div style="font-weight: 600; margin-bottom: 8px; font-size: 15px">‚å®Ô∏è Input Keyboard:</div>

              <!-- Numbers & Basic Accordion -->
              <div class="keyboard-accordion" style="margin-bottom: 6px">
                <div class="keyboard-accordion-header" data-target="numbersBody">
                  <span>üî¢ Numbers & Basic</span>
                  <span class="keyboard-accordion-icon">‚ñº</span>
                </div>
                <div id="numbersBody" class="keyboard-accordion-body">
                  <div style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 3px; padding: 8px">
                    <button class="input-btn digit" data-action="7">7</button>
                    <button class="input-btn digit" data-action="8">8</button>
                    <button class="input-btn digit" data-action="9">9</button>
                    <button class="input-btn special" data-action="^" id="freestylePower"></button>
                    <button class="input-btn special" data-action="_" id="freestyleSubscript"></button>
                    <button class="input-btn digit" data-action="4">4</button>
                    <button class="input-btn digit" data-action="5">5</button>
                    <button class="input-btn digit" data-action="6">6</button>
                    <button class="input-btn operator" data-action="/">√∑</button>
                    <button class="input-btn operator" data-action="\\times">√ó</button>
                    <button class="input-btn digit" data-action="1">1</button>
                    <button class="input-btn digit" data-action="2">2</button>
                    <button class="input-btn digit" data-action="3">3</button>
                    <button class="input-btn operator" data-action="-">‚àí</button>
                    <button class="input-btn operator" data-action="+">+</button>
                    <button class="input-btn special" data-action="(">(</button>
                    <button class="input-btn digit" data-action="0">0</button>
                    <button class="input-btn special" data-action=")">)</button>
                    <button class="input-btn special" data-action=".">.</button>
                    <button class="input-btn special" data-action="=">=</button>
                    <button class="input-btn delete" data-action="BACKSPACE">‚å´</button>
                    <button class="input-btn navigation" data-action="MOVE_LEFT" id="freestyleMoveLeft"></button>
                    <button class="input-btn navigation" data-action="MOVE_RIGHT" id="freestyleMoveRight"></button>
                    <button class="input-btn delete" data-action="CLEAR">Clear</button>
                  </div>
                </div>
              </div>

              <!-- Algebra Accordion -->
              <div class="keyboard-accordion" style="margin-bottom: 6px">
                <div class="keyboard-accordion-header" data-target="algebraBody">
                  <span>üî§ Algebra</span>
                  <span class="keyboard-accordion-icon">‚ñº</span>
                </div>
                <div id="algebraBody" class="keyboard-accordion-body">
                  <div style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 3px; padding: 8px">
                    <button class="input-btn symbol" data-action="x">x</button>
                    <button class="input-btn symbol" data-action="y">y</button>
                    <button class="input-btn symbol" data-action="z">z</button>
                    <button class="input-btn symbol" data-action="a">a</button>
                    <button class="input-btn symbol" data-action="b">b</button>
                    <button class="input-btn symbol" data-action="c">c</button>
                    <button class="input-btn symbol" data-action="n">n</button>
                    <button class="input-btn special" data-action="\\frac">√∑(fr)</button>
                    <button class="input-btn special" data-action="|">|x|</button>
                    <button class="input-btn special" data-action="\\sqrt">‚àö</button>
                  </div>
                </div>
              </div>

              <!-- Calculus Accordion -->
              <div class="keyboard-accordion" style="margin-bottom: 6px">
                <div class="keyboard-accordion-header" data-target="calculusBody">
                  <span>‚à´ Calculus</span>
                  <span class="keyboard-accordion-icon">‚ñº</span>
                </div>
                <div id="calculusBody" class="keyboard-accordion-body">
                  <div style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 3px; padding: 8px">
                    <button class="input-btn operator" data-action="SEQ:d,/,d,x">d/dx</button>
                    <button class="input-btn operator" data-action="\\int">‚à´</button>
                    <button class="input-btn operator" data-action="\\sum">Œ£</button>
                    <button class="input-btn operator" data-action="\\lim">lim</button>
                    <button class="input-btn operator" data-action="SEQ:\\lim,_,x,\\to,0,{Right},{Right}">lim‚Üí0</button>
                    <button class="input-btn operator" data-action="SEQ:\\lim,_,x,\\to,\\infty,{Right},{Right}">lim‚Üí‚àû</button>
                    <button class="input-btn operator" data-action="\\to">‚Üí</button>
                    <button class="input-btn operator" data-action="\\infty">‚àû</button>
                    <button class="input-btn operator" data-action="\\partial">‚àÇ</button>
                    <button class="input-btn operator" data-action="e">e</button>
                  </div>
                </div>
              </div>

              <!-- Trigonometry Accordion -->
              <div class="keyboard-accordion" style="margin-bottom: 6px">
                <div class="keyboard-accordion-header" data-target="trigBody">
                  <span>üìä Trigonometry</span>
                  <span class="keyboard-accordion-icon">‚ñº</span>
                </div>
                <div id="trigBody" class="keyboard-accordion-body">
                  <div style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 3px; padding: 8px">
                    <button class="input-btn operator" data-action="\\sin">sin</button>
                    <button class="input-btn operator" data-action="\\cos">cos</button>
                    <button class="input-btn operator" data-action="\\tan">tan</button>
                    <button class="input-btn operator" data-action="\\sec">sec</button>
                    <button class="input-btn operator" data-action="\\csc">csc</button>
                    <button class="input-btn operator" data-action="\\arcsin">asin</button>
                    <button class="input-btn operator" data-action="\\arccos">acos</button>
                    <button class="input-btn operator" data-action="\\arctan">atan</button>
                    <button class="input-btn symbol" data-action="\\pi">œÄ</button>
                    <button class="input-btn operator" data-action="\\ln">ln</button>
                  </div>
                </div>
              </div>

              <!-- Matrix Accordion -->
              <div class="keyboard-accordion" style="margin-bottom: 6px">
                <div class="keyboard-accordion-header" data-target="matrixBody">
                  <span>‚¨ú Matrix</span>
                  <span class="keyboard-accordion-icon">‚ñº</span>
                </div>
                <div id="matrixBody" class="keyboard-accordion-body">
                  <div style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 3px; padding: 8px">
                    <button class="input-btn special" data-action="[">[</button>
                    <button class="input-btn special" data-action="]">]</button>
                    <button class="input-btn special" data-action=",">,</button>
                    <button class="input-btn special" data-action="\\\\">\</button>
                    <button class="input-btn special" data-action="&">&</button>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
        <!-- Load Page -->
        <div id="loadPage" class="page">
          <div class="panel">
            <h3>üìÇ Load Problem Set</h3>

            <label>Load Problem Set From File</label>
            <input type="file" id="uploadFile" accept=".txt,text/plain" />

            <div style="text-align: center; margin: 12px 0; color: #94a3b8">‚Äî OR ‚Äî</div>

            <label>üìã Paste JSON</label>
            <textarea id="pasteJson" placeholder="Paste base64-compressed JSON" style="width:100%;min-height:120px;padding:12px;border-radius:8px;border:1px solid #e6eef8;"></textarea>
            <button id="loadJsonBtn" class="btn">üìÇ Load Problem Set From Pasted JSON</button>
          </div>
        </div>

        <!-- Export Page -->
        <div id="exportPage" class="page">
          <div class="panel">
            <h3>üì§ Submit Progress</h3>
            <button id="exportProgressBtn" class="btn" style="background: #10b981">üì§ Export to File</button>
          </div>
        </div>
      </main>
    </div>

    <!-- Storage Indicator -->
    <div id="storageIndicator" class="storage-indicator">üíæ Saved</div>

    <!-- Python Script -->
    <script type="py">

from pyscript import document, window
from pyodide.ffi import create_proxy
import json, html, base64, uuid

print("üîß Starting Problem Solver with Multi-Type Support...")

class MathParser:
    """Handles LaTeX parsing, structural comparison, and error popups"""

    GRAMMAR = r"""
start: matrix_ops
   | expr

?expr: sum

?sum: sum "+" product   -> add
  | sum "-" product   -> sub
  | product

?product: product ("*" | "\\cdot" | "\\times" | "\\ast") power   -> mul  # Changed: power instead of implicit
      | product "/" power                                        -> div   # Changed: power instead of implicit
      | scalar matrix                                            -> scalar_matrix_mul
      | scalar matrix_env                                        -> scalar_matrix_mul
      | implicit

?implicit: implicit power        -> implicit_mul
       | power

?power: "-" power                -> neg
    | atom_degree              -> atom_to_degree
    | atom "^" power           -> power
    | atom

?atom: NUMBER                    -> number
   | derivative_function
   | partial_derivative_function
   | trig_function
   | log_function
   | limit
   | fraction
   | abs_function
   | matrix
   | matrix_env
   | "(" expr ")"              -> paren_expr
   | "{" expr "}"              -> braces_expr
   | PI                        -> pi_symbol
   | INFTY                     -> infty_symbol
   | SYMBOL                    -> symbol
   | row_op

scalar: NUMBER | SYMBOL

trig_function: TRIG_NAME "(" expr ")"    -> trig_func

log_function: LOG_NAME "(" expr ")"      -> log_func

limit: "\\lim" "_" "{" SYMBOL "\\to" expr "}" expr -> limit_expr

derivative_function: "__derivative" "(" SYMBOL "," expr ")" -> derivative_func

partial_derivative_function: "__partial_derivative" "(" SYMBOL "," expr ")" -> partial_derivative_func

fraction: "\\frac" "{" expr "}" "{" expr "}" -> frac

abs_function: "\\left" "|" expr "\\right" "|"     -> abs_func
          | "|" expr "|"                          -> abs_func

atom_degree: atom "^" degree_expr

degree_expr: "{" CIRC "}"

matrix: "[" matrix_rows "]" -> matrix_rows
matrix_rows: row ("," row)* -> matrix_rows
row: "[" elements "]" -> row
elements: expr ("," expr)* -> elements

matrix_env: "\\begin" "{" /(bmatrix|pmatrix|matrix)/ "}" matrix_env_body "\\end" "{" /(bmatrix|pmatrix|matrix)/ "}" -> matrix_env

matrix_env_body: matrix_env_row ( "\\\\" matrix_env_row )*
matrix_env_row: expr ( "&" expr )*

matrix_ops: matrix ("|" row_op)+ -> matrix_apply_ops

row_op: "R_" INT arrow row_expr                 -> row_replace
    | "R_" INT swap_arrow "R_" INT            -> row_swap

arrow: "\\to" | "\\leftarrow"
swap_arrow: "\\leftrightarrow"

row_expr: "R_" INT                     -> row_reference
       | expr "R_" INT               -> row_scale
       | "R_" INT op expr "R_" INT   -> row_combine

op: "+" | "-"

TRIG_NAME.2: "\\sin" | "\\cos" | "\\tan" | "\\cot" | "\\sec" | "\\csc"
         | "\\arcsin" | "\\arccos" | "\\arctan"
LOG_NAME.2: "\\log" | "\\ln" | "\\exp"
LIM.2: "\\lim"
NUMBER: /[+-]?\d+(\.\d*)?|\.\d+/
INT: /\d+/
PI.2: "\\pi"
INFTY.2: "\\infty"
SYMBOL: /\\?(?!(?:sin|cos|tan|cot|sec|csc|arcsin|arccos|arctan|log|ln|exp|frac|left|right|begin|end|pi|infty|lim|lvert|rvert)(?![a-zA-Z0-9]))[a-zA-Z][a-zA-Z0-9]*/
CIRC: "\\circ"

%import common.WS_INLINE
%ignore WS_INLINE
"""
    
    def __init__(self):
        from lark import Lark
        self.parser = Lark(self.GRAMMAR, parser="earley", start="start")
        self.transformer = self._create_transformer()

    def _preprocess_derivatives(self, latex_str):
        """
        Rewrites \frac{d}{dx}(...) and \frac{\partial}{\partial x}(...)
        patterns into unique function calls before parsing.
        """
        import re

        # 1. Handle total derivatives: \frac{d}{dx}(...)
        total_derivative_pattern = re.compile(r"\\frac\{d\}\{d([a-zA-Z]+)\}\(([^)]+)\)")
        total_replacement = r"__derivative(\1, \2)"
        processed_str = total_derivative_pattern.sub(total_replacement, latex_str)

        # 2. Handle partial derivatives: \frac{\partial}{\partial x}(...)
        # This regex is slightly different to handle the \partial command and optional space.
        partial_derivative_pattern = re.compile(r"\\frac\{\\partial\}\{\\partial\s*([a-zA-Z]+)\}\(([^)]+)\)")
        partial_replacement = r"__partial_derivative(\1, \2)"
        final_str = partial_derivative_pattern.sub(partial_replacement, processed_str)

        return final_str

    def _show_error_popup(self, message):
        """Display error popup with close button - optimized for mobile"""
        safe_msg = message.replace("`", "'").replace("\\", "\\\\").replace("\n", "\\n")
        js_code = f"""
            (function(){{
                let existing = document.querySelector('#parseErrorPopup');
                if(existing) existing.remove();

                let popup = document.createElement('div');
                popup.id = 'parseErrorPopup';

                // Detect if mobile/small screen
                let isMobile = window.innerWidth <= 768;

                if(isMobile) {{
                    // Mobile styles - fullscreen-like
                    popup.style.cssText = `
                        position:fixed;
                        top:0;
                        left:0;
                        right:0;
                        bottom:0;
                        background:#f8fafc;
                        color:#0f172a;
                        font-family:monospace;
                        padding:60px 16px 16px 16px;
                        border:none;
                        border-radius:0;
                        box-shadow:none;
                        white-space:pre-wrap;
                        z-index:9999;
                        overflow:auto;
                        -webkit-overflow-scrolling:touch;
                    `;
                }} else {{
                    // Desktop styles - centered dialog
                    popup.style.cssText = `
                        position:fixed;
                        top:50%;
                        left:50%;
                        transform:translate(-50%, -50%);
                        background:#f8fafc;
                        color:#0f172a;
                        font-family:monospace;
                        padding:24px 24px 16px 24px;
                        border:2px solid #ef4444;
                        border-radius:12px;
                        box-shadow:0 12px 40px rgba(0,0,0,0.2);
                        white-space:pre;
                        z-index:9999;
                        max-width:650px;
                        max-height:70vh;
                        overflow:auto;
                    `;
                }}

                let btn = document.createElement('button');
                btn.textContent = '‚úñ';
                btn.title = 'Close';

                if(isMobile) {{
                    // Mobile close button - larger and top-left
                    btn.style.cssText = `
                        position:fixed;
                        top:12px;
                        right:12px;
                        width:44px;
                        height:44px;
                        border:none;
                        background:#ef4444;
                        color:#fff;
                        font-size:24px;
                        font-weight:bold;
                        cursor:pointer;
                        line-height:1;
                        border-radius:8px;
                        box-shadow:0 4px 12px rgba(239,68,68,0.4);
                        z-index:10000;
                    `;
                }} else {{
                    // Desktop close button - small and subtle
                    btn.style.cssText = `
                        position:absolute;
                        top:8px;
                        right:10px;
                        border:none;
                        background:transparent;
                        color:#ef4444;
                        font-size:18px;
                        font-weight:bold;
                        cursor:pointer;
                        line-height:1;
                    `;
                }}
                btn.onclick = () => popup.remove();

                let title = document.createElement('div');
                title.textContent = '‚ö†Ô∏è Parse Error';

                if(isMobile) {{
                    title.style.cssText = `
                        font-size:22px;
                        font-weight:bold;
                        color:#ef4444;
                        margin-bottom:16px;
                        padding-right:50px;
                    `;
                }} else {{
                    title.style.cssText = `
                        font-size:18px;
                        font-weight:bold;
                        color:#ef4444;
                        margin-bottom:12px;
                    `;
                }}

                let content = document.createElement('div');
                content.textContent = `{safe_msg}`;

                if(isMobile) {{
                    content.style.cssText = `
                        font-size:14px;
                        line-height:1.6;
                        word-break:break-word;
                        padding-top:8px;
                    `;
                }} else {{
                    content.style.cssText = `
                        padding-top:8px;
                    `;
                }}

                popup.appendChild(btn);
                popup.appendChild(title);
                popup.appendChild(content);
                document.body.appendChild(popup);
            }})();
        """
        window.eval(js_code)

    def _preprocess_row_operations(self, latex_str):
        """
        Safe preprocessing: only apply row-operation regexes to the operation part.
        Normalizes matrix numbers separately so matrix content is not mangled.
        """
        import re

        # 0. Quick generic cleanups that are safe everywhere
        s = latex_str.replace(r'\ ', ' ')
        s = s.replace(r'\left(', '(').replace(r'\right)', ')')
        s = s.replace(r'\left[', '[').replace(r'\right]', ']')
        s = s.replace(r'\left\{', '{').replace(r'\right\}', '}')
        s = s.replace(r'\left|', '|').replace(r'\right|', '|')
        s = s.replace(r'\cdot', '*')

        # Split into matrix part and operations part.
        # Prefer explicit '|' split. If no pipe, attempt to split at arrow (\to or ->).
        if '|' in s:
            matrix_part, ops_part = s.split('|', 1)
        else:
            # attempt to split at first arrow occurrence
            m = re.search(r'(\\to|\\rightarrow|->|<-)','%s' % s)
            if m:
                # split so matrix_part includes everything before arrow, ops_part includes arrow+rest
                idx = m.start()
                matrix_part = s[:idx]
                ops_part = s[idx:]
            else:
                # nothing to do: treat entire string as matrix_part (no row op)
                matrix_part, ops_part = s, ''

        # -------------------------
        # Normalize matrix_part (do NOT run row-op rewrites here)
        # -------------------------
        # 1) collapse repeated spaces
        matrix_part = re.sub(r'\s+', ' ', matrix_part).strip()

        # 2) Remove stray spaces between minus and number/fraction inside matrix
        #    Examples: [0, - 1, - \frac{1}{2}] -> [0, -1, -\frac{1}{2}]
        matrix_part = re.sub(r'-\s+\\frac', r'-\\frac', matrix_part)          # - \frac -> -\frac
        matrix_part = re.sub(r'-\s+(\d)', r'-\1', matrix_part)                 # - 1 -> -1
        matrix_part = re.sub(r'(\{)\s+', r'\1', matrix_part)                  # remove space after { 
        matrix_part = re.sub(r'\s+(\})', r'\1', matrix_part)                  # remove space before }
        matrix_part = re.sub(r'\[\s+', '[', matrix_part)
        matrix_part = re.sub(r'\s+\]', ']', matrix_part)

        # 3) (Optional) convert simple LaTeX fractions in matrix to explicit form so parser sees them consistently
        #    e.g. replace \frac{1}{2} with (1/2) ‚Äî only inside matrix part
        #    If you prefer leaving \frac for parser, skip this.
        matrix_part = re.sub(r'\\frac\{([^{}]+)\}\{([^{}]+)\}', r'(\1/\2)', matrix_part)

        # -------------------------
        # Now operate on ops_part only (row-operation specific rewrites)
        # -------------------------
        ops = ops_part  # local alias for clarity

        if ops:
            # 1) Ensure there's a space after arrows so tokenizer can separate parts
            ops = re.sub(r'\\to(?=\S)', r'\\to ', ops)
            ops = re.sub(r'\\rightarrow(?=\S)', r'\\rightarrow ', ops)
            ops = re.sub(r'->(?=\S)', r'-> ', ops)
            ops = re.sub(r'<-(?=\S)', r'<- ', ops)

            # 2) Fix fractions with row reference in denominator: \frac{1}{2R_3} -> (1/2)R_3
            ops = re.sub(r'\\frac\{([^{}]+)\}\{\(?(\d+)\)?R_(\d+)\}', r'(\1/\2)R_\3', ops)

            # 3) Fix fractions before row reference: \frac{1}{2}R_ -> (1/2)R_
            ops = re.sub(r'\\frac\{([^{}]+)\}\{\(?([^{}]+?)\)?\}R_', r'(\1/\2)R_', ops)

            # 4) Negative fractions -\frac{...}R_ -> (-1/2)R_
            ops = re.sub(r'-\\frac\{([^{}]+)\}\{\(?([^{}]+?)\)?\}R_', r'(-\1/\2)R_', ops)

            # 5) Fix fractions in combines: R_2+\frac{1}{2}R_3 -> R_2+(1/2)R_3
            ops = re.sub(r'([+\-])\\frac\{([^{}]+)\}\{\(?([^{}]+?)\)?\}R_', r'\1(\2/\3)R_', ops)

            # 6) Remove outer wrapping parentheses from row scale expressions
            ops = re.sub(r'\((-?\([^)]+\)R_\d+)\)', r'\1', ops)
            ops = re.sub(
                r'(R_\d+\s*(?:\\to|\\rightarrow|->)\s*)\(([^()]+R_\d+)\)(?=\s*(?:\||$))',
                r'\1\2',
                ops
            )
            ops = re.sub(r'\((R_\d+)\)', r'\1', ops)

            # 7) Remove single-number parentheses before R_: (2)R_1 -> 2R_1; (-2)R_1 -> -2R_1
            ops = re.sub(r'\((\d+)\)R_', r'\1R_', ops)
            ops = re.sub(r'\((-\d+)\)R_', r'\1R_', ops)

            # 7.5 Insert implicit coefficient 1 in row combinations (ONLY in ops_part)
            # Handles: R_2-R_1 -> R_2-1R_1 ; R_2+R_1 -> R_2+1R_1
            ops = re.sub(r'(R_\d+)\s*([+\-])\s*R_', r'\1\g<2>1R_', ops)

            # 7c. Force spaces around + and - inside ops_part so lexer never fuses +5 into a single token
            ops = re.sub(r'([+\-])', r' \1 ', ops)

            # 7d. Canonicalize multiple +/- combos: "--"->"+", "+-"|"-+"->"-"
            ops = re.sub(r'\+\s*\+', ' + ', ops)
            ops = re.sub(r'-\s*-', ' + ', ops)
            ops = re.sub(r'\+\s*-|-\s*\+', ' - ', ops)

            # 8) Clean up multiple spaces in ops
            ops = re.sub(r'\s+', ' ', ops).strip()

        # -------------------------
        # Recombine matrix_part and ops_part (if ops existed)
        # -------------------------
        if ops:
            # Ensure single pipe between matrix and ops
            out = matrix_part.strip() + '|' + ops
        else:
            out = matrix_part.strip()

        # Final cleanup (a little extra safety)
        out = re.sub(r'\|{2,}', '|', out)
        out = re.sub(r'\s+', ' ', out).strip()
        out = re.sub(r'\|\s*$', '', out)  # remove trailing pipe
        # --- Step 7: Final sanity rewrite for self-row combos ---
        # Convert R_n+nR_n ‚Üí R_n-(-n)R_n
            # --- Step 7: Final rewrite for all "+" row operations ---
        # Convert any R_n1 + nR_n2 ‚Üí R_n1 - (-n)R_n2
        out = re.sub(
            r'(R_(\d+))\s*\+\s*([0-9]+)R_(\d+)',
            lambda m: f"{m.group(1)} - (-{m.group(3)})R_{m.group(4)}",
            out
        )

        # Convert any R_n1 + R_n2 ‚Üí R_n1 - (-1)R_n2
        out = re.sub(
            r'(R_(\d+))\s*\+\s*R_(\d+)',
            lambda m: f"{m.group(1)} - (-1)R_{m.group(3)}",
            out
        )

        return out

    def expression_has_matrix_operations(self, latex_str):
      """
      Quick check if a LaTeX expression contains matrix row operations.
      Must have BOTH a pipe AND row operation indicators.
      """
      if not latex_str:
          return False

      # ‚úÖ CRITICAL FIX: Matrix operations MUST have a pipe character
      # This prevents false positives with limits that use \to
      if '|' not in latex_str:
          return False

      # Now check for row operation indicators AFTER the pipe
      indicators = [
          "R_",            # Row reference (most reliable)
          "\\leftarrow",   # Left arrow
          "\\leftrightarrow"  # Swap arrow
      ]

      # Check if any indicator appears after a pipe
      pipe_index = latex_str.find('|')
      if pipe_index >= 0:
          after_pipe = latex_str[pipe_index:]
          return any(ind in after_pipe for ind in indicators)

      return False
  
    def parse_latex(self, latex):
      """Parse LaTeX to SymPy expression with error popup display"""
      import re
      from lark.exceptions import UnexpectedToken, UnexpectedCharacters, UnexpectedEOF

      window.console.log(f"üîç [DEBUG 1] Original LaTeX: {latex}")

      cleaned = self.clean_latex(latex)
      window.console.log(f"üîç [DEBUG 2] After clean_latex: {cleaned}")

      clean = self._preprocess_derivatives(cleaned)
      window.console.log(f"üîç [DEBUG 3] After preprocess_derivatives: {clean}")

      # ‚úÖ FIX: Only preprocess row operations if they actually exist
      if self.expression_has_matrix_operations(clean):
          clean = self._preprocess_row_operations(clean)
          window.console.log(f"üîç [DEBUG 4] After preprocess_row_operations: {clean}")
      else:
          window.console.log(f"üîç [DEBUG 4] No row operations detected, skipping preprocessing")

      window.console.log(f"Cleaned LaTeX: {clean}")

      try:
          window.console.log(f"üîç [DEBUG 5] About to call parser.parse()...")
          tree = self.parser.parse(clean)
          window.console.log(f"üîç [DEBUG 6] Parse successful, tree type: {type(tree)}")

          window.console.log(f"üîç [DEBUG 7] About to call transformer.transform()...")
          result = self.transformer.transform(tree)
          window.console.log(f"üîç Transformed result: {result}")
          return result

      except (UnexpectedToken, UnexpectedCharacters, UnexpectedEOF) as e:
          pos = getattr(e, "pos_in_stream", None)
          line = getattr(e, "line", "?")
          col = getattr(e, "column", "?")

          # Remove "Expected ‚Ä¶" section from Lark message
          raw_msg = str(e)
          simplified_msg = re.sub(r"Expected one of:.*", "", raw_msg, flags=re.DOTALL).strip()

          # Build context with caret pointing to error
          try:
              span = 35
              start = max(0, (pos or 0) - span)
              end = min(len(clean), (pos or 0) + span)
              snippet = clean[start:end]
              caret_pos = (pos or 0) - start
              caret_line = " " * caret_pos + "‚Üë"
              context = f"{snippet}\n{caret_line}"
          except Exception:
              context = clean

          msg = (
              f"‚ùå Parse error in LaTeX:\n\n"
              f"Line: {line}, Column: {col}\n"
              f"Type: {type(e).__name__}\n"
              f"Message: {simplified_msg}\n\n"
              f"Context:\n{context}"
          )
          self._show_error_popup(msg)
          window.console.error(msg)
          return None

      except Exception as e:
          window.console.error(f"‚ùå [DEBUG ERROR] Exception type: {type(e).__name__}")
          window.console.error(f"‚ùå [DEBUG ERROR] Exception message: {str(e)}")
          import traceback
          tb_str = traceback.format_exc()
          window.console.error(f"‚ùå [DEBUG ERROR] Traceback:\n{tb_str}")

          msg = f"‚ùå General parse error: {e}"
          window.console.error(msg)
          self._show_error_popup(msg)
          return None

    def clean_latex(self, tex):
      """Normalize LaTeX string for parsing"""
      import re
      if not tex:
          return ""
      t = str(tex)

      # Remove \left and \right but keep the parentheses
      t = t.replace("\\left(", "(")
      t = t.replace("\\right)", ")")
      t = t.replace("\\left[", "[")
      t = t.replace("\\right]", "]")
      t = t.replace("\\left\\{", "{")
      t = t.replace("\\right\\}", "}")
      t = t.replace("\\left|", "|")
      t = t.replace("\\right|", "|")

      # Replace mathrm{d} with d
      t = t.replace("\\mathrm{d}", "d")

      # Remove spacing macros
      t = re.sub(r"\\(?:,|;|:|!|quad|qquad| )", "", t)

      # Protect matrix row separators
      t = re.sub(r"\\\\\s*", "\\\\", t)

      # Ensure & separators have no surrounding whitespace
      t = re.sub(r"\s*&\s*", "&", t)

      # Remove whitespace
      t = re.sub(r"\s+", "", t)

      # ‚≠ê CRITICAL FIX: Add explicit multiplication for implicit cases
      # IMPORTANT: Apply these BEFORE the digit-letter rule to avoid conflicts

      # 1. Between closing paren and opening paren: )( -> )*(
      t = re.sub(r'\)\s*\(', ')*(', t)

      # 2. Between closing paren and digit: )2 -> )*2
      t = re.sub(r'\)(\d)', r')*\1', t)

      # 3. Between closing paren and letter: )x -> )*x
      t = re.sub(r'\)([a-zA-Z])', r')*\1', t)

      # 4. Between digit and opening paren: 2( -> 2*(
      t = re.sub(r'(\d)\(', r'\1*(', t)

      # 5. Between single letter and opening paren: x( -> x*(, but not for function names like sin(
      t = re.sub(r'(?<![a-zA-Z])([a-zA-Z])\(', r'\1*(', t)

      # 6. Between digit and letter: 2x -> 2*x (original rule, kept last)
      t = re.sub(r'(\d)([a-zA-Z])', r'\1*\2', t)

      return t.strip()

    def _create_transformer(self):
        """Create the Lark transformer with improved rules"""
        from lark import Transformer, v_args
        import sympy as sp

        # ‚úÖ Define canonical_scalar at the top level of this function
        def canonical_scalar(x):
            """Convert/normalize a value to a canonical SymPy scalar (Integer/Rational/Float simplified)."""
            if not isinstance(x, sp.Basic):
                try:
                    x = sp.sympify(x)
                except Exception:
                    return x
            # Prefer exact rationals for floats represented as strings
            if isinstance(x, sp.Float):
                try:
                    x = sp.Rational(str(x))
                except Exception:
                    pass
            # Simplify and evaluate any Mul/Add wrappers (handles Mul(-1,n) -> -n)
            x = sp.simplify(x)
            try:
                x = x.doit()
            except Exception:
                pass
            return sp.simplify(x)
          
        @v_args(inline=True)
        class Latex2Sympy(Transformer):
            _canonical_scalar = canonical_scalar
            def paren_expr(self, expr):
                return expr

            def braces_expr(self, expr):
                return expr

            def number(self, tok):
                s = str(tok)
                return sp.Integer(s) if '.' not in s else sp.Float(s)

            def symbol(self, tok):
                s = str(tok).strip()
                return sp.Symbol(s[1:] if s.startswith("\\") else s)

            def pi_symbol(self, _):
                return sp.pi

            def infty_symbol(self, _):
                return sp.oo

            def infinity(self, tok):
                s = str(tok)
                return -sp.oo if s.startswith('-') else sp.oo

            def abs_func(self, expr):
                return sp.Abs(expr)

            def neg(self, v):
                return sp.Mul(-1, v, evaluate=False)

            def add(self, a, b):
                return sp.Add(a, b, evaluate=False)

            def sub(self, a, b):
                return sp.Add(a, sp.Mul(-1, b, evaluate=False), evaluate=False)

            def mul(self, a, b):
                if isinstance(a, (sp.MatrixBase, sp.MatrixExpr)) or isinstance(b, (sp.MatrixBase, sp.MatrixExpr)):
                    a_ = sp.UnevaluatedExpr(a) if isinstance(a, (sp.MatrixBase, sp.MatrixExpr)) else a
                    b_ = sp.UnevaluatedExpr(b) if isinstance(b, (sp.MatrixBase, sp.MatrixExpr)) else b
                    return sp.Mul(a_, b_, evaluate=False)
                return sp.Mul(a, b, evaluate=True)

            def div(self, a, b):
                return sp.Mul(a, sp.Pow(b, -1, evaluate=False), evaluate=False)

            def frac(self, numerator, denominator):
                return sp.Mul(numerator, sp.Pow(denominator, -1, evaluate=False), evaluate=False)

            def trig_func(self, func_name, expr):
                func_str = str(func_name).strip().replace("\\", "")
                func_map = {
                    "sin": sp.sin,
                    "cos": sp.cos,
                    "tan": sp.tan,
                    "cot": sp.cot,
                    "sec": sp.sec,
                    "csc": sp.csc,
                    "arcsin": sp.asin,
                    "arccos": sp.acos,
                    "arctan": sp.atan,
                }
                func = func_map.get(func_str)
                if func:
                    return func(expr)
                return sp.Function(func_str)(expr)

            def log_func(self, func_name, expr):
                func_str = str(func_name).strip().replace("\\", "")
                if func_str == "ln":
                    return sp.ln(expr)
                elif func_str == "log":
                    return sp.log(expr, 10)
                elif func_str == "exp":
                    return sp.exp(expr)
                return sp.Function(func_str)(expr)

            def limit_expr(self, var, value, expr):
                return sp.Limit(expr, sp.Symbol(str(var)), value)

            def implicit_mul(self, a, b):
                if isinstance(a, sp.Matrix) or isinstance(b, sp.Matrix):
                    return sp.Mul(a, b, evaluate=False)
                return sp.Mul(a, b, evaluate=False)

            def power(self, a, b):
                """
                Handle right-associative power like 10^100^0 correctly.
                Lark gives us nested trees due to right recursion.
                """
                import sympy as sp

                # If right child is another power, handle it recursively.
                # Example: a=10, b=Pow(100, 0) -> Pow(10, (100**0))
                if isinstance(b, sp.Pow):
                    return sp.Pow(a, b, evaluate=False)

                return sp.Pow(a, b, evaluate=False)

            # --- NEW METHOD FOR DEGREES ---
            def atom_to_degree(self, tree):
                """
                Handles expressions like 90^\circ.
                Converts degrees to radians by multiplying by pi/180.
                """
                # tree.children[0] is the already-transformed atom (e.g., the number 90)
                atom = tree.children[0]
                # We don't need tree.children[1] which is the degree_expr
                return sp.pi * atom / 180

            def elements(self, *items):
                return list(items)

            def row(self, elements):
                return list(elements) if isinstance(elements, (list, tuple)) else [elements]

            def matrix_rows(self, *rows):
                row_list = [list(r) if isinstance(r, (list, tuple)) else [r] for r in rows]
                return sp.Matrix(row_list)

            def matrix_env(self, *args):
                rows = []
                for a in args:
                    if a is None:
                        continue
                    if isinstance(a, list) and a and all(isinstance(x, (list, tuple)) for x in a):
                        rows.extend([list(r) for r in a])
                    elif isinstance(a, (list, tuple)):
                        rows.append(list(a))
                    else:
                        rows.append([a])
                return sp.Matrix(rows)

            def scalar_matrix_mul(self, scalar, matrix):
                return sp.Mul(scalar, matrix, evaluate=False)

            def row_reference(self, i):
                return ("ref", int(i))

            def row_scale(self, factor, i):
                return ("scale", int(i), factor)

            def row_replace(self, target, arrow, expr):
                """Row replacement operation - arrow parameter is captured but not used"""
                return ("replace", int(target), expr)

            def row_swap(self, i, swap_arrow, j):
                """Row swap operation - swap_arrow parameter is captured but not used"""
                return ("swap", int(i), int(j))

            def row_combine(self, i, op, factor, j):
                return ("combine", int(i), str(op), factor, int(j))

            def matrix_apply_ops(self, matrix, *ops):
              import sympy as sp
              # Ensure we have a writable SymPy Matrix copy
              m = sp.Matrix(matrix) if not isinstance(matrix, sp.Matrix) else matrix.copy()

              # ‚úÖ Store original matrix and track operations
              original_matrix = m.copy()
              operations_list = []

              # Canonicalize input matrix elements up-front (avoids '- 1' split issues)
              m = m.applyfunc(canonical_scalar)

              for op in ops:
                  # ‚úÖ Record each operation BEFORE applying it
                  operations_list.append({
                      "type": op[0],
                      "details": list(op[1:]) if len(op) > 1 else []
                  })

                  if op[0] == "replace":
                      _, target, expr = op
                      tgt = int(target) - 1  # 0-based

                      if expr[0] == "ref":
                          _, src = expr
                          # copy row to avoid aliasing
                          m[tgt, :] = m[int(src)-1, :].copy()

                      elif expr[0] == "scale":
                          _, src, factor = expr
                          src_row = [canonical_scalar(v) for v in list(m[int(src)-1, :].copy())]
                          factor_sym = canonical_scalar(factor)
                          new_elems = [ canonical_scalar(factor_sym * v) for v in src_row ]
                          m[tgt, :] = sp.Matrix([ new_elems ]).reshape(1, m.cols)

                      elif expr[0] == "combine":
                          _, src, op_str, factor, other = expr
                          src_idx = int(src) - 1
                          other_idx = int(other) - 1

                          # CRITICAL: copy both source rows so we compute from originals
                          src_row = [ canonical_scalar(v) for v in list(m[src_idx, :].copy()) ]
                          other_row = [ canonical_scalar(v) for v in list(m[other_idx, :].copy()) ]

                          factor_sym = canonical_scalar(factor)

                          new_elems = []
                          for a, b in zip(src_row, other_row):
                              if op_str == "+":
                                  val = canonical_scalar(a + factor_sym * b)
                              else:
                                  val = canonical_scalar(a - factor_sym * b)
                              new_elems.append(val)

                          m[tgt, :] = sp.Matrix([ new_elems ]).reshape(1, m.cols)

                  elif op[0] == "swap":
                      _, i, j = op
                      i0, j0 = int(i)-1, int(j)-1
                      temp = m[i0, :].copy()
                      m[i0, :] = m[j0, :].copy()
                      m[j0, :] = temp

              # final pass to ensure everything canonicalized
              result = m.applyfunc(canonical_scalar)

              # ‚úÖ CRITICAL: Store metadata on the FINAL result matrix
              # This preserves the operation history even after canonicalization
              result._matrix_op_metadata = {
                  "operations": operations_list,
                  "original_shape": (original_matrix.rows, original_matrix.cols)
              }

              window.console.log(f"‚úÖ Stored metadata on matrix with {len(operations_list)} operation(s)")

              return result

            # --- METHODS FOR PREPROCESSED DERIVATIVES ---
            def derivative_func(self, var, expr):
                """Handles the preprocessed __derivative(var, expr) call."""
                return sp.Derivative(expr, sp.Symbol(str(var)))

            def partial_derivative_func(self, var, expr):
                """Handles the preprocessed __partial_derivative(var, expr) call."""
                return sp.Derivative(expr, sp.Symbol(str(var)))

            def start(self, e):
                return e

        return Latex2Sympy()

    def validate_limit(self, limit_expr):
        """
        Validate if a limit problem is suitable for students.
        Returns (is_valid, error_message)

        Invalid cases:
        1. Different left and right limit values (discontinuity)
        2. Oscillating limits (e.g., sin(1/x) as x->0)
        3. Limits that evaluate to infinity
        """
        import sympy as sp

        if not isinstance(limit_expr, sp.Limit):
            return (True, None)  # Not a limit, skip validation

        try:
            # Get the limit components
            expr = limit_expr.args[0]
            var = limit_expr.args[1]
            point = limit_expr.args[2]

            # Evaluate the limit
            limit_value = limit_expr.doit()

            # Check 1: Limit evaluates to infinity
            if limit_value.has(sp.oo) or limit_value == sp.oo or limit_value == -sp.oo:
                return (False, f"Limit evaluates to infinity: {limit_value}")

            # Check 2: Limit does not exist (returns unevaluated or NaN)
            if isinstance(limit_value, sp.Limit) or limit_value is sp.nan:
                return (False, "Limit does not exist or cannot be determined")

            # Check 3: Different left and right limits (if approaching a finite point)
            if point != sp.oo and point != -sp.oo:
                try:
                    left_limit = sp.limit(expr, var, point, '-')
                    right_limit = sp.limit(expr, var, point, '+')

                    # Simplify both limits
                    left_simplified = sp.simplify(left_limit)
                    right_simplified = sp.simplify(right_limit)

                    # Check if they're different
                    if not sp.simplify(left_simplified - right_simplified) == 0:
                        return (False, f"Left and right limits differ: left={left_simplified}, right={right_simplified}")
                except:
                    pass

            # Check 4: Oscillating behavior (limit doesn't exist due to oscillation)
            # This is tricky - we check if the limit is AccumBounds or contains zoo
            if hasattr(limit_value, 'is_finite') and not limit_value.is_finite:
                if limit_value != sp.oo and limit_value != -sp.oo:
                    return (False, "Limit oscillates or is undefined")

            # Check for AccumBounds (accumulated bounds, indicates oscillation)
            if 'AccumBounds' in str(type(limit_value)):
                return (False, "Limit oscillates between multiple values")

            # Check for zoo (complex infinity, often from oscillation)
            if limit_value == sp.zoo:
                return (False, "Limit is complex infinity (oscillation or undefined)")

            return (True, None)

        except Exception as e:
            window.console.error(f"Error validating limit: {e}")
            return (False, f"Error evaluating limit: {str(e)}")

    def normalize_expr(self, expr):
        """Normalize and simplify expressions - with better sanity check"""
        import sympy as sp

        if expr is None:
            return None

        try:
            window.console.log(f"üîß NORMALIZE INPUT: {expr}")
            window.console.log(f"üîß NORMALIZE INPUT (srepr): {sp.srepr(expr)}")

            # Store original for comparison
            original_expr = expr

            if hasattr(expr, "doit"):
                window.console.log(f"DEBUG: Expression has doit, calling it...") 
                expr = expr.doit()
                window.console.log(f"DEBUG: After doit: {expr}")
                window.console.log(f"DEBUG: After doit (srepr): {sp.srepr(expr)}")

            if isinstance(expr, list):
                expr = sp.Matrix(expr)
            if isinstance(expr, sp.Matrix):
                expr = expr.applyfunc(sp.simplify)
            else:
                if isinstance(expr, sp.Mul) and not expr.is_Number:
                    args = expr.args
                    has_matrix = any(isinstance(a, sp.Matrix) for a in args)
                    has_scalar = any(not isinstance(a, sp.Matrix) for a in args)
                    if has_matrix and has_scalar:
                        return sp.Mul(*args, evaluate=True)

                # Store expression after doit but before simplify
                after_doit = expr
                window.console.log(f"üîß Before simplify: {after_doit}")

                # ‚úÖ LIGHT normalization
                expr = sp.simplify(expr)
                window.console.log(f"üîß NORMALIZE OUTPUT: {expr}")
                window.console.log(f"üîß NORMALIZE OUTPUT (srepr): {sp.srepr(expr)}")

                # ‚úÖ IMPROVED SANITY CHECK: Test multiple values
                try:
                    free_syms = list(original_expr.free_symbols)
                    if free_syms:
                        # Test with multiple values including 2.5, 3.7, -1.5
                        test_values = [2.5, 3.7, -1.5, 10.0]

                        for test_x in test_values:
                            test_subs = {sym: test_x for sym in free_syms}

                            # Evaluate both
                            try:
                                original_numeric = complex(original_expr.subs(test_subs))
                                normalized_numeric = complex(expr.subs(test_subs))
                                after_doit_numeric = complex(after_doit.subs(test_subs))

                                diff_orig_norm = abs(original_numeric - normalized_numeric)
                                diff_doit_norm = abs(after_doit_numeric - normalized_numeric)

                                window.console.log(f"Test @ x={test_x}:")
                                window.console.log(f"  Original: {original_numeric}")
                                window.console.log(f"  After doit: {after_doit_numeric}")
                                window.console.log(f"  After simplify: {normalized_numeric}")
                                window.console.log(f"  Diff (orig vs norm): {diff_orig_norm}")
                                window.console.log(f"  Diff (doit vs norm): {diff_doit_norm}")

                                if diff_orig_norm > 1e-6:
                                    window.console.error(f"‚ö†Ô∏è NORMALIZATION BROKE EXPRESSION at x={test_x}!")
                                    window.console.error(f"   Difference: {diff_orig_norm}")
                                    # Return the expression after doit, not after simplify
                                    window.console.error(f"   Returning after-doit version instead")
                                    return after_doit

                            except (ZeroDivisionError, OverflowError) as e:
                                window.console.warn(f"  Skipping x={test_x} due to: {e}")
                                continue

                        window.console.log(f"‚úì Sanity check passed all test values")
                except Exception as sanity_err:
                    window.console.warn(f"‚ö†Ô∏è Sanity check failed (non-fatal): {sanity_err}")

        except Exception as e:
            window.console.error(f"ERROR inside normalize: {e}")
            import traceback
            window.console.error(traceback.format_exc())
            return expr

        return expr

    def final_eq(self, a, b):
        """Check equality for scalar or matrix expressions with multiple strategies"""
        import sympy as sp
        try:
            # Handle matrix comparisons
            if isinstance(a, sp.MatrixBase) and isinstance(b, sp.MatrixBase):
                if a.shape != b.shape:
                    return False
                for i in range(a.rows):
                    for j in range(a.cols):
                        if not sp.simplify(a[i, j] - b[i, j]) == 0:
                            return False
                return True
            if isinstance(a, sp.MatrixBase) and isinstance(b, list):
                return self.final_eq(a, sp.Matrix(b))
            if isinstance(b, sp.MatrixBase) and isinstance(a, list):
                return self.final_eq(sp.Matrix(a), b)

            # ‚úÖ STRATEGY: Multiple passes with increasing aggressiveness
            # This handles expressions built with evaluate=False

            # Strategy 1: Direct comparison (fastest, handles simple cases)
            try:
                if a == b:
                    window.console.log("‚úì Strategy 1: Direct comparison succeeded")
                    return True
            except:
                pass

            # Strategy 2: Simplify difference (handles most cases)
            try:
                diff = sp.simplify(a - b)
                if diff == 0:
                    window.console.log("‚úì Strategy 2: Simplify difference succeeded")
                    return True
            except:
                pass

            # Strategy 3: Expand then simplify (handles unevaluated Mul/Add with evaluate=False)
            try:
                a_expanded = sp.expand(a)
                b_expanded = sp.expand(b)
                diff = sp.simplify(a_expanded - b_expanded)
                if diff == 0:
                    window.console.log("‚úì Strategy 3: Expand then simplify succeeded")
                    return True
            except:
                pass

            # Strategy 4: Full normalization pipeline (handles complex cases)
            try:
                # Apply multiple simplification passes
                a_norm = sp.simplify(sp.expand(a))
                b_norm = sp.simplify(sp.expand(b))

                # Try difference first
                diff = sp.simplify(a_norm - b_norm)
                if diff == 0:
                    window.console.log("‚úì Strategy 4a: Normalized difference succeeded")
                    return True

                # Try direct comparison
                if a_norm == b_norm:
                    window.console.log("‚úì Strategy 4b: Normalized direct comparison succeeded")
                    return True
            except:
                pass

            # Strategy 5: PowerSimp + Collect (handles nested powers and like terms)
            try:
                a_processed = sp.simplify(sp.powsimp(sp.expand(a), force=True))
                b_processed = sp.simplify(sp.powsimp(sp.expand(b), force=True))

                diff = sp.simplify(a_processed - b_processed)
                if diff == 0:
                    window.console.log("‚úì Strategy 5: PowerSimp succeeded")
                    return True
            except:
                pass

            # Strategy 6: SymPy's equals method (most robust but slowest)
            try:
                result = a.equals(b)
                if result:
                    window.console.log("‚úì Strategy 6: equals() method succeeded")
                return result
            except:
                pass

            window.console.log("‚úó All comparison strategies failed")
            return False

        except Exception as e:
            window.console.error(f"final_eq error: {e}")
            # Last resort: try equals method
            try:
                return a.equals(b)
            except:
                return False
          
    def structural_match(self, expr1, expr2, tolerance='strict'):
      """
      Compare expressions structurally, not just mathematically.

      tolerance levels:
      - 'strict': Must have identical structure
      - 'loose': Allow minor differences (commutativity, associativity)
      - 'math': Full mathematical equivalence (same as final_eq)
      """
      import sympy as sp

      if expr1 is None or expr2 is None:
          return False

      window.console.log(f"üîç Structural match check (tolerance={tolerance})")
      window.console.log(f"   expr1: {expr1}")
      window.console.log(f"   expr2: {expr2}")
      window.console.log(f"   expr1 srepr: {sp.srepr(expr1)}")
      window.console.log(f"   expr2 srepr: {sp.srepr(expr2)}")

      if tolerance == 'math':
          # Use full mathematical equivalence
          return self.final_eq(expr1, expr2)

      # Extract structures
      struct1 = self.extract_structure(expr1)
      struct2 = self.extract_structure(expr2)

      window.console.log(f"   struct1 operators: {struct1['operators']}")
      window.console.log(f"   struct2 operators: {struct2['operators']}")
      window.console.log(f"   struct1 operands: {struct1['operands']}")
      window.console.log(f"   struct2 operands: {struct2['operands']}")

      if tolerance == 'strict':
          # Strict: operators and operands must match exactly
          operators_match = struct1['operators'] == struct2['operators']
          operands_match = struct1['operands'] == struct2['operands']

          window.console.log(f"   operators_match: {operators_match}")
          window.console.log(f"   operands_match: {operands_match}")

          if operators_match and operands_match:
              window.console.log("‚úÖ Strict structural match: PASS")
              return True
          else:
              window.console.log("‚ùå Strict structural match: FAIL")
              # Try mathematical equivalence as fallback
              math_eq = self.final_eq(expr1, expr2)
              if math_eq:
                  window.console.log("‚ö†Ô∏è Expressions are mathematically equivalent but structurally different")
              return False

      elif tolerance == 'loose':
          # Loose: Allow some flexibility but check overall structure
          # Check if operator counts are similar
          ops1_total = struct1['total_ops']
          ops2_total = struct2['total_ops']

          # Allow ¬±1 difference in operator count
          if abs(ops1_total - ops2_total) > 1:
              window.console.log(f"‚ùå Loose structural match: operator count difference too large")
              return False

          # Check if main operators are present
          ops1_set = set(struct1['operators'].keys())
          ops2_set = set(struct2['operators'].keys())

          if ops1_set != ops2_set:
              window.console.log(f"‚ùå Loose structural match: different operator types")
              return False

          window.console.log("‚úÖ Loose structural match: PASS")
          return True

      return False
    
    def extract_structure(self, expr):
      """
      Extract structural fingerprint of expression INCLUDING matrix operations.
      Normalizes all numeric values to consistent float representation for reliable comparison.
      """
      import sympy as sp, traceback
      operators, operands, matrix_ops = {}, {}, []

      def normalize_numeric_to_string(node):
          """
          Convert any numeric value to normalized string representation.
          Rational(1, 2) ‚Üí "0.5"
          Integer(2) ‚Üí "2.0" 
          Float(0.5) ‚Üí "0.5"
          """
          try:
              # Check if it's a SymPy numeric type
              if isinstance(node, sp.Basic):
                  if hasattr(node, 'is_number') and node.is_number:
                      # Convert to float for consistency
                      float_val = float(node.evalf())
                      # Check if it's effectively an integer
                      if float_val == int(float_val):
                          return str(int(float_val))
                      else:
                          return str(float_val)

              # Check if it's a Python numeric type
              if isinstance(node, (int, float)):
                  if isinstance(node, int) or float(node) == int(float(node)):
                      return str(int(node))
                  else:
                      return str(float(node))

              # Try to parse as number from string
              node_str = str(node)
              if '/' in node_str:
                  # Handle fraction strings like "1/2"
                  parts = node_str.split('/')
                  if len(parts) == 2:
                      try:
                          num = float(parts[0].strip())
                          denom = float(parts[1].strip())
                          if denom != 0:
                              result = num / denom
                              if result == int(result):
                                  return str(int(result))
                              else:
                                  return str(result)
                      except:
                          pass

              # Try direct float conversion
              try:
                  float_val = float(node_str)
                  if float_val == int(float_val):
                      return str(int(float_val))
                  else:
                      return str(float_val)
              except:
                  pass

          except Exception as e:
              window.console.log(f"normalize_numeric_to_string error: {e}")

          # If all else fails, return string representation
          return str(node).strip().replace(" ", "")

      def normalize_matrix_metadata(metadata):
          """
          Normalize matrix operation metadata to ensure consistent numeric representation.
          """
          if not metadata or not isinstance(metadata, dict):
              return metadata

          normalized = {
              "type": metadata.get("type"),
              "operations": [],
              "original_shape": metadata.get("original_shape")
          }

          for operation in metadata.get("operations", []):
              normalized_op = {
                  "type": operation.get("type"),
                  "details": normalize_details_list(operation.get("details", []))
              }
              normalized["operations"].append(normalized_op)

          return normalized

      def normalize_details_list(details):
          """
          Recursively normalize a list/tuple of operation details.
          Converts nested structures and numeric values.
          """
          if details is None:
              return []

          if not isinstance(details, (list, tuple)):
              details = [details]

          normalized = []
          for item in details:
              if isinstance(item, (list, tuple)):
                  # Recursively normalize nested structures
                  normalized.append(normalize_details_list(item))
              elif isinstance(item, str):
                  # Keep strings as-is (like "scale", "swap", etc.)
                  normalized.append(item)
              else:
                  # Normalize numeric values
                  normalized.append(normalize_numeric_to_string(item))

          return normalized

      def process(node, parent_op=None):
          nonlocal matrix_ops

          if node is None:
              return

          # Skip tuple coordinates from matrix indexing
          if isinstance(node, (tuple, list)) and all(isinstance(i, sp.Integer) for i in node):
              return

          # ‚úÖ CRITICAL: Detect matrix operations by checking for metadata
          if isinstance(node, sp.MatrixBase):
              # Check if this matrix has row operation metadata
              if hasattr(node, '_matrix_op_metadata'):
                  metadata = node._matrix_op_metadata

                  # Normalize the metadata before storing
                  normalized_metadata = normalize_matrix_metadata(metadata)

                  matrix_ops.append({
                      "type": "matrix_with_row_ops",
                      "operations": normalized_metadata["operations"],
                      "original_shape": normalized_metadata["original_shape"]
                  })

                  window.console.log(f"‚úÖ Found matrix with {len(metadata['operations'])} operation(s)")
                  window.console.log(f"   Normalized operations: {normalized_metadata['operations']}")
              else:
                  window.console.log(f"‚ÑπÔ∏è Matrix has no _matrix_op_metadata attribute")

              # Process matrix elements
              for el in node:
                  process(el, parent_op)
              return

          # Handle MatrixExpr (symbolic matrix operations)
          if isinstance(node, sp.MatrixExpr) and not isinstance(node, sp.MatrixBase):
              val = normalize_numeric_to_string(node)
              operands[val] = operands.get(val, 0) + 1
              return

          # Check if this is a Mul(-1, x) pattern (negation)
          if isinstance(node, sp.Mul) and len(node.args) == 2:
              a, b = node.args
              if a == sp.Integer(-1) and isinstance(b, (sp.Symbol, sp.Number)):
                  # Simplify Mul(-1, x) to -x
                  simplified = sp.simplify(node)
                  val = normalize_numeric_to_string(simplified)
                  operands[val] = operands.get(val, 0) + 1
                  window.console.log(f"‚úÖ Simplified Mul(-1, {b}) -> {val}")
                  return

          # Handle nodes with arguments (operators)
          if hasattr(node, "args") and len(node.args) > 0:
              op_name = type(node).__name__

              # Skip Tuple nodes
              if op_name == "Tuple":
                  for c in node.args:
                      process(c, parent_op)
                  return

              # Don't double-count nested Mul operations
              if not (op_name == "Mul" and (parent_op == "Mul" or len(node.args) == 1)):
                  operators[op_name] = operators.get(op_name, 0) + 1

              # Recursively process children
              for c in node.args:
                  process(c, op_name)
              return

          # Handle leaf nodes (operands) - NORMALIZE HERE
          val = normalize_numeric_to_string(node)

          # Skip -1 as it's usually part of subtraction/negation
          if val == "-1":
              return

          operands[val] = operands.get(val, 0) + 1

      try:
          process(expr)
      except Exception as e:
          window.console.log(f"extract_structure error: {e}")
          window.console.log(traceback.format_exc())

      result = {
          "operators": operators,
          "operands": operands,
          "matrix_ops": matrix_ops,
          "total_ops": sum(operators.values()),
          "total_operands": sum(operands.values())
      }

      window.console.log(f"üìä Extracted structure: {len(matrix_ops)} matrix operation(s)")
      if matrix_ops:
          window.console.log(f"   Matrix ops details: {matrix_ops}")

      return result
    

# ============================================================================
# End of MathParser Class
# Now you can use: self.math_parser = MathParser()
# ============================================================================

class ScoreRecalculationTracker:
    """Tracks edits and triggers score recalculation based on rules"""
    def __init__(self, app_instance):
        self.app = app_instance
        self.edited_steps = set()  # Current session edits: set of (problem_idx, step_idx) tuples
        self.first_time_edits_in_session = set()  # NEW: Track which current session edits are first-time
        self.ever_edited_steps = set()  # All-time edited steps: set of (problem_idx, step_idx) tuples (never reset)
        self.last_edit_time = None
        self.timer_handle = None
        self.pending_edits = {}  # {(problem_idx, step_idx): new_answer}
        self.current_problem_idx = None
    
    def reset(self):
        """Reset current session tracking state (but keep ever_edited_steps)"""
        window.console.log("üîÑ Resetting score recalculation tracker")
        self.edited_steps.clear()
        self.first_time_edits_in_session.clear()  # NEW: Clear first-time tracking
        self.pending_edits.clear()
        self.last_edit_time = None
        if self.timer_handle:
            window.clearTimeout(self.timer_handle)
            self.timer_handle = None
    
    def add_edit(self, problem_idx, step_idx, new_answer):
        """Called when user edits an answer"""
        import datetime
        
        self.current_problem_idx = problem_idx
        
        # Create a unique key for this edit (global across all problems)
        edit_key = (problem_idx, step_idx)
        
        # ‚úÖ Track if this is a first-time edit BEFORE adding to ever_edited_steps
        is_first_time_edit = edit_key not in self.ever_edited_steps
        
        # Add to current session
        self.edited_steps.add(edit_key)
        
        # ‚úÖ Track first-time status for this session
        if is_first_time_edit:
            self.first_time_edits_in_session.add(edit_key)
        
        # Add to all-time tracking
        self.ever_edited_steps.add(edit_key)
        
        self.last_edit_time = datetime.datetime.now()
        self.pending_edits[edit_key] = new_answer
        
        window.console.log(f"üìù Edit tracked: problem {problem_idx}, step {step_idx}, first-time: {is_first_time_edit}")
        window.console.log(f"   Current session: {len(self.edited_steps)} edits, {len(self.first_time_edits_in_session)} first-time")
        window.console.log(f"   Ever edited (global): {len(self.ever_edited_steps)}")
        
        # Cancel existing timer if any
        if self.timer_handle:
            window.clearTimeout(self.timer_handle)
            self.timer_handle = None
        
        # ‚úÖ Check if we have at least 2 first-time edits in current session
        if len(self.first_time_edits_in_session) >= 2:
            window.console.log("‚úÖ At least 2 first-time edits detected (global) - triggering immediate recalculation")
            self.trigger_recalculation("2_edits")
        else:
            window.console.log(f"‚è±Ô∏è Only {len(self.first_time_edits_in_session)} first-time edit(s) - starting 5-minute timer")
            def timer_callback():
                self.trigger_recalculation("5_minutes")
            self.timer_handle = window.setTimeout(create_proxy(timer_callback), 5 * 60 * 1000)
            self.update_ui_message()
    
    def trigger_recalculation(self, reason):
        """Recalculate score and reset"""
        window.console.log(f"üî¢ Triggering score recalculation: {reason}")
        
        # Apply all pending edits to problem_states
        for (prob_idx, step_idx), answer in self.pending_edits.items():
            if prob_idx in self.app.problem_states:
                if step_idx < len(self.app.problem_states[prob_idx]):
                    self.app.problem_states[prob_idx][step_idx]["user_answers"] = answer
                    window.console.log(f"  Applied edit to problem {prob_idx}, step {step_idx}: {answer}")
        
        self.app.save_to_storage()
        
        self.show_recalculation_message(reason)
        
        def show_updated_score():
            total_score, max_score, percentage = self.app.calculate_total_score()
            
            self.app.update_score_display_in_review(percentage)
            
            self.reset()
            
            window.console.log(f"‚úÖ Score updated: {percentage:.1f}%")
        
        window.setTimeout(create_proxy(show_updated_score), 2000)
    
    def show_recalculation_message(self, reason):
        """Show message during recalculation"""
        msg_el = document.querySelector("#reviewScoreMessage")
        if msg_el:
            if reason == "2_edits":
                msg_el.innerHTML = """
                <div style='background:#dbeafe;color:#1e40af;padding:12px;border-radius:6px;text-align:center;'>
                    ‚úÖ 2 edits detected - Recalculating score... ‚è≥
                </div>
                """
            else:
                msg_el.innerHTML = """
                <div style='background:#dbeafe;color:#1e40af;padding:12px;border-radius:6px;text-align:center;'>
                    ‚è±Ô∏è 5 minutes elapsed - Recalculating score... ‚è≥
                </div>
                """
    
    def update_ui_message(self):
        """Update the UI to show current status"""
        import datetime
        
        count = len(self.edited_steps)
        first_time_count = len(self.first_time_edits_in_session)
        
        msg_el = document.querySelector("#reviewScoreMessage")
        if not msg_el:
            return
        
        if self.last_edit_time:
            elapsed = (datetime.datetime.now() - self.last_edit_time).total_seconds()
            remaining = max(0, 5 * 60 - elapsed)
            
            if remaining > 60:
                time_str = f"{int(remaining/60)}:{int(remaining%60):02d}"
            else:
                time_str = f"{int(remaining)} seconds"
            
            if first_time_count < 2:
                msg_el.innerHTML = f"""
                <div style='background:#fef3c7;color:#92400e;padding:12px;border-radius:6px;text-align:center;'>
                    <div style='font-weight:600;margin-bottom:4px;'>üìù {first_time_count}/2 first-time edits made</div>
                    <div style='font-size:14px;'>Edit another <strong>first-time</strong> step to update score immediately</div>
                    <div style='font-size:13px;margin-top:4px;'>or wait {time_str} for automatic update</div>
                    <div style='font-size:12px;margin-top:6px;color:#78350f;'>Total edits this session: {count} ({first_time_count} first-time, {count - first_time_count} re-edit)</div>
                </div>
                """
                
                def update_countdown():
                    if len(self.first_time_edits_in_session) < 2:
                        self.update_ui_message()
                window.setTimeout(create_proxy(update_countdown), 1000)
                

class ProblemSolverApp:
    # ============================================
    # COMPLETE REVIEW SYSTEM - Only shows when ALL problems done
    # ============================================

    def show_review_section(self):
        """Show the review section - ONLY after all problems are complete"""
        window.console.log("üìä Checking if review can be shown...")

        # ‚úÖ CHECK: All problems must be complete
        if not self._all_problems_complete():
            window.console.log("‚ö†Ô∏è Not all problems are complete yet. Review not shown.")
            return

        window.console.log("‚úÖ All problems complete! Building review section...")

        # Calculate total score
        total_score, max_score, problem_scores = self.calculate_total_score()
        if max_score > 0:
            percentage = (total_score / max_score) * 100
        else:
            percentage = 0

        window.console.log(f"Final score: {percentage:.1f}% ({total_score:.1f}/{max_score:.1f})")

        # Find or create review container
        review_container = document.querySelector("#reviewSectionContainer")
        if not review_container:
            review_container = document.createElement("div")
            review_container.id = "reviewSectionContainer"

            main_content = document.querySelector("#solveProblemsContainer")
            if main_content:
                main_content.appendChild(review_container)

        # Clear existing content
        review_container.innerHTML = ""

        # Create review section
        review_section = document.createElement("div")
        review_section.id = "reviewSection_all"
        review_section.className = "review-section"
        review_section.style.cssText = """
            background: #ffffff;
            border-radius: 12px;
            padding: 24px;
            margin-bottom: 20px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        """

        # Add header with completion message
        header = document.createElement("div")
        header.style.cssText = "margin-bottom: 20px;"
        header.innerHTML = """
            <div style="background: linear-gradient(135deg, #10b981, #059669); color: white; padding: 16px; border-radius: 8px; margin-bottom: 16px; text-align: center;">
                <div style="font-size: 32px; margin-bottom: 8px;">üéâ</div>
                <div style="font-size: 20px; font-weight: 700;">Congratulations!</div>
                <div style="font-size: 14px; opacity: 0.9; margin-top: 4px;">You've completed all problems in this set</div>
            </div>
            <h2 style="margin: 0 0 8px 0; color: #1e293b; font-size: 24px;">
                üìä Problem Set Review
            </h2>
            <p style="color: #64748b; margin: 0; font-size: 14px;">
                Review all your answers and edit if needed
            </p>
        """
        review_section.appendChild(header)

        # Add score message div (for edit tracking messages)
        score_msg_div = document.createElement("div")
        score_msg_div.id = "reviewScoreMessage"
        score_msg_div.style.cssText = "margin-bottom: 16px;"
        review_section.appendChild(score_msg_div)

        # Add overall score display
        score_display = document.createElement("div")
        score_display.id = "overallScoreDisplay"
        score_display.style.cssText = """
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 24px;
            text-align: center;
        """
        score_display.innerHTML = f"""
            <div style="font-size: 14px; opacity: 0.9; margin-bottom: 4px;">Overall Score</div>
            <div style="font-size: 48px; font-weight: 700;">{percentage:.1f}%</div>
            <div style="font-size: 14px; opacity: 0.9; margin-top: 4px;">
                {total_score:.1f} / {max_score:.1f} points
            </div>
        """
        review_section.appendChild(score_display)

        # Add each problem's review
        for prob_idx in sorted(self.problem_states.keys()):
            score_info = problem_scores.get(prob_idx, {'score': 0, 'max_score': 0, 'percentage': 0})
            problem_review = self._create_problem_review(prob_idx, score_info)
            review_section.appendChild(problem_review)

        review_container.appendChild(review_section)

        # Scroll to review
        review_section.scrollIntoView({'behavior': 'smooth', 'block': 'start'})

        window.console.log("‚úÖ Review section displayed")


    def _all_problems_complete(self):
        """Check if ALL problems in the problem set are complete"""
        if not self.problem_states:
            return False

        for prob_idx in self.problem_states.keys():
            if not self.is_problem_complete(prob_idx):
                window.console.log(f"Problem {prob_idx} is not complete yet")
                return False

        return True


    def _create_problem_review(self, prob_idx, score_data):
        """Create review section for a single problem"""
        problem_container = document.createElement("div")
        problem_container.className = "problem-review"
        problem_container.style.cssText = """
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 16px;
            background: #f8fafc;
        """

        # Problem header
        prob_score = score_data.get('score', 0)
        prob_max = score_data.get('max_score', 0)
        prob_pct = (prob_score / prob_max * 100) if prob_max > 0 else 0

        header = document.createElement("div")
        header.style.cssText = """
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 2px solid #e2e8f0;
        """
        header.innerHTML = f"""
            <div>
                <h3 style="margin: 0; color: #1e293b; font-size: 18px;">Problem {prob_idx + 1}</h3>
            </div>
            <div style="text-align: right;">
                <div style="font-size: 24px; font-weight: 700; color: #3b82f6;">{prob_pct:.1f}%</div>
                <div style="font-size: 12px; color: #64748b;">{prob_score:.1f} / {prob_max:.1f}</div>
            </div>
        """
        problem_container.appendChild(header)

        # Add each step's review
        if prob_idx in self.problem_states:
            for step_idx, step_data in enumerate(self.problem_states[prob_idx]):
                step_review = self._create_step_review(prob_idx, step_idx, step_data)
                problem_container.appendChild(step_review)

        return problem_container


    def _create_step_review(self, prob_idx, step_idx, step_data):
        """Create review display for a single step"""
        step_container = document.createElement("div")
        step_container.className = "step-review"
        step_container.style.cssText = """
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 12px;
        """

        # Step header with edit button
        step_header = document.createElement("div")
        step_header.style.cssText = """
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        """

        is_correct = step_data.get("finished", False) and step_data.get("correct", False)
        status_icon = "‚úÖ" if is_correct else "‚ùå"
        status_color = "#10b981" if is_correct else "#ef4444"

        step_header.innerHTML = f"""
            <div style="font-weight: 600; color: #475569;">
                Step {step_idx + 1} <span style="color: {status_color};">{status_icon}</span>
            </div>
            <button class="edit-step-btn" data-problem="{prob_idx}" data-step="{step_idx}"
                    style="padding: 6px 12px; background: #3b82f6; color: white; border: none; 
                           border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: 500;">
                ‚úèÔ∏è Edit
            </button>
        """
        step_container.appendChild(step_header)

        # Question text
        question = step_data.get("question", "") or step_data.get("description", "") or step_data.get("text", "")
        if question:
            q_div = document.createElement("div")
            q_div.style.cssText = "margin-bottom: 12px; color: #334155; font-size: 14px;"
            q_div.innerHTML = question
            step_container.appendChild(q_div)

        # User's answer
        user_answers = step_data.get("user_answers", [])
        answer_div = document.createElement("div")
        answer_div.style.cssText = f"""
            background: {'#f0fdf4' if is_correct else '#fef2f2'};
            border-left: 4px solid {status_color};
            padding: 12px;
            border-radius: 6px;
            font-size: 14px;
        """

        if user_answers:
            if len(user_answers) == 1:
                answer_text = str(user_answers[0])
            else:
                answer_text = ", ".join([str(ans) for ans in user_answers])

            answer_div.innerHTML = f"""
                <div style="font-weight: 600; color: #475569; margin-bottom: 4px;">Your Answer:</div>
                <div style="color: #1e293b;">{answer_text}</div>
            """
        else:
            answer_div.innerHTML = '<div style="color: #64748b; font-style: italic;">No answer provided</div>'

        step_container.appendChild(answer_div)

        # Add click handler to edit button
        def make_edit_handler(p_idx, s_idx):
            def handler(e):
                self.edit_answer_from_review(p_idx, s_idx)
            return handler

        edit_btn = step_container.querySelector(".edit-step-btn")
        if edit_btn:
            edit_btn.addEventListener("click", create_proxy(make_edit_handler(prob_idx, step_idx)))

        return step_container


    def calculate_total_score(self):
        """Calculate the total score across all problems"""
        total_score = 0
        max_score = 0
        problem_scores = {}

        for prob_idx, steps in self.problem_states.items():
            prob_score = 0
            prob_max = 0

            for step in steps:
                if step.get("finished", False):
                    step_points = step.get("points", 1)
                    prob_max += step_points

                    if step.get("correct", False):
                        prob_score += step_points

            problem_scores[prob_idx] = {
                'score': prob_score,
                'max_score': prob_max,
                'percentage': (prob_score / prob_max * 100) if prob_max > 0 else 0
            }

            total_score += prob_score
            max_score += prob_max

        return total_score, max_score, problem_scores


    def update_score_display_in_review(self, percentage):
      """Update the score display in the review section"""
      score_display = document.querySelector("#overallScoreDisplay")
      if score_display:
          # ‚úÖ FIXED: Get fresh scores
          total_score, max_score, _ = self.calculate_total_score()

          score_display.innerHTML = f"""
              <div style="font-size: 14px; opacity: 0.9; margin-bottom: 4px;">Overall Score</div>
              <div style="font-size: 48px; font-weight: 700;">{percentage:.1f}%</div>
              <div style="font-size: 14px; opacity: 0.9; margin-top: 4px;">
                  {total_score:.1f} / {max_score:.1f} points
              </div>
          """

          window.console.log(f"‚úÖ Score display updated: {percentage:.1f}%")


    def is_problem_complete(self, prob_idx):
        """Check if all steps in a problem are finished"""
        if prob_idx not in self.problem_states:
            return False

        for step in self.problem_states[prob_idx]:
            if not step.get("finished", False):
                return False

        return True


    def count_finished_steps(self, prob_idx):
        """Count how many steps are finished in a problem"""
        if prob_idx not in self.problem_states:
            return 0

        count = 0
        for step in self.problem_states[prob_idx]:
            if step.get("finished", False):
                count += 1

        return count
    # COMPLETE save_answer_from_review() METHOD
    # Integrates: Score tracking, validation, all step types, deferred display

    def save_answer_from_review(self, problem_idx, step_idx):
        """Save the edited answer and return to review - COMPLETE VERSION"""
        window.console.log(f"üíæ Saving edited answer: problem {problem_idx}, step {step_idx}")

        try:
            # ============================================
            # PART 1: VALIDATION - Ensure everything exists
            # ============================================

            # Validate problem state exists
            if problem_idx not in self.solve_states:
                window.console.error("‚ùå No solve_state found")
                window.alert("‚ùå Error: Problem state not found!")
                return

            solve_state = self.solve_states[problem_idx]

            # Validate step index
            if step_idx >= len(solve_state):
                window.console.error(f"‚ùå Invalid step index: {step_idx}")
                window.alert(f"‚ùå Error: Invalid step index {step_idx}")
                return

            step = solve_state[step_idx]
            container = step.get("container")

            if not container:
                window.console.error(f"‚ùå Container not found for step {step_idx}")
                window.alert("‚ùå Error: Step container not found")
                return

            # ‚úÖ Get step_type from solve_state, or fallback to original problem data
            step_type = step.get("step_type", "unknown")

            # If step_type is unknown, try to get it from original problem data
            if step_type == "unknown":
                if problem_idx < len(self.problem_set):
                    problem = self.problem_set[problem_idx]
                    steps = problem.get("steps", [])
                    if step_idx < len(steps):
                        step_type = steps[step_idx].get("step_type", "math-expression")
                        if step_type == "step-by-step":
                            step_type = "math-expression"
                        window.console.log(f"‚úÖ Retrieved step_type from original data: {step_type}")

            window.console.log(f"üìù Step type: {step_type}")

            # ============================================
            # PART 2: CAPTURE ANSWER - Based on step type
            # ============================================

            new_answer = None

            if step_type == "multiple-choice-single":
                window.console.log("üìù Capturing multiple-choice-single answer")
                radio = container.querySelector(f"input[name='mc_single_{step_idx}']:checked")
                if radio:
                    new_answer = [radio.value]
                    window.console.log(f"‚úÖ Captured answer: {new_answer}")
                else:
                    window.console.warn("‚ö†Ô∏è No radio button selected")
                    window.alert("‚ö†Ô∏è Please select an option before saving")
                    return

            elif step_type == "multiple-choice-multiple":
                window.console.log("üìù Capturing multiple-choice-multiple answer")
                checkboxes = container.querySelectorAll(f"input[name='mc_multiple_{step_idx}']:checked")
                if checkboxes.length > 0:
                    new_answer = [checkboxes[i].value for i in range(checkboxes.length)]
                    window.console.log(f"‚úÖ Captured {len(new_answer)} answers: {new_answer}")
                else:
                    window.console.warn("‚ö†Ô∏è No checkboxes selected")
                    window.alert("‚ö†Ô∏è Please select at least one option before saving")
                    return

            elif step_type == "true-false":
                window.console.log("üìù Capturing true-false answer")
                selected = container.querySelector(".tf-btn.selected")
                if selected:
                    value = selected.getAttribute("data-value")
                    new_answer = [value == "true"]
                    window.console.log(f"‚úÖ Captured answer: {new_answer}")
                else:
                    window.console.warn("‚ö†Ô∏è No true/false button selected")
                    window.alert("‚ö†Ô∏è Please select True or False before saving")
                    return

            elif step_type == "fill-blank":
                window.console.log("üìù Capturing fill-blank answer")
                input_field = container.querySelector(".fill-blank-input")
                if input_field:
                    value = input_field.value.strip()
                    if value:
                        new_answer = [value]
                        window.console.log(f"‚úÖ Captured answer: {new_answer}")
                    else:
                        window.console.warn("‚ö†Ô∏è Empty fill-blank input")
                        window.alert("‚ö†Ô∏è Please enter an answer before saving")
                        return
                else:
                    window.console.error("‚ùå Fill-blank input not found")
                    window.alert("‚ùå Error: Input field not found")
                    return

            elif step_type in ["freestyle", "math-expression"]:
                window.console.log("üé® Capturing freestyle/math-expression answer")
                # ‚úÖ Use the stored MathQuill instance
                if hasattr(container, 'mq_field') and container.mq_field:
                    try:
                        latex = container.mq_field.latex()
                        if latex and latex.strip():
                            new_answer = [latex]
                            window.console.log(f"‚úÖ Captured LaTeX: {latex}")
                        else:
                            window.console.warn("‚ö†Ô∏è Empty LaTeX captured")
                            window.alert("‚ö†Ô∏è Please enter a mathematical expression before saving")
                            return
                    except Exception as e:
                        window.console.error(f"‚ö†Ô∏è Error capturing LaTeX: {e}")
                        window.alert(f"‚ùå Error capturing answer: {str(e)}")
                        return
                else:
                    window.console.error("‚ùå MathQuill instance not found")
                    window.alert("‚ùå Error: Math field not properly initialized")
                    return

            else:
                window.console.error(f"‚ùå Unknown step type: {step_type}")
                window.alert(f"‚ùå Error: Unknown step type '{step_type}'")
                return

            # ============================================
            # PART 3: VALIDATE ANSWER - Ensure we got something
            # ============================================

            if not new_answer:
                window.alert("‚ö†Ô∏è Please provide an answer before saving")
                window.console.error("‚ùå No answer captured")
                return

            # Filter out empty strings
            if isinstance(new_answer, list):
                new_answer = [ans for ans in new_answer if ans != "" and ans is not None]
                if len(new_answer) == 0:
                    window.alert("‚ö†Ô∏è Please provide a valid answer")
                    window.console.error("‚ùå Answer list is empty after filtering")
                    return

            window.console.log(f"‚úÖ Final validated answer: {new_answer}")

            # ============================================
            # PART 4: UPDATE STATE - Save to problem_states
            # ============================================

            if problem_idx not in self.problem_states:
                window.console.error(f"‚ùå Problem {problem_idx} not found in problem_states")
                window.alert("‚ùå Error: Problem state not found")
                return

            if step_idx >= len(self.problem_states[problem_idx]):
                window.console.error(f"‚ùå Step {step_idx} not found in problem_states")
                window.alert("‚ùå Error: Step state not found")
                return

            # Store old answer for logging
            old_answer = self.problem_states[problem_idx][step_idx].get("user_answers", [])

            # Update with new answer
            self.problem_states[problem_idx][step_idx]["user_answers"] = new_answer

            window.console.log(f"‚úÖ Updated problem_states[{problem_idx}][{step_idx}]")
            window.console.log(f"   Old answer: {old_answer}")
            window.console.log(f"   New answer: {new_answer}")

            # ============================================
            # PART 5: TRACK EDIT - For score recalculation
            # ============================================

            self.score_tracker.add_edit(problem_idx, step_idx, new_answer)
            window.console.log("‚úÖ Edit tracked in score_tracker")

            # ============================================
            # PART 6: RECALCULATE SCORE - Always calculate, may not display yet
            # ============================================

            total_score, max_score, problem_scores = self.calculate_total_score()
            if max_score > 0:
                percentage = (total_score / max_score) * 100
            else:
                percentage = 0

            window.console.log(f"üìä Recalculated score: {percentage:.1f}% ({total_score:.1f}/{max_score:.1f})")

            # ============================================
            # PART 7: SCORE DISPLAY LOGIC - Immediate or deferred?
            # ============================================

            # Check if this is a first-time edit for this problem
            is_first_edit_for_problem = problem_idx not in self.score_display_manager["edited_problems"]
            if is_first_edit_for_problem:
                self.score_display_manager["edited_problems"].add(problem_idx)
                window.console.log(f"‚úÖ First edit for problem {problem_idx}")

            # Update last edit timestamp
            import js
            self.score_display_manager["last_edit_time"] = js.Date.now()

            # Determine if score should be displayed NOW
            edited_count = len(self.score_display_manager["edited_problems"])
            should_display_now = edited_count >= 2

            window.console.log(f"üìä Score display check: {edited_count} problems edited")

            if should_display_now:
                window.console.log("‚úÖ Displaying score NOW (2+ problems edited)")
                score_to_display = percentage
                should_show_update = True
                # Clear pending update
                self.score_display_manager["pending_score_update"] = False
            else:
                window.console.log("‚è≥ Score display deferred (need 2+ problems or 5 minutes)")
                # Store as pending
                self.score_display_manager["pending_score_update"] = True
                self.score_display_manager["pending_percentage"] = percentage
                score_to_display = None
                should_show_update = False

            # ============================================
            # PART 8: PERSIST TO STORAGE - Save everything
            # ============================================

            try:
                self.save_to_storage()
                window.console.log("üíæ Progress saved to localStorage")
            except Exception as e:
                window.console.error(f"‚ö†Ô∏è Could not save to localStorage: {e}")
                import traceback
                window.console.error(traceback.format_exc())
                # Don't fail completely if save fails

            # ============================================
            # PART 9: UI FEEDBACK - Show success message
            # ============================================

            self.show_edit_success_message(container)

            # ============================================
            # PART 10: RETURN TO REVIEW - After delay
            # ============================================

            def return_to_review():
                try:
                    # Update score display if conditions are met
                    if should_show_update:
                        self.update_score_display_in_review(score_to_display)
                        self.show_score_update_notification("‚ú® Score Updated!")
                        window.console.log("‚úÖ Score display updated immediately")
                    else:
                        # Show deferred message
                        self.show_score_deferred_message(edited_count)
                        window.console.log(f"‚è≥ Score display deferred (need {2 - edited_count} more edit(s))")

                    # Return to review section
                    self.cancel_edit_from_review(problem_idx)
                    window.console.log("‚úÖ Returned to review section")

                except Exception as e:
                    window.console.error(f"‚ùå Error returning to review: {e}")
                    import traceback
                    window.console.error(traceback.format_exc())
                    # Try to at least close the edit mode
                    try:
                        self.cancel_edit_from_review(problem_idx)
                    except:
                        pass

            # Delay return to show success message
            window.setTimeout(create_proxy(return_to_review), 1500)

            window.console.log("‚úÖ Save process completed successfully")

        except Exception as e:
            # ============================================
            # ERROR HANDLING - Something went wrong
            # ============================================

            window.console.error(f"‚ùå Error saving answer: {e}")
            import traceback
            error_trace = traceback.format_exc()
            window.console.error(error_trace)

            # Show user-friendly error
            window.alert(f"‚ùå Error saving answer: {str(e)}\n\nPlease try again or refresh the page.")


    # ============================================
    # HELPER METHODS (Add these to your class if not present)
    # ============================================

    def show_score_update_notification(self, message):
        """Show a notification that the score was updated"""
        notification = document.createElement("div")
        notification.style.cssText = """
            position: fixed;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, #10b981, #059669);
            color: white;
            padding: 16px 24px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
            font-weight: 600;
            z-index: 10000;
        """
        notification.innerHTML = f"<div>{message}</div>"
        document.body.appendChild(notification)

        def remove_notification():
            notification.remove()
        window.setTimeout(create_proxy(remove_notification), 3000)

    def show_score_deferred_message(self, edited_count):
        """Show a message that score display is deferred"""
        needed = 2 - edited_count

        review_section = document.querySelector("[id^='reviewSection_']")
        if not review_section:
            return

        existing_msg = review_section.querySelector(".score-deferred-msg")
        if existing_msg:
            existing_msg.remove()

        deferred_msg = document.createElement("div")
        deferred_msg.className = "score-deferred-msg"
        deferred_msg.style.cssText = """
            background: linear-gradient(135deg, #fef3c7, #fde68a);
            border: 2px solid #f59e0b;
            border-radius: 12px;
            padding: 16px 20px;
            margin: 16px 0;
        """

        deferred_msg.innerHTML = f"""
            <div style="font-weight: 600; color: #92400e;">
                Score Update Pending
            </div>
            <div style="font-size: 14px; color: #78350f;">
                Score will display after editing <strong>{needed} more problem(s)</strong> or in <strong>5 minutes</strong>.
            </div>
        """

        review_section.insertBefore(deferred_msg, review_section.firstChild)

    def show_edit_success_message(self, container):
        """Show a success message after editing"""
        success_msg = document.createElement("div")
        success_msg.style.cssText = """
            background: #d1fae5;
            color: #065f46;
            padding: 12px;
            border-radius: 6px;
            margin-top: 12px;
            text-align: center;
            font-weight: 600;
        """
        success_msg.textContent = "‚úÖ Answer saved successfully!"
        container.appendChild(success_msg)

        def remove_msg():
            success_msg.remove()
        window.setTimeout(create_proxy(remove_msg), 2000)


    


    # ============================================
    # USAGE NOTES
    # ============================================
    """
    DEPENDENCIES:
    This method requires the following to be present in your class:

    1. self.solve_states - Dict of solve states by problem index
    2. self.problem_states - Dict of problem states by problem index
    3. self.score_tracker - ScoreRecalculationTracker instance
    4. self.score_display_manager - Dict with tracking data
    5. self.calculate_total_score() - Method to calculate scores
    6. self.save_to_storage() - Method to persist data
    7. self.update_score_display_in_review() - Method to update score UI
    8. self.cancel_edit_from_review() - Method to close edit mode

    FEATURES:
    ‚úÖ Handles all step types (MC-single, MC-multiple, T/F, fill-blank, freestyle)
    ‚úÖ Comprehensive validation and error handling
    ‚úÖ Tracks edits for intelligent score recalculation
    ‚úÖ Deferred score display (2-edit rule or 5-minute timer)
    ‚úÖ User-friendly feedback messages
    ‚úÖ Persistent storage
    ‚úÖ Console logging for debugging
    ‚úÖ Graceful error recovery

    STEP TYPES SUPPORTED:
    - "multiple-choice-single"
    - "multiple-choice-multiple"
    - "true-false"
    - "fill-blank"
    - "freestyle"
    - "math-expression"

    ERROR HANDLING:
    - Missing solve_state ‚Üí Alert and return
    - Invalid step index ‚Üí Alert and return
    - No container ‚Üí Alert and return
    - No answer captured ‚Üí Alert and return
    - Empty answer ‚Üí Alert and return
    - Unknown step type ‚Üí Alert and return
    - Storage error ‚Üí Log but continue
    - Return to review error ‚Üí Try fallback

    SCORE DISPLAY LOGIC:
    - Immediate display: When 2+ different problems have been edited
    - Deferred display: When only 1 problem edited (shows timer message)
    - Timer: 5 minutes after edit, score displays automatically

    TESTING:
    1. Test each step type (MC, T/F, fill-blank, freestyle)
    2. Test validation (try submitting empty answers)
    3. Test score display (edit 1 problem, then 2 problems)
    4. Test persistence (save, reload, check data)
    5. Test error handling (remove elements, check alerts)
    """
    
    def start_score_display_timer(self):
        """Check periodically if pending score updates should be displayed"""
        def check_and_display():
            if self.score_display_manager["pending_score_update"]:
                current_time = js.Date.now()
                last_edit = self.score_display_manager["last_edit_time"]

                if last_edit:
                    elapsed_ms = current_time - last_edit
                    elapsed_minutes = elapsed_ms / 60000

                    if elapsed_minutes >= 5:
                        window.console.log("‚è∞ 5 minutes elapsed, displaying pending score")
                        percentage = self.score_display_manager["pending_percentage"]
                        self.update_score_display_in_review(percentage)
                        self.score_display_manager["pending_score_update"] = False
                        self.show_score_update_notification("‚è∞ Score Updated (5 minutes elapsed)")

            # Check again in 10 seconds
            window.setTimeout(create_proxy(check_and_display), 10000)

        # Start the timer
        window.setTimeout(create_proxy(check_and_display), 10000)
    
    def edit_answer_from_review(self, problem_idx, step_idx):
      """Initiate editing of a specific step from review section"""
      window.console.log("=" * 60)
      window.console.log(f"üîß EDIT ANSWER FROM REVIEW")
      window.console.log(f"   Problem: {problem_idx}, Step: {step_idx}")
      window.console.log("=" * 60)

      # ‚úÖ FIX: Get original step data from problem set FIRST
      if problem_idx >= len(self.problem_set):
          window.console.error(f"‚ùå Invalid problem index: {problem_idx}")
          window.alert("Error: Invalid problem index")
          return

      problem = self.problem_set[problem_idx]
      steps = problem.get("steps", [])

      if step_idx >= len(steps):
          window.console.error(f"‚ùå Invalid step index: {step_idx}")
          window.alert("Error: Invalid step index")
          return

      # ‚úÖ Get the original step data
      original_step_data = steps[step_idx]

      # ‚úÖ Get the step type from original data
      step_type = original_step_data.get("step_type", "math-expression")
      # Handle legacy "step-by-step" type
      if step_type == "step-by-step":
          step_type = "math-expression"

      window.console.log(f"‚úÖ Step type from original data: {step_type}")

      # ‚úÖ Step 1: Hide review section
      review_section = document.querySelector("#reviewSection")
      if review_section:
          review_section.style.display = "none"
          window.console.log("‚úÖ Hidden review section")
      else:
          window.console.warn("‚ö†Ô∏è Review section not found")

      # ‚úÖ Step 2: Get and open problem accordion
      accordion = document.querySelector(f".accordion-problem[data-index='{problem_idx}']")
      if accordion:
          window.console.log(f"‚úÖ Found accordion for problem {problem_idx}")
          if not accordion.classList.contains("open"):
              accordion.classList.add("open")
              window.console.log("‚úÖ Opened accordion")
          else:
              window.console.log("‚ÑπÔ∏è Accordion already open")
      else:
          window.console.error(f"‚ùå Accordion not found for problem {problem_idx}")

      # ‚úÖ Step 3: Get problem body container
      problem_body = document.querySelector(f"#problemBody{problem_idx}")
      if not problem_body:
          window.console.error(f"‚ùå Problem body #{problem_idx} not found in DOM")
          window.alert("Error: Problem container not found")
          return

      window.console.log(f"‚úÖ Found problem body for problem {problem_idx}")
      problem_body.style.display = "block"

      # ‚úÖ Step 4: Set current problem
      self.current_problem_index = problem_idx

      # ‚úÖ Step 5: Ensure solve_state exists with original step data
      if problem_idx not in self.solve_states:
          window.console.log(f"‚ö†Ô∏è solve_state not found, rebuilding from original data...")

          if not self.ensure_solve_state_for_edit(problem_idx):
              window.alert("‚ùå Error: Could not load problem for editing")
              return

      # ‚úÖ Step 6: Create container for this step using original data
      try:
          saved_step = self.problem_states[problem_idx][step_idx]

          # Create step container
          container = document.createElement("div")
          container.id = f"stepContainer{step_idx}"
          container.className = "step-container"
          container.style.cssText = "display:block;margin-bottom:24px;padding:20px;background:#f8fafc;border-radius:12px;border:2px solid #e2e8f0;"

          # Create step header
          step_header = document.createElement("div")
          step_header.style.cssText = "font-size:16px;font-weight:600;color:#1e293b;margin-bottom:16px;"
          step_header.innerHTML = f"üìù Step {step_idx + 1}"
          container.appendChild(step_header)

          # ‚úÖ Create step content based on type from ORIGINAL data
          window.console.log(f"Creating UI for step type: {step_type}")

          if step_type == "multiple-choice-single":
              self._recreate_mc_single_step(container, step_idx, saved_step, original_step_data)
          elif step_type == "multiple-choice-multiple":
              self._recreate_mc_multiple_step(container, step_idx, saved_step, original_step_data)
          elif step_type == "true-false":
              self._recreate_true_false_step(container, step_idx, saved_step, original_step_data)
          elif step_type == "fill-blank":
              self._recreate_fill_blank_step(container, step_idx, saved_step, original_step_data)
          elif step_type in ["freestyle", "math-expression"]:
              self._recreate_freestyle_step(container, step_idx, saved_step, original_step_data)
          else:
              window.console.error(f"‚ùå Unknown step type: {step_type}")
              error_msg = document.createElement("div")
              error_msg.textContent = f"Unknown step type: {step_type}"
              error_msg.style.cssText = "color:#ef4444;padding:12px;background:#fee2e2;border-radius:6px;"
              container.appendChild(error_msg)

          # Add to body
          problem_body.innerHTML = ""  # Clear existing content

          # ‚úÖ Add problem description if it exists
          problem_description = problem.get("description", [])
          if problem_description and isinstance(problem_description, list):
              desc_html = self.render_content_blocks(problem_description)
              if desc_html.strip():
                  desc_container = document.createElement("div")
                  desc_container.className = "problem-description"
                  desc_container.style.cssText = """
                      background: #f0f9ff;
                      padding: 16px 20px;
                      border-radius: 12px;
                      border-left: 4px solid #3b82f6;
                      margin-bottom: 20px;
                      font-size: 15px;
                      line-height: 1.6;
                      color: #1e293b;
                  """
                  desc_container.innerHTML = f"<div style='font-weight:600;margin-bottom:8px;color:#1e40af;'>üìã Problem Description:</div>{desc_html}"
                  problem_body.appendChild(desc_container)
                  window.console.log("‚úÖ Added problem description to view")

          problem_body.appendChild(container)

          # Store in solve_state
          if problem_idx not in self.solve_states:
              self.solve_states[problem_idx] = []

          # Update or add step to solve_state
          step_state = {
              "container": container,
              "step_type": step_type,
              "step_data": original_step_data,  # ‚úÖ Store original data
              "finished": saved_step.get("finished", True)
          }

          if step_idx < len(self.solve_states[problem_idx]):
              self.solve_states[problem_idx][step_idx] = step_state
          else:
              self.solve_states[problem_idx].append(step_state)

          window.console.log(f"‚úÖ Created container for step {step_idx}")

          # Show the edit UI
          self._show_step_edit_ui(problem_idx, step_idx)

          # Render MathJax for problem description and step content
          if hasattr(window, 'MathJax') and hasattr(window.MathJax, 'typesetPromise'):
              window.console.log("üé® Rendering MathJax for edit mode...")
              window.MathJax.typesetPromise([problem_body]).then(
                  create_proxy(lambda result: window.console.log("‚úÖ MathJax rendered in edit mode"))
              ).catch(
                  create_proxy(lambda e: window.console.error(f"‚ö†Ô∏è MathJax error: {e}"))
              )

      except Exception as e:
          window.console.error(f"‚ùå Error creating step UI: {e}")
          import traceback
          window.console.error(traceback.format_exc())
          window.alert(f"Error loading step: {str(e)}")

    def cancel_edit_from_review(self, problem_idx):
        """Cancel editing and return to review section"""
        window.console.log(f"‚ùå Canceling edit, returning to review")
        
        if problem_idx not in self.solve_states:
            window.console.error("‚ùå Problem state not found")
            return
        
        solve_state = self.solve_states[problem_idx]
        
        # ‚úÖ Hide all step containers and remove edit wrappers
        for i, step in enumerate(solve_state):
            container = step.get("container")
            if container:
                # Remove edit wrapper
                edit_wrapper = container.querySelector(".edit-mode-wrapper")
                if edit_wrapper:
                    edit_wrapper.remove()
                
                # Hide the step container
                container.style.display = "none"
                
                # ‚úÖ Remove the container from DOM to clean up
                container.remove()
        
        # ‚úÖ Clear the solve_state since we're done editing
        del self.solve_states[problem_idx]
        window.console.log(f"üóëÔ∏è Cleared solve_state for problem {problem_idx}")
        
        # ‚úÖ Show the review section again
        review_section = document.querySelector(f"#reviewSection_{problem_idx}")
        if review_section:
            review_section.style.display = "block"
            window.console.log("‚úÖ Review section shown")
            
            # Scroll to review section
            review_section.scrollIntoView({'behavior': 'smooth', 'block': 'start'})
        
        # ‚úÖ Show the completion banner again
        completion_banner = document.querySelector(f"#completionBanner_{problem_idx}")
        if completion_banner:
            completion_banner.style.display = "block"
            window.console.log("‚úÖ Completion banner shown")

    def ensure_solve_state_for_edit(self, problem_idx):
        """Ensure solve_state exists for a completed problem before editing"""
        window.console.log(f"üîß Ensuring solve_state exists for problem {problem_idx}")

        # If solve_state already exists, we're good
        if problem_idx in self.solve_states:
            window.console.log(f"‚úÖ solve_state already exists for problem {problem_idx}")
            return True

        # ‚úÖ Check if we have saved problem_states data
        if problem_idx not in self.problem_states:
            window.console.error(f"‚ùå No saved problem_states for problem {problem_idx}")
            window.alert("‚ùå Error: No saved data for this problem")
            return False

        saved_steps = self.problem_states[problem_idx]
        if not saved_steps or len(saved_steps) == 0:
            window.console.error(f"‚ùå No saved steps for problem {problem_idx}")
            window.alert("‚ùå Error: No steps found for this problem")
            return False

        # ‚úÖ Get the original problem from problem_set
        if problem_idx >= len(self.problem_set):
            window.console.error(f"‚ùå Invalid problem index: {problem_idx}")
            window.alert("‚ùå Error: Invalid problem index")
            return False

        problem = self.problem_set[problem_idx]
        original_steps = problem.get("steps", [])

        if len(original_steps) != len(saved_steps):
            window.console.warn(f"‚ö†Ô∏è Mismatch: {len(original_steps)} original steps vs {len(saved_steps)} saved steps")

        # Get the problem body
        body = document.querySelector(f"#problemBody{problem_idx}")
        if not body:
            window.console.error(f"‚ùå Problem body not found for problem {problem_idx}")
            window.alert("‚ùå Error: Problem container not found")
            return False

        window.console.log(f"üîß Recreating solve_state with {len(saved_steps)} steps from original problem data")

        # Initialize solve_state array
        solve_state = []

        # ‚úÖ Create container for each step using ORIGINAL problem data for step type
        for step_idx, saved_step in enumerate(saved_steps):
            # ‚úÖ Get step type from ORIGINAL problem data, not saved data
            if step_idx < len(original_steps):
                original_step_data = original_steps[step_idx]
                step_type = original_step_data.get("step_type", "math-expression")
                # Handle legacy "step-by-step" type
                if step_type == "step-by-step":
                    step_type = "math-expression"
            else:
                window.console.error(f"‚ùå No original data for step {step_idx}")
                original_step_data = {}
                step_type = "unknown"

            window.console.log(f"üìù Creating step {step_idx} with type: {step_type}")

            # Create step container
            container = document.createElement("div")
            container.id = f"stepContainer{step_idx}"
            container.className = "step-container"
            container.style.cssText = "display:none;margin-bottom:24px;padding:20px;background:#f8fafc;border-radius:12px;border:2px solid #e2e8f0;"

            # Create step header
            step_header = document.createElement("div")
            step_header.style.cssText = "font-size:16px;font-weight:600;color:#1e293b;margin-bottom:16px;"
            step_header.innerHTML = f"üìù Step {step_idx + 1}"
            container.appendChild(step_header)

            # Create step content based on type using ORIGINAL step data
            try:
                if step_type == "multiple-choice-single":
                    self._recreate_mc_single_step(container, step_idx, saved_step, original_step_data)
                elif step_type == "multiple-choice-multiple":
                    self._recreate_mc_multiple_step(container, step_idx, saved_step, original_step_data)
                elif step_type == "true-false":
                    self._recreate_true_false_step(container, step_idx, saved_step, original_step_data)
                elif step_type == "fill-blank":
                    self._recreate_fill_blank_step(container, step_idx, saved_step, original_step_data)
                elif step_type in ["freestyle", "math-expression"]:
                    self._recreate_freestyle_step(container, step_idx, saved_step, original_step_data)
                else:
                    window.console.error(f"‚ùå Unknown step type: {step_type}")
                    # Create a generic container anyway
                    error_msg = document.createElement("div")
                    error_msg.textContent = f"Unknown step type: {step_type}"
                    error_msg.style.cssText = "color:#ef4444;padding:12px;"
                    container.appendChild(error_msg)

                window.console.log(f"‚úÖ Created container for step {step_idx}")

            except Exception as e:
                window.console.error(f"‚ùå Error creating step {step_idx}: {e}")
                # Add error message to container
                error_msg = document.createElement("div")
                error_msg.textContent = f"Error creating step: {str(e)}"
                error_msg.style.cssText = "color:#ef4444;padding:12px;background:#fee2e2;border-radius:6px;"
                container.appendChild(error_msg)

            # Add to body
            body.appendChild(container)

            # Store in solve_state
            step_state = {
                "container": container,
                "step_type": step_type,
                "step_data": original_step_data,  # ‚úÖ Store original step data
                "finished": saved_step.get("finished", True)
            }
            solve_state.append(step_state)

        # Store the solve_state
        self.solve_states[problem_idx] = solve_state
        window.console.log(f"‚úÖ solve_state recreated with {len(solve_state)} steps")

        # Render MathJax for all recreated steps
        if hasattr(window, 'MathJax') and hasattr(window.MathJax, 'typesetPromise'):
            window.console.log("üé® Rendering MathJax for recreated steps...")
            window.MathJax.typesetPromise([body]).then(
                create_proxy(lambda result: window.console.log("‚úÖ MathJax rendered for recreated steps"))
            ).catch(
                create_proxy(lambda e: window.console.error(f"‚ö†Ô∏è MathJax error: {e}"))
            )

        return True

    def _show_step_edit_ui(self, problem_idx, step_idx):
        """Show the edit UI for a specific step"""
        window.console.log(f"Showing edit UI for step {step_idx}")

        if problem_idx not in self.solve_states:
            window.console.error("‚ùå No solve_state found")
            window.alert("‚ùå Error: Problem state not found")
            return

        solve_state = self.solve_states[problem_idx]

        if step_idx >= len(solve_state):
            window.console.error(f"‚ùå Invalid step index: {step_idx}")
            window.alert(f"‚ùå Error: Invalid step index {step_idx}")
            return

        # ‚úÖ Hide all steps first
        for i, s in enumerate(solve_state):
            if s.get("container"):
                s["container"].style.display = "none"

        # Hide global history if it exists
        global_history = document.querySelector(f"#globalHistory_{problem_idx}")
        if global_history:
            global_history.style.display = "none"

        step = solve_state[step_idx]
        container = step.get("container")

        if not container:
            window.console.error(f"‚ùå Container not found for step {step_idx}")
            window.alert("‚ùå Error: Step container not found")
            return

        # ‚úÖ Get step_type from solve_state, or fallback to original problem data
        step_type = step.get("step_type", "unknown")

        # If step_type is unknown, try to get it from original problem data
        if step_type == "unknown":
            if problem_idx < len(self.problem_set):
                problem = self.problem_set[problem_idx]
                steps = problem.get("steps", [])
                if step_idx < len(steps):
                    step_type = steps[step_idx].get("step_type", "math-expression")
                    if step_type == "step-by-step":
                        step_type = "math-expression"
                    window.console.log(f"‚úÖ Retrieved step_type from original data: {step_type}")

        window.console.log(f"üìù Step type for editing: {step_type}")
        
        # ‚úÖ Show only this step
        container.style.display = "block"
        window.console.log(f"‚úÖ Step container displayed: {step_idx}")
        
        # ‚úÖ Remove any existing edit wrapper to prevent stacking
        existing_wrapper = container.querySelector(".edit-mode-wrapper")
        if existing_wrapper:
            existing_wrapper.remove()
            window.console.log("üóëÔ∏è Removed existing edit wrapper")
        
        # ‚úÖ Hide original Submit/Finalize buttons and feedback
        submit_btn = container.querySelector(f"#submitBtn{step_idx}")
        finalize_btn = container.querySelector(f"#finalizeBtn{step_idx}")
        feedback_div = container.querySelector(f"#stepFeedback{step_idx}")
        
        if submit_btn:
            submit_btn.style.display = "none"
            window.console.log(f"‚úÖ Hidden submit button for step {step_idx}")
        if finalize_btn:
            finalize_btn.style.display = "none"
            window.console.log(f"‚úÖ Hidden finalize button for step {step_idx}")
        if feedback_div:
            feedback_div.style.display = "none"
            window.console.log(f"‚úÖ Hidden feedback for step {step_idx}")
        
        # ‚úÖ Remove any "correct/incorrect" styling that might be present
        container.classList.remove("correct-answer", "incorrect-answer")
        
        # Scroll to it smoothly
        container.scrollIntoView({'behavior': 'smooth', 'block': 'center'})
        
        # Create edit wrapper
        edit_wrapper = document.createElement("div")
        edit_wrapper.className = "edit-mode-wrapper"
        edit_wrapper.style.cssText = "background:#fef3c7;border:3px solid #f59e0b;padding:20px;border-radius:12px;margin-top:16px;animation:slideIn 0.3s ease-out;"
        
        edit_header = document.createElement("div")
        edit_header.style.cssText = "font-size:18px;font-weight:700;color:#92400e;margin-bottom:16px;text-align:center;"
        edit_header.innerHTML = "‚úèÔ∏è Editing Mode - Update Your Answer"
        edit_wrapper.appendChild(edit_header)
        
        # ‚úÖ Handle different step types
        if step_type in ["multiple-choice-single", "multiple-choice-multiple"]:
            window.console.log(f"üìù Enabling {step_type} editing")
            
            # Re-enable radio buttons or checkboxes
            inputs = container.querySelectorAll("input")
            for i in range(inputs.length):
                inp = inputs[i]
                inp.disabled = False
                inp.style.pointerEvents = "auto"
                window.console.log(f"‚úÖ Enabled input {i}")
            
            # Re-enable option containers
            options = container.querySelectorAll(".mc-option")
            for i in range(options.length):
                opt = options[i]
                opt.style.pointerEvents = "auto"
                opt.style.opacity = "1"
                opt.style.cursor = "pointer"
                # Remove any disabled styling
                opt.classList.remove("disabled")
        
        elif step_type == "true-false":
            window.console.log("üìù Enabling true-false editing")
            
            # Re-enable true/false buttons
            tf_buttons = container.querySelectorAll(".tf-btn")
            for i in range(tf_buttons.length):
                btn = tf_buttons[i]
                btn.style.pointerEvents = "auto"
                btn.style.opacity = "1"
                btn.style.cursor = "pointer"
                btn.disabled = False
                window.console.log(f"‚úÖ Enabled TF button {i}")
        
        elif step_type == "fill-blank":
            window.console.log("üìù Enabling fill-blank editing")
            
            # Re-enable text input
            input_field = container.querySelector(".fill-blank-input")
            if input_field:
                input_field.disabled = False
                input_field.readOnly = False
                input_field.style.pointerEvents = "auto"
                input_field.style.opacity = "1"
                input_field.style.backgroundColor = "#ffffff"
                input_field.focus()
                window.console.log("‚úÖ Enabled fill-blank input")
        
        elif step_type in ["freestyle", "math-expression"]:
            window.console.log("üé® Enabling freestyle math editing")

            # ‚úÖ Get the stored MathQuill instance
            if hasattr(container, 'mq_field') and container.mq_field:
                try:
                    # Focus the existing MathQuill field
                    container.mq_field.focus()
                    window.console.log("‚úÖ MathQuill field focused")
                except Exception as e:
                    window.console.error(f"‚ö†Ô∏è Could not focus MathQuill: {e}")
            else:
                window.console.warn("‚ö†Ô∏è MathQuill instance not found on container")

            # Make sure the input container is visible and styled for editing
            input_container = container.querySelector(".math-input-container")
            if input_container:
                input_container.style.pointerEvents = "auto"
                input_container.style.opacity = "1"

            # Show instruction for freestyle editing
            freestyle_hint = document.createElement("div")
            freestyle_hint.style.cssText = "background:#fef9c3;border:1px solid #eab308;padding:12px;border-radius:6px;margin-bottom:12px;font-size:14px;color:#854d0e;"
            freestyle_hint.innerHTML = "üí° <strong>Tip:</strong> Click in the math field above to edit your answer. Use your keyboard to enter mathematical expressions."
            edit_wrapper.appendChild(freestyle_hint)
        
        # Create button container
        button_container = document.createElement("div")
        button_container.style.cssText = "display:flex;gap:12px;margin-top:16px;"
        
        # Save button
        save_btn = document.createElement("button")
        save_btn.className = "btn"
        save_btn.style.cssText = "flex:1;background:#10b981;color:white;font-weight:600;padding:12px;border:none;border-radius:8px;cursor:pointer;transition:all 0.2s;"
        save_btn.textContent = "üíæ Save Answer"
        save_btn.onmouseover = create_proxy(lambda e: setattr(e.target.style, 'background', '#059669'))
        save_btn.onmouseout = create_proxy(lambda e: setattr(e.target.style, 'background', '#10b981'))
        
        def make_save_handler(prob_idx, s_idx):
            def handler(e):
                self.save_answer_from_review(prob_idx, s_idx)
            return handler
        
        save_btn.addEventListener("click", create_proxy(make_save_handler(problem_idx, step_idx)))
        button_container.appendChild(save_btn)
        
        # Cancel button
        cancel_btn = document.createElement("button")
        cancel_btn.className = "btn ghost"
        cancel_btn.style.cssText = "flex:1;background:#ef4444;color:white;font-weight:600;padding:12px;border:none;border-radius:8px;cursor:pointer;transition:all 0.2s;"
        cancel_btn.textContent = "‚ùå Cancel"
        cancel_btn.onmouseover = create_proxy(lambda e: setattr(e.target.style, 'background', '#dc2626'))
        cancel_btn.onmouseout = create_proxy(lambda e: setattr(e.target.style, 'background', '#ef4444'))
        
        def make_cancel_handler(prob_idx):
            def handler(e):
                self.cancel_edit_from_review(prob_idx)
            return handler
        
        cancel_btn.addEventListener("click", create_proxy(make_cancel_handler(problem_idx)))
        button_container.appendChild(cancel_btn)
        
        edit_wrapper.appendChild(button_container)
        container.appendChild(edit_wrapper)
        
        window.console.log("‚úÖ Edit UI fully constructed and displayed")

    def _recreate_mc_single_step(self, container, step_idx, saved_step, original_step_data):
        """Recreate a multiple-choice-single step for editing"""
        window.console.log(f"üìù Recreating MC-single step {step_idx}")

        # ‚úÖ Get question from original step data (description blocks)
        desc_blocks = original_step_data.get("description", [])
        question_html = self.render_content_blocks(desc_blocks)
        if not question_html.strip():
            question_html = f"Multiple Choice Question {step_idx + 1}"

        # ‚úÖ Get options from original step data
        options = original_step_data.get("options", [])

        # ‚úÖ Get user's previous answer from saved_step
        user_answer = saved_step.get("user_answers", [])

        window.console.log(f"Question HTML: {question_html[:100]}...")
        window.console.log(f"Options: {options}")

        # If no options, create generic ones
        if not options or len(options) == 0:
            options = ["Option A", "Option B", "Option C", "Option D"]

        # Create question
        q_div = document.createElement("div")
        q_div.style.cssText = "margin-bottom:16px;font-size:15px;color:#334155;line-height:1.6;"
        q_div.innerHTML = question_html
        container.appendChild(q_div)

        # Create options
        for i, option in enumerate(options):
            # Handle both string and dict options
            if isinstance(option, dict):
                # Use label (A, B, C, D) as the value
                opt_value = option.get("label", f"Option_{i}")
                # Render the rich content
                opt_content = option.get("content", [])
                if opt_content and isinstance(opt_content, list):
                    opt_text = self.render_content_blocks(opt_content)
                else:
                    opt_text = str(option.get("label", f"Option {i+1}"))
            else:
                opt_value = option
                opt_text = option

            opt_container = document.createElement("div")
            opt_container.className = "mc-option"
            opt_container.style.cssText = "padding:12px;margin-bottom:8px;border:2px solid #e2e8f0;border-radius:8px;cursor:pointer;transition:all 0.2s;background:white;"

            radio = document.createElement("input")
            radio.type = "radio"
            radio.name = f"mc_single_{step_idx}"
            radio.value = opt_value
            radio.id = f"mc_single_{step_idx}_{i}"
            radio.style.cssText = "cursor:pointer;"

            # Check if this was the user's answer
            if user_answer and opt_value in user_answer:
                radio.checked = True
                opt_container.style.borderColor = "#3b82f6"
                opt_container.style.background = "#eff6ff"

            label = document.createElement("label")
            label.htmlFor = radio.id
            label.style.cssText = "margin-left:8px;cursor:pointer;display:inline-block;width:calc(100% - 24px);"
            label.innerHTML = opt_text  # Use innerHTML to render math
            
            opt_container.appendChild(radio)
            opt_container.appendChild(label)
            
            # Add click handler for visual feedback
            def make_click_handler(opt_cont, r):
                def handler(e):
                    # Deselect all options
                    all_opts = container.querySelectorAll(".mc-option")
                    for j in range(all_opts.length):
                        all_opts[j].style.borderColor = "#e2e8f0"
                        all_opts[j].style.background = "white"
                    # Select this one
                    r.checked = True
                    opt_cont.style.borderColor = "#3b82f6"
                    opt_cont.style.background = "#eff6ff"
                return handler
            
            opt_container.addEventListener("click", create_proxy(make_click_handler(opt_container, radio)))
            container.appendChild(opt_container)

    def _recreate_mc_multiple_step(self, container, step_idx, saved_step, original_step_data):
        """Recreate a multiple-choice-multiple step for editing"""
        window.console.log(f"üìù Recreating MC-multiple step {step_idx}")

        # ‚úÖ Get question from original step data (description blocks)
        desc_blocks = original_step_data.get("description", [])
        question_html = self.render_content_blocks(desc_blocks)
        if not question_html.strip():
            question_html = f"Multiple Choice Question {step_idx + 1} (Select all that apply)"

        # ‚úÖ Get options from original step data
        options = original_step_data.get("options", [])

        # ‚úÖ Get user's previous answers from saved_step
        user_answers = saved_step.get("user_answers", [])

        window.console.log(f"Question HTML: {question_html[:100]}...")
        window.console.log(f"Options: {options}")

        if not options or len(options) == 0:
            options = ["Option A", "Option B", "Option C", "Option D"]

        # Create question
        q_div = document.createElement("div")
        q_div.style.cssText = "margin-bottom:16px;font-size:15px;color:#334155;line-height:1.6;"
        q_div.innerHTML = question_html
        container.appendChild(q_div)
        
        # Create hint
        hint = document.createElement("div")
        hint.style.cssText = "font-size:13px;color:#64748b;margin-bottom:12px;font-style:italic;"
        hint.textContent = "‚úì Select all that apply"
        container.appendChild(hint)
        
        # Create options
        for i, option in enumerate(options):
            if isinstance(option, dict):
                # Use label (A, B, C, D) as the value
                opt_value = option.get("label", f"Option_{i}")
                # Render the rich content
                opt_content = option.get("content", [])
                if opt_content and isinstance(opt_content, list):
                    opt_text = self.render_content_blocks(opt_content)
                else:
                    opt_text = str(option.get("label", f"Option {i+1}"))
            else:
                opt_value = option
                opt_text = option

            opt_container = document.createElement("div")
            opt_container.className = "mc-option"
            opt_container.style.cssText = "padding:12px;margin-bottom:8px;border:2px solid #e2e8f0;border-radius:8px;cursor:pointer;background:white;transition:all 0.2s;"

            checkbox = document.createElement("input")
            checkbox.type = "checkbox"
            checkbox.name = f"mc_multiple_{step_idx}"
            checkbox.value = opt_value
            checkbox.id = f"mc_multiple_{step_idx}_{i}"
            checkbox.style.cssText = "cursor:pointer;"

            # Check if this was selected
            if opt_value in user_answers:
                checkbox.checked = True
                opt_container.style.borderColor = "#3b82f6"
                opt_container.style.background = "#eff6ff"

            label = document.createElement("label")
            label.htmlFor = checkbox.id
            label.style.cssText = "margin-left:8px;cursor:pointer;display:inline-block;width:calc(100% - 24px);"
            label.innerHTML = opt_text  # Use innerHTML to render math
            
            opt_container.appendChild(checkbox)
            opt_container.appendChild(label)
            
            # Add click handler
            def make_click_handler(opt_cont, cb):
                def handler(e):
                    # Toggle checkbox
                    if e.target.tagName != "INPUT":  # Only toggle if not clicking the checkbox itself
                        cb.checked = not cb.checked
                    
                    if cb.checked:
                        opt_cont.style.borderColor = "#3b82f6"
                        opt_cont.style.background = "#eff6ff"
                    else:
                        opt_cont.style.borderColor = "#e2e8f0"
                        opt_cont.style.background = "white"
                return handler
            
            opt_container.addEventListener("click", create_proxy(make_click_handler(opt_container, checkbox)))
            container.appendChild(opt_container)

    def _recreate_true_false_step(self, container, step_idx, saved_step, original_step_data):
        """Recreate a true-false step for editing"""
        window.console.log(f"üìù Recreating True/False step {step_idx}")

        # ‚úÖ Get question from original step data (description blocks)
        desc_blocks = original_step_data.get("description", [])
        question_html = self.render_content_blocks(desc_blocks)
        if not question_html.strip():
            question_html = f"True or False Question {step_idx + 1}"

        # ‚úÖ Get user's previous answer from saved_step
        user_answer = saved_step.get("user_answers", [])

        window.console.log(f"Question HTML: {question_html[:100]}...")
        window.console.log(f"User answer: {user_answer}")

        # Create question
        q_div = document.createElement("div")
        q_div.style.cssText = "margin-bottom:16px;font-size:15px;color:#334155;line-height:1.6;"
        q_div.innerHTML = question_html
        container.appendChild(q_div)
        
        # Create button container
        btn_container = document.createElement("div")
        btn_container.style.cssText = "display:flex;gap:12px;margin-top:16px;"
        
        # True button
        true_btn = document.createElement("button")
        true_btn.className = "tf-btn"
        true_btn.setAttribute("data-value", "true")
        true_btn.style.cssText = "flex:1;padding:16px;border:2px solid #e2e8f0;border-radius:8px;background:white;cursor:pointer;font-weight:600;font-size:15px;transition:all 0.2s;"
        true_btn.textContent = "‚úì True"
        
        if user_answer and len(user_answer) > 0 and user_answer[0] == True:
            true_btn.classList.add("selected")
            true_btn.style.borderColor = "#10b981"
            true_btn.style.background = "#d1fae5"
            true_btn.style.color = "#065f46"
        
        # False button
        false_btn = document.createElement("button")
        false_btn.className = "tf-btn"
        false_btn.setAttribute("data-value", "false")
        false_btn.style.cssText = "flex:1;padding:16px;border:2px solid #e2e8f0;border-radius:8px;background:white;cursor:pointer;font-weight:600;font-size:15px;transition:all 0.2s;"
        false_btn.textContent = "‚úó False"
        
        if user_answer and len(user_answer) > 0 and user_answer[0] == False:
            false_btn.classList.add("selected")
            false_btn.style.borderColor = "#ef4444"
            false_btn.style.background = "#fee2e2"
            false_btn.style.color = "#991b1b"
        
        # Add click handlers
        def make_tf_handler(btn, other_btn, is_true):
            def handler(e):
                btn.classList.add("selected")
                if is_true:
                    btn.style.borderColor = "#10b981"
                    btn.style.background = "#d1fae5"
                    btn.style.color = "#065f46"
                else:
                    btn.style.borderColor = "#ef4444"
                    btn.style.background = "#fee2e2"
                    btn.style.color = "#991b1b"
                
                other_btn.classList.remove("selected")
                other_btn.style.borderColor = "#e2e8f0"
                other_btn.style.background = "white"
                other_btn.style.color = "inherit"
            return handler
        
        true_btn.addEventListener("click", create_proxy(make_tf_handler(true_btn, false_btn, True)))
        false_btn.addEventListener("click", create_proxy(make_tf_handler(false_btn, true_btn, False)))
        
        btn_container.appendChild(true_btn)
        btn_container.appendChild(false_btn)
        container.appendChild(btn_container)

    def _recreate_fill_blank_step(self, container, step_idx, saved_step, original_step_data):
      """Recreate a fill-in-the-blank step for editing"""
      window.console.log(f"üìù Recreating Fill-blank step {step_idx}")

      # ‚úÖ Get question from original step data
      question = original_step_data.get("text", "")

      # If no text field, try description blocks
      if not question:
          desc_blocks = original_step_data.get("description", [])
          question = self.render_content_blocks(desc_blocks)

      if not question.strip():
          question = f"Fill in the blank: Step {step_idx + 1}"

      # Get user's previous answer from saved_step
      user_answer = saved_step.get("user_answers", [])

      window.console.log(f"Question: {question[:100]}...")
      window.console.log(f"User answer: {user_answer}")

      # Create question with blank
      q_div = document.createElement("div")
      q_div.style.cssText = "margin-bottom:16px;font-size:15px;color:#334155;line-height:1.6;"

      # Replace ___ with input field
      if "___" in question:
          parts = question.split("___")

          span1 = document.createElement("span")
          span1.textContent = parts[0]
          q_div.appendChild(span1)

          input_field = document.createElement("input")
          input_field.type = "text"
          input_field.className = "fill-blank-input"
          input_field.style.cssText = "border:2px solid #cbd5e1;border-radius:6px;padding:8px 12px;min-width:150px;font-size:15px;margin:0 4px;transition:all 0.2s;"
          input_field.placeholder = "Your answer..."

          if user_answer and len(user_answer) > 0:
              input_field.value = user_answer[0]

          # Add focus styling
          input_field.addEventListener("focus", create_proxy(lambda e: setattr(e.target.style, 'borderColor', '#3b82f6')))
          input_field.addEventListener("blur", create_proxy(lambda e: setattr(e.target.style, 'borderColor', '#cbd5e1')))

          q_div.appendChild(input_field)

          if len(parts) > 1:
              span2 = document.createElement("span")
              span2.textContent = parts[1]
              q_div.appendChild(span2)
      else:
          q_div.innerHTML = question

          # Add input below
          input_field = document.createElement("input")
          input_field.type = "text"
          input_field.className = "fill-blank-input"
          input_field.style.cssText = "border:2px solid #cbd5e1;border-radius:6px;padding:8px 12px;width:100%;font-size:15px;margin-top:12px;transition:all 0.2s;"
          input_field.placeholder = "Your answer..."

          if user_answer and len(user_answer) > 0:
              input_field.value = user_answer[0]

          # Add focus styling
          input_field.addEventListener("focus", create_proxy(lambda e: setattr(e.target.style, 'borderColor', '#3b82f6')))
          input_field.addEventListener("blur", create_proxy(lambda e: setattr(e.target.style, 'borderColor', '#cbd5e1')))

          container.appendChild(q_div)
          container.appendChild(input_field)
          return

      container.appendChild(q_div)

    def _recreate_freestyle_step(self, container, step_idx, saved_step, original_step_data):
      """Recreate a freestyle/math-expression step for editing"""
      window.console.log(f"üìù Recreating Freestyle/Math step {step_idx}")

      # ‚úÖ Get question from original step data (description blocks)
      desc_blocks = original_step_data.get("description", [])
      question_html = self.render_content_blocks(desc_blocks)
      if not question_html.strip():
          question_html = f"Math Expression Step {step_idx + 1}"

      # ‚úÖ Get user's previous answer from saved_step
      user_answer = saved_step.get("user_answers", [])

      window.console.log(f"Question HTML: {question_html[:100]}...")
      window.console.log(f"User answer: {user_answer}")

      # Create question
      q_div = document.createElement("div")
      q_div.style.cssText = "margin-bottom:16px;font-size:15px;color:#334155;line-height:1.6;"
      q_div.innerHTML = question_html
      container.appendChild(q_div)

      # Create math input field container
      input_container = document.createElement("div")
      input_container.className = "math-input-container"
      input_container.style.cssText = "border:2px solid #cbd5e1;border-radius:8px;padding:12px;background:white;margin-top:12px;"

      # ‚úÖ Create span element for MathQuill initialization
      math_field = document.createElement("span")
      math_field.className = "math-input step-answer"
      math_field.style.cssText = "min-height:40px;font-size:16px;display:block;"

      input_container.appendChild(math_field)
      container.appendChild(input_container)

      # ‚úÖ Initialize MathQuill field
      if self.MQ:
          try:
              mq_instance = self.MQ.MathField(math_field)
              # Set previous answer if available
              if user_answer and len(user_answer) > 0:
                  mq_instance.latex(user_answer[0])
                  window.console.log(f"‚úÖ Set previous answer: {user_answer[0]}")
              # Store instance for later access
              container.mq_field = mq_instance
              window.console.log("‚úÖ MathQuill field initialized")
          except Exception as e:
              window.console.error(f"‚ùå Error initializing MathQuill: {e}")
              # Fallback: show previous answer as text
              if user_answer and len(user_answer) > 0:
                  prev_answer = document.createElement("div")
                  prev_answer.style.cssText = "margin-top:12px;padding:10px;background:#f1f5f9;border-radius:6px;font-size:14px;color:#475569;"
                  prev_answer.innerHTML = f"<strong>Previous answer:</strong> {user_answer[0]}"
                  container.appendChild(prev_answer)
      else:
          window.console.error("‚ùå MathQuill not available")
          # Show previous answer as text
          if user_answer and len(user_answer) > 0:
              prev_answer = document.createElement("div")
              prev_answer.style.cssText = "margin-top:12px;padding:10px;background:#f1f5f9;border-radius:6px;font-size:14px;color:#475569;"
              prev_answer.innerHTML = f"<strong>Previous answer:</strong> {user_answer[0]}"
              container.appendChild(prev_answer)

    def __init__(self):
        self.problem_set = []
        self.problem_states = {}
        self.current_problem_index = None
        self.current_problem_set_uuid = None
        self.MQ = None

        # ‚úÖ Global history tracking
        self.global_attempt_history = []
        self.problem_global_histories = {}
        self.solve_states = {}  # NEW: {problem_index: solve_state}

        # ‚úÖ Initialize MathParser for expression validation
        self.math_parser = MathParser()

        # ‚úÖ Credit system for freestyle practice
        self.credit_balance = 0
        self.credit_earned_total = 0
        self.credit_spent_total = 0
        self.credit_history = []  # List of credit transactions
        self.freestyle_solved_problems = []  # History of solved problems

        # ‚úÖ Add this line to make the app accessible for button callbacks
        window.problem_solver_app = self
        # ‚úÖ Score recalculation tracker (NEW)

        self.score_display_manager = {
            "last_edit_time": None,
            "edited_problems": set(),
            "pending_score_update": False,
            "pending_percentage": 0
        }
        self.score_tracker = ScoreRecalculationTracker(self)
    
    def init(self):
        # Initialize MathQuill
        if hasattr(window, 'MathQuill'):
            self.MQ = window.MathQuill.getInterface(2)
        
        self.setup_events()
        self.load_from_storage()
        self.load_credit_data()  # Load credit system data
        
        overlay = document.querySelector("#loadingOverlay")
        if overlay:
            overlay.style.opacity = "0"
            window.setTimeout(create_proxy(lambda: overlay.remove()), 400)
        
        # ‚úÖ ADD THIS NEW LINE:
        self.start_score_display_timer()
    
    def setup_events(self):
        # Navigation
        nav_items = document.querySelectorAll(".nav-item")
        for i in range(nav_items.length):
            item = nav_items[i]
            page = item.getAttribute("data-page")
            
            def make_nav_handler(p):
                def handler(e):
                    self.show_page(p)
                return handler
            
            item.addEventListener("click", create_proxy(make_nav_handler(page)))
        
        # Menu button
        menu_btn = document.querySelector("#menuBtn")
        if menu_btn:
            menu_btn.addEventListener("click", create_proxy(lambda e: self.toggle_sidebar(e)))
        
        overlay = document.querySelector("#sidebarOverlay")
        if overlay:
            overlay.addEventListener("click", create_proxy(lambda e: self.close_sidebar(e)))
        
        # File upload
        upload = document.querySelector("#uploadFile")
        if upload:
            upload.addEventListener("change", create_proxy(lambda e: self.handle_file_upload(e)))
        
        # Load JSON button
        load_json_btn = document.querySelector("#loadJsonBtn")
        if load_json_btn:
            load_json_btn.addEventListener("click", create_proxy(lambda e: self.load_json(e)))
        
        # Export button
        export_btn = document.querySelector("#exportProgressBtn")
        if export_btn:
            export_btn.addEventListener("click", create_proxy(lambda e: self.export_progress(e)))
        
        # Credit history modal handlers
        show_history_btn = document.querySelector("#showCreditHistory")
        if show_history_btn:
            show_history_btn.addEventListener("click", create_proxy(lambda e: self.show_credit_history_modal(e)))
        
        close_history_btn = document.querySelector("#closeCreditHistory")
        if close_history_btn:
            close_history_btn.addEventListener("click", create_proxy(lambda e: self.close_credit_history_modal(e)))
    
    def show_page(self, page_name):
        # Hide all pages
        pages = document.querySelectorAll(".page")
        for i in range(pages.length):
            pages[i].classList.remove("active")
        
        # Show selected page
        target = document.querySelector(f"#{page_name}Page")
        if target:
            target.classList.add("active")
        
        # Update nav
        nav_items = document.querySelectorAll(".nav-item")
        for i in range(nav_items.length):
            nav_items[i].classList.remove("active")
        
        active_nav = document.querySelector(f".nav-item[data-page='{page_name}']")
        if active_nav:
            active_nav.classList.add("active")
        
        if page_name == "freestyle":
          def delayed_init():
              self.ensure_freestyle_initialized()
          window.setTimeout(create_proxy(delayed_init), 100)
        
        self.close_sidebar(None)
    
    def toggle_sidebar(self, event):
        sidebar = document.querySelector("#sidebar")
        overlay = document.querySelector("#sidebarOverlay")
        
        if sidebar:
            is_open = sidebar.classList.contains("open")
            if is_open:
                sidebar.classList.remove("open")
                if overlay:
                    overlay.classList.remove("show")
            else:
                sidebar.classList.add("open")
                if overlay:
                    overlay.classList.add("show")
    
    def close_sidebar(self, event):
        sidebar = document.querySelector("#sidebar")
        overlay = document.querySelector("#sidebarOverlay")
        if sidebar:
            sidebar.classList.remove("open")
        if overlay:
            overlay.classList.remove("show")
    
    def load_json(self, event):
        textarea = document.querySelector("#pasteJson")
        if not textarea:
            window.alert("Paste area not found")
            return
        
        content = textarea.value.strip()
        if not content:
            window.alert("Please paste some data first")
            return
        
        try:
            self.decode_and_load(content)
            textarea.value = ""
        except Exception as e:
            window.console.error(f"Error loading pasted data: {e}")
            window.alert(f"‚ùå Error loading data: {e}")
    
    def handle_file_upload(self, event):
        files = event.target.files
        if files and files.length > 0:
            file = files.item(0)
            from js import FileReader
            reader = FileReader.new()
            
            def on_load(e):
                try:
                    content = e.target.result
                    self.decode_and_load(content)
                    event.target.value = ""
                except Exception as ex:
                    window.console.error(f"Error processing file: {ex}")
                    window.alert(f"‚ùå Error processing file: {ex}")
            
            reader.onload = create_proxy(on_load)
            reader.readAsText(file)
    
    def decode_and_load(self, base64text):
        try:
            import brotli
            
            # Extract base64 if wrapped
            if "===" in base64text:
                import re
                pattern = r"===.*?EXPORT.*?===(.*?)(?:===|$)"
                matches = re.findall(pattern, base64text, re.DOTALL)
                if matches:
                    base64text = re.sub(r"[\s\r\n]+", "", "".join(matches))
            
            # Decode and decompress
            compressed = base64.b64decode(base64text)
            json_text = brotli.decompress(compressed).decode("utf-8")
            data = json.loads(json_text)
            
            # Handle different formats
            if isinstance(data, dict) and "problems" in data:
                problems = data["problems"]
                self.current_problem_set_uuid = data.get("problem_set_id", str(uuid.uuid4()))
                description = data.get("problem_set_description", "")
            else:
                problems = data if isinstance(data, list) else []
                self.current_problem_set_uuid = str(uuid.uuid4())
                description = ""
            
            if not problems:
                raise ValueError("No problems found in data")
            
            # Clear and set new data
            self.problem_set = problems
            self.problem_states = {}
            self.current_problem_index = None
            
            # Update UI
            self.update_problem_set_info(description)
            self.render_problems()
            
            window.alert(f"‚úÖ Loaded {len(problems)} problems")
            self.show_page("problems")
            
            # Save
            def delayed_save():
                self.save_to_storage()
            window.setTimeout(create_proxy(delayed_save), 500)
            
        except Exception as e:
            window.console.error(f"Decode error: {e}")
            import traceback
            window.console.error(traceback.format_exc())
            window.alert(f"‚ùå Failed to load: {e}")
    
    def update_problem_set_info(self, description):
        info_panel = document.querySelector("#problemSetInfo")
        desc_el = document.querySelector("#currentProblemSetDescription")
        uuid_el = document.querySelector("#currentProblemSetUuid")
        
        if self.problem_set:
            info_panel.style.display = "block"
            desc_el.textContent = description or "No description"
            uuid_el.textContent = self.current_problem_set_uuid
        else:
            info_panel.style.display = "none"
    
    def render_problems(self):
      """Render problem list with completion status"""
      container = document.querySelector("#solveProblemsContainer")
      if not container:
          return
      container.innerHTML = ""

      # Hide initial panel
      initial_panel = document.querySelector("#initialLoadPanel")
      if initial_panel:
          initial_panel.style.display = "none"

      for idx, prob in enumerate(self.problem_set):
          title = prob.get("title", f"Problem {idx+1}")
          steps = prob.get("steps", [])
          total = len(steps)

          prob_state = self.problem_states.get(idx, [])
          finished = sum(1 for s in prob_state if s.get("finished", False))
          is_done = finished == total and total > 0

          accordion = document.createElement("div")
          accordion.className = "accordion-problem"
          accordion.setAttribute("data-index", idx)

          if is_done:
              accordion.classList.add("finished")

          header = document.createElement("div")
          header.className = "accordion-header"

          # Different header content for completed vs incomplete
          if is_done:
              # ‚úÖ Count must-not-be-correct questions (where must_correct is False)
              non_math_count = 0
              for step in steps:
                  if step.get("requireCorrect") == False:
                      non_math_count += 1

              # Completed problem - show completion message
              if non_math_count > 0:
                  # Has non-math questions - display the count
                  header.innerHTML = f"""
                  <span>{idx+1}. {html.escape(title)}</span>
                  <span class='progress-summary' style='color:#059669;display:flex;align-items:center;gap:8px;'>
                      <span style='font-size:20px;'>üéâ</span>
                      <span style='font-weight:700;'>Completed! (non-math: {non_math_count})</span>
                  </span>
                  """
              else:
                  # All questions require correct answers
                  header.innerHTML = f"""
                  <span>{idx+1}. {html.escape(title)}</span>
                  <span class='progress-summary' style='color:#059669;display:flex;align-items:center;gap:8px;'>
                      <span style='font-size:20px;'>üéâ</span>
                      <span style='font-weight:700;'>Completed!</span>
                  </span>
                  """
              header.style.background = "#f0fdf4"
          else:
              # Incomplete problem - show progress
              progress_color = "#6b7280"
              header.innerHTML = f"""
              <span>{idx+1}. {html.escape(title)}</span>
              <span class='progress-summary' style='color:{progress_color}'>‚úÖ {finished}/{total} completed</span>
              """
              header.style.background = "#f0f4ff"

          header.style.transition = "background 0.2s ease"
          header.style.fontSize = "16px"
          header.style.minHeight = "60px"
          header.style.padding = "16px"
          header.style.fontWeight = "700"
          header.style.cursor = "pointer"
          header.style.display = "flex"
          header.style.justifyContent = "space-between"
          header.style.alignItems = "center"

          def make_hover_handler(h, done):
              def on_hover(e):
                  if done:
                      h.style.background = "#dcfce7"
                  else:
                      h.style.background = "#dbeafe"
              def off_hover(e):
                  if done:
                      h.style.background = "#f0fdf4"
                  else:
                      h.style.background = "#f0f4ff"
              return on_hover, off_hover

          on_h, off_h = make_hover_handler(header, is_done)
          header.addEventListener("mouseenter", create_proxy(on_h))
          header.addEventListener("mouseleave", create_proxy(off_h))

          body = document.createElement("div")
          body.className = "accordion-body"
          body.id = f"problemBody{idx}"

          accordion.appendChild(header)
          accordion.appendChild(body)
          container.appendChild(accordion)

          def make_toggle_handler(i):
              def handler(e):
                  self.toggle_problem(i)
              return handler

          header.addEventListener("click", create_proxy(make_toggle_handler(idx)))

      # ‚úÖ Check if all problems are completed and show banner
      # ‚úÖ Check if all problems are completed and show banner
      # ‚úÖ Check if all problems are completed and show REVIEW SECTION
      def check_and_show_all_complete():
          window.console.log("=" * 80)
          window.console.log("üîç CHECKING COMPLETION STATUS ON LOAD")
          window.console.log("=" * 80)

          # Debug: Check problem_states
          window.console.log(f"Total problems in problem_set: {len(self.problem_set)}")
          window.console.log(f"Total problems in problem_states: {len(self.problem_states)}")

          # Check each problem individually
          for prob_idx in range(len(self.problem_set)):
              problem = self.problem_set[prob_idx]
              steps = problem.get("steps", [])
              total_steps = len(steps)

              window.console.log(f"\nProblem {prob_idx}: {total_steps} total steps")

              if prob_idx in self.problem_states:
                  saved_steps = self.problem_states[prob_idx]
                  window.console.log(f"  Saved state: {len(saved_steps)} steps")

                  finished_count = 0
                  for step_idx, step_state in enumerate(saved_steps):
                      is_finished = step_state.get("finished", False)
                      is_correct = step_state.get("correct", False)
                      window.console.log(f"    Step {step_idx}: finished={is_finished}, correct={is_correct}")
                      if is_finished:
                          finished_count += 1

                  window.console.log(f"  Result: {finished_count}/{total_steps} finished")

                  is_complete = self.is_problem_complete(prob_idx)
                  window.console.log(f"  is_problem_complete() returns: {is_complete}")
              else:
                  window.console.log(f"  ‚ùå No saved state found!")

          # Now check overall completion
          window.console.log("\n" + "=" * 80)
          all_completed = self.check_all_problems_completion()
          window.console.log(f"check_all_problems_completion() returns: {all_completed}")

          all_completed_v2 = self._all_problems_complete()
          window.console.log(f"_all_problems_complete() returns: {all_completed_v2}")
          window.console.log("=" * 80)

          if all_completed_v2:
              window.console.log("‚úÖ ALL COMPLETE - Showing review section in 500ms...")
              # ‚úÖ Show the actual review section with scores
              def show_review_delayed():
                  window.console.log("üìä Calling show_review_section() now...")
                  self.show_review_section()
                  window.console.log("‚úÖ show_review_section() completed")
              window.setTimeout(create_proxy(show_review_delayed), 500)
          else:
              window.console.log("‚è≥ NOT ALL COMPLETE - Opening first incomplete problem")
              # Not all complete - auto-open first incomplete problem
              first_incomplete = self.find_first_incomplete_problem()
              window.console.log(f"First incomplete problem: {first_incomplete}")
              if first_incomplete is not None:
                  def auto_open():
                      self.toggle_problem(first_incomplete)
                  window.setTimeout(create_proxy(auto_open), 100)
                  window.console.log(f"‚úÖ Auto-opening first incomplete problem: {first_incomplete}")

      # Delay the check slightly to ensure DOM is ready
      window.setTimeout(create_proxy(check_and_show_all_complete), 200)
    
    def toggle_problem(self, index):
      """Toggle problem accordion open/close"""
      # Prevent recursive calls
      if hasattr(self, '_toggling') and self._toggling:
          window.console.warn("‚ö†Ô∏è Already toggling, skipping...")
          return

      self._toggling = True

      try:
          acc = document.querySelector(f".accordion-problem[data-index='{index}']")
          if not acc:
              self._toggling = False
              return

          # Close if already open
          if acc.classList.contains("open"):
              # ‚úÖ Save global history before closing
              if self.current_problem_index is not None:
                  self.save_global_history_state(self.current_problem_index)
              acc.classList.remove("open")
              self._toggling = False
              return

          # ‚úÖ Save current problem's history before switching
          if self.current_problem_index is not None and self.current_problem_index != index:
              window.console.log(f"Saving global history for problem {self.current_problem_index} before switching")
              self.save_global_history_state(self.current_problem_index)

          # Close all
          accordions = document.querySelectorAll(".accordion-problem")
          for i in range(accordions.length):
              accordions[i].classList.remove("open")

          # Open selected
          acc.classList.add("open")
          body = acc.querySelector(".accordion-body")

          if not body:
              self._toggling = False
              return

          # ‚úÖ NEW: Check if problem is complete BEFORE checking if loaded
          is_complete = self.check_problem_completion(index)
          is_first_load = not body.getAttribute("data-loaded")

          if is_complete:
              # ‚úÖ COMPLETED PROBLEM: Always reload to show completion banner
              window.console.log(f"‚úÖ Problem {index} is complete, reloading completion view")
              self.current_problem_index = index
              body.innerHTML = ""  # Clear old content
              self.load_problem(index, body)  # Reload (will show banner only)
              body.setAttribute("data-loaded", "true")

          elif is_first_load:
              # ‚úÖ INCOMPLETE PROBLEM: First load
              window.console.log(f"üìÇ First time loading problem {index}")
              self.current_problem_index = index
              self.load_problem(index, body)
              body.setAttribute("data-loaded", "true")

          else:
              # ‚úÖ INCOMPLETE PROBLEM: Reopening
              window.console.log(f"üìÇ Reopening incomplete problem {index}")
              self.current_problem_index = index

              # ‚úÖ Restore solve_state if available
              if index in self.solve_states:
                  self.solve_state = self.solve_states[index]
                  window.console.log(f"‚úÖ Restored solve_state with {len(self.solve_state)} steps")
              else:
                  window.console.warn(f"‚ö†Ô∏è No solve_state found, using current state")
                
              # Show first unfinished step
              first_unfinished = self.find_first_unfinished_step(index)
              if first_unfinished is not None and hasattr(self, 'solve_state'):
                  # Hide all steps
                  for i, step in enumerate(self.solve_state):
                      step["container"].style.display = "none"
                      step["container"].classList.remove("active")

                  # Show first unfinished
                  self.solve_state[first_unfinished]["container"].style.display = "block"
                  self.solve_state[first_unfinished]["container"].classList.add("active")

                  window.console.log(f"‚úÖ Reopened to step {first_unfinished}")

          # Re-render MathJax when reopening
          def rerender_mathjax(retry_count=0):
              max_retries = 3
              try:
                  if hasattr(window, 'MathJax') and hasattr(window.MathJax, 'typesetPromise'):
                      window.console.log("üé® Re-rendering MathJax for reopened problem...")
                      window.MathJax.typesetPromise([body]).then(
                          create_proxy(lambda result: window.console.log("‚úÖ MathJax re-rendered"))
                      )
                  elif retry_count < max_retries:
                      window.setTimeout(create_proxy(lambda: rerender_mathjax(retry_count + 1)), 200)
              except Exception as e:
                  window.console.error(f"MathJax re-render error: {e}")

          window.setTimeout(create_proxy(lambda: rerender_mathjax(0)), 100)

      finally:
          # Clear the lock after a short delay
          def clear_lock():
              self._toggling = False
          window.setTimeout(create_proxy(clear_lock), 100)
    
    def restore_global_history_state(self, prob_idx):
      """Restore the saved global history state for a problem"""
      try:
          if prob_idx not in self.problem_global_histories:
              return False

          saved_state = self.problem_global_histories[prob_idx]
          global_history = document.querySelector(f"#globalHistory_{prob_idx}")

          if not global_history:
              return False

          # Restore the HTML content
          global_history.innerHTML = saved_state["html"]

          # Restore visibility
          if saved_state["visible"]:
              global_history.style.display = "block"
          else:
              global_history.style.display = "none"

          window.console.log(f"‚úÖ Restored global history for problem {prob_idx}")
          return True
      except Exception as e:
          window.console.error(f"‚ùå Failed to restore global history: {e}")
          return False

    
    def save_global_history_state(self, prob_idx):
      """Save the current global history state for a problem"""
      try:
          global_history = document.querySelector(f"#globalHistory_{prob_idx}")
          if not global_history:
              window.console.warn(f"‚ö†Ô∏è No global history element for problem {prob_idx}")
              return

          # Save the innerHTML
          history_html = global_history.innerHTML
          is_visible = global_history.style.display != "none"

          self.problem_global_histories[prob_idx] = {
              "html": history_html,
              "visible": is_visible
          }

          window.console.log(f"‚úÖ Saved global history for problem {prob_idx}")
      except Exception as e:
          window.console.error(f"‚ùå Failed to save global history: {e}")

    
    def add_to_global_history(self, step_idx, latex, correct, time_taken, attempt_type):
        """Add attempt to global history view"""
        window.console.log(f"üîµ Adding to global history: step {step_idx}, correct={correct}")
        if self.current_problem_index is None:
            window.console.error(f"‚ùå current_problem_index is None")
            return
        global_history_id = f"#globalHistory_{self.current_problem_index}"
        global_history = document.querySelector(global_history_id)
        if not global_history:
            window.console.error(f"‚ùå Global history element not found: {global_history_id}")
            return

        # Show the container
        global_history.style.display = "block"

        # Convert LaTeX for display (handle matrices and row operations)
        display_latex = self._convert_for_display(latex)

        # Create entry
        entry = document.createElement("div")
        entry.className = "attempt-entry-wrapper"
        if attempt_type == "submit":
            entry.style.background = "#dcfce7" if correct else "#fee2e2"
            entry.style.border = f"2px solid {'#86efac' if correct else '#fecaca'}"
            status_text = '‚úÖ Correct' if correct else '‚ùå Incorrect'
            step_label = f"Step {step_idx + 1}"
        else:  # finalize or other
            entry.style.background = "#dcfce7" if correct else "#fef3c7"
            entry.style.border = f"2px solid {'#86efac' if correct else '#fbbf24'}"
            status_text = '‚úÖ Finalized' if correct else '‚ö†Ô∏è Check'
            step_label = f"Step {step_idx + 1}"

        entry.innerHTML = f"""
        <div style='font-weight:700;font-size:15px;'>
            {step_label}: {status_text} ({time_taken if time_taken else 0}s)
        </div>
        <div style='margin-top:6px;padding:8px;background:#fff;border-radius:6px;overflow-x:auto;'>
            $$\\displaystyle {display_latex}$$
        </div>
        """
        global_history.appendChild(entry)

        # Re-render MathJax
        if hasattr(window, 'MathJax') and hasattr(window.MathJax, 'typesetPromise'):
            window.MathJax.typesetPromise([entry])

        # Scroll to bottom
        global_history.scrollTop = global_history.scrollHeight
        window.console.log(f"‚úÖ Added entry to global history")

    def _convert_for_display(self, latex):
        """Convert LaTeX for display, handling matrices and row operations"""
        try:
            import sympy as sp
            import re

            # Check if this is a row operation
            is_row_op = (
                '|R_' in latex or 
                '|\\mathrm{R}_' in latex or
                '\\left|R_' in latex or
                '\\right|' in latex
            )

            # Check if contains matrices
            has_matrix = (
                '[[' in latex or 
                '\\left[\\left[' in latex or 
                '\\begin{matrix}' in latex or
                '\\begin{bmatrix}' in latex or
                '\\begin{pmatrix}' in latex
            )

            # Handle row operations: convert matrix part, keep operation part
            if is_row_op and has_matrix:
                window.console.log(f"Converting row operation for display: {latex}")

                # Split at the pipe: matrix part | operation part
                match = re.match(r'(.+?)(\\left\|.*?\\right\|)', latex)

                if match:
                    matrix_part = match.group(1)
                    operation_part = match.group(2)

                    # Convert only the matrix part
                    parsed_matrix = self.math_parser.parse_latex(matrix_part)
                    converted_matrix = self._convert_latex_preserve_order(parsed_matrix)

                    # Combine: converted matrix + original operation
                    result = converted_matrix + operation_part
                    window.console.log(f"  ‚úÖ Row operation converted: {result}")
                    return result
                else:
                    window.console.log("  Regex didn't match, using original")
                    return latex

            # Regular matrices (not row operations)
            elif has_matrix and not is_row_op:
                window.console.log(f"Converting matrix for display: {latex}")

                # Parse and convert
                parsed = self.math_parser.parse_latex(latex)
                result = self._convert_latex_preserve_order(parsed)

                window.console.log(f"  ‚úÖ Matrix converted: {result}")
                return result

            # No matrices, use original
            else:
                return latex

        except Exception as e:
            window.console.error(f"Error converting LaTeX for display: {e}")
            import traceback
            window.console.error(traceback.format_exc())
            # Fallback to original
            return latex
    
    def find_first_incomplete_problem(self):
      """
      Find the index of the first incomplete problem.
      Returns None if all problems are complete.
      """
      for idx in range(len(self.problem_set)):
          if not self.check_problem_completion(idx):
              window.console.log(f"Found first incomplete problem at index {idx}")
              return idx

      window.console.log("All problems are complete")
      return None
    
    def find_first_unfinished_step(self, problem_idx):
      """
      Find the index of the first unfinished step in a problem.
      Returns None if all steps are finished or no saved state exists.
      """
      # Check if we have saved state for this problem
      if problem_idx not in self.problem_states:
          window.console.log(f"No saved state for problem {problem_idx}, starting from step 0")
          return 0

      saved_state = self.problem_states[problem_idx]

      if not saved_state:
          window.console.log(f"Empty saved state for problem {problem_idx}, starting from step 0")
          return 0

      # Find first unfinished step
      for i, step_state in enumerate(saved_state):
          if not step_state.get("finished", False):
              window.console.log(f"Found first unfinished step at index {i}")
              return i

      # All steps finished - show last step
      window.console.log(f"All steps finished, showing last step")
      return len(saved_state) - 1 if saved_state else 0
    
    def save_to_storage(self):
        """Save to localStorage - problem_set compressed, problem_states uncompressed"""
        try:
            import json
            import base64
            import brotli

            # ============================================
            # PART 1: Save problem_set (COMPRESSED - large, changes rarely)
            # ============================================

            if self.problem_set:
                problem_set_data = {
                    "problem_set_id": self.current_problem_set_uuid,
                    "problem_set": self.problem_set,
                    "description": getattr(self, '_problem_set_description', '')
                }

                # Compress problem set
                json_str = json.dumps(problem_set_data)
                compressed = brotli.compress(json_str.encode('utf-8'))
                encoded = base64.b64encode(compressed).decode('ascii')
                window.localStorage.setItem("problem_solver_problem_set", encoded)

                window.console.log(f"‚úÖ Saved compressed problem set ({len(self.problem_set)} problems)")

            # ============================================
            # PART 2: Save problem_states (UNCOMPRESSED - small, changes frequently)
            # ============================================

            # ‚úÖ Clean problem_states - remove DOM elements
            clean_problem_states = {}
            for prob_idx, steps in self.problem_states.items():
                clean_problem_states[str(prob_idx)] = []
                for step in steps:
                    clean_step = {
                        "finished": step.get("finished", False),
                        "correct": step.get("correct", False),
                        "user_answers": step.get("user_answers", []),
                        "attempts": step.get("attempts", 0),
                        "structure_correct": step.get("structure_correct", False),
                        "points": step.get("points", 100),
                        "score": step.get("score", 0)
                    }
                    clean_problem_states[str(prob_idx)].append(clean_step)

            # Save as plain JSON (fast updates!)
            window.localStorage.setItem("problem_solver_states", json.dumps(clean_problem_states))

            # Debug log
            for prob_idx, steps in self.problem_states.items():
                finished_count = sum(1 for step in steps if step.get("finished", False))
                total_steps = len(steps)
                window.console.log(f"üíæ Problem {prob_idx}: {finished_count}/{total_steps} finished")

            window.console.log(f"‚úÖ Saved problem states ({len(self.problem_states)} problems)")

            # Save current problem index
            if self.current_problem_index is not None:
                window.localStorage.setItem("problem_solver_current_index", str(self.current_problem_index))

            # ============================================
            # PART 3: Save enhanced tracking data
            # ============================================

            # Save score display manager state
            manager_state = {
                "edited_problems": list(self.score_display_manager["edited_problems"]),
                "last_edit_time": self.score_display_manager["last_edit_time"],
                "pending_score_update": self.score_display_manager["pending_score_update"],
                "pending_percentage": self.score_display_manager["pending_percentage"]
            }
            window.localStorage.setItem("score_display_manager", json.dumps(manager_state))
            window.console.log("‚úÖ Saved score display manager")

            # Save global edit tracking
            if hasattr(self.score_tracker, 'ever_edited_steps') and self.score_tracker.ever_edited_steps:
                edits_to_save = {}
                for (prob_idx, step_idx) in self.score_tracker.ever_edited_steps:
                    prob_key = str(prob_idx)
                    if prob_key not in edits_to_save:
                        edits_to_save[prob_key] = {}
                    edits_to_save[prob_key][str(step_idx)] = True

                window.localStorage.setItem("score_edits", json.dumps(edits_to_save))
                window.console.log(f"‚úÖ Saved {len(self.score_tracker.ever_edited_steps)} edit records")

            # Save credit data
            if hasattr(self, 'credit_balance'):
                credit_data = {
                    "balance": self.credit_balance,
                    "earned_total": self.credit_earned_total,
                    "spent_total": self.credit_spent_total,
                    "history": self.credit_history
                }
                window.localStorage.setItem("credit_data", json.dumps(credit_data))
                window.console.log("‚úÖ Saved credit data")

            window.console.log("‚úÖ Save complete")

        except Exception as e:
            window.console.error(f"‚ö†Ô∏è Error saving to localStorage: {e}")
            import traceback
            window.console.error(traceback.format_exc())


    def load_from_storage(self):
        """Load from localStorage - problem_set compressed, problem_states uncompressed"""
        try:
            window.console.log("üîç Loading data from localStorage...")
            import json

            # ============================================
            # PART 1: Load problem_set (COMPRESSED)
            # ============================================

            stored_problem_set = window.localStorage.getItem("problem_solver_problem_set")
            if stored_problem_set:
                try:
                    import brotli
                    import base64

                    # Decompress problem set
                    compressed = base64.b64decode(stored_problem_set)
                    json_str = brotli.decompress(compressed).decode('utf-8')
                    data = json.loads(json_str)

                    # Restore problem set data
                    self.current_problem_set_uuid = data.get("problem_set_id")
                    self.problem_set = data.get("problem_set", [])
                    self._problem_set_description = data.get("description", "")

                    window.console.log(f"‚úÖ Loaded compressed problem set: {len(self.problem_set)} problems")

                except Exception as e:
                    window.console.error(f"‚ö†Ô∏è Error loading compressed problem set: {e}")
                    # Try legacy format
                    self._try_load_legacy_compressed_format()
            else:
                window.console.log("‚ÑπÔ∏è No problem set found")
                # Try legacy format
                self._try_load_legacy_compressed_format()

            # ============================================
            # PART 2: Load problem_states (UNCOMPRESSED - fast!)
            # ============================================

            stored_states = window.localStorage.getItem("problem_solver_states")
            if stored_states:
                loaded_states = json.loads(stored_states)

                # Convert string keys to integers
                self.problem_states = {}
                for k, v in loaded_states.items():
                    self.problem_states[int(k)] = v

                window.console.log(f"‚úÖ Loaded problem states: {len(self.problem_states)} problems")

                # ‚úÖ DEBUG: Log completion data
                window.console.log("=" * 50)
                window.console.log("üìä LOADED COMPLETION DATA:")
                for prob_idx, steps in self.problem_states.items():
                    finished_count = sum(1 for step in steps if step.get("finished", False))
                    total_steps = len(steps)
                    is_complete = finished_count >= total_steps and total_steps > 0
                    status = "‚úÖ COMPLETE" if is_complete else f"‚è≥ {finished_count}/{total_steps}"
                    window.console.log(f"  Problem {prob_idx}: {status}")
                window.console.log("=" * 50)
            else:
                window.console.log("‚ÑπÔ∏è No problem states found - starting fresh")
                self.problem_states = {}

            # Load current problem index
            current_index_str = window.localStorage.getItem("problem_solver_current_index")
            if current_index_str:
                self.current_problem_index = int(current_index_str)

            # ‚úÖ Initialize solve_states as empty (UI only, not persisted)
            self.solve_states = {}
            window.console.log("‚úÖ Initialized empty solve_states (UI only)")

            # Update UI if problem set exists
            if self.problem_set:
                self.update_problem_set_info(self._problem_set_description)
                self.render_problems()
                window.console.log("‚úÖ Problem set rendered")

            # ============================================
            # PART 3: Load enhanced tracking data
            # ============================================

            # Load score display manager state
            score_manager_data = window.localStorage.getItem("score_display_manager")
            if score_manager_data:
                try:
                    manager_data = json.loads(score_manager_data)

                    if "edited_problems" in manager_data:
                        self.score_display_manager["edited_problems"] = set(manager_data["edited_problems"])
                        window.console.log(f"‚úÖ Restored {len(self.score_display_manager['edited_problems'])} edited problems")

                    if "last_edit_time" in manager_data:
                        self.score_display_manager["last_edit_time"] = manager_data["last_edit_time"]

                    if "pending_score_update" in manager_data:
                        self.score_display_manager["pending_score_update"] = manager_data["pending_score_update"]
                        self.score_display_manager["pending_percentage"] = manager_data.get("pending_percentage", 0)

                    window.console.log("‚úÖ Restored score display manager state")
                except Exception as e:
                    window.console.error(f"‚ö†Ô∏è Error loading score manager data: {e}")

            # Load global edit tracking
            edits_data = window.localStorage.getItem("score_edits")
            if edits_data:
                try:
                    edits = json.loads(edits_data)

                    for prob_idx_str, step_edits in edits.items():
                        prob_idx = int(prob_idx_str)
                        for step_idx_str in step_edits.keys():
                            step_idx = int(step_idx_str)
                            self.score_tracker.ever_edited_steps.add((prob_idx, step_idx))

                    total_edits = len(self.score_tracker.ever_edited_steps)
                    window.console.log(f"‚úÖ Restored {total_edits} historical edits")
                except Exception as e:
                    window.console.error(f"‚ö†Ô∏è Error loading edit tracking: {e}")

            # Load credit data
            credit_data = window.localStorage.getItem("credit_data")
            if credit_data:
                try:
                    credits = json.loads(credit_data)
                    self.credit_balance = credits.get("balance", 0)
                    self.credit_earned_total = credits.get("earned_total", 0)
                    self.credit_spent_total = credits.get("spent_total", 0)
                    self.credit_history = credits.get("history", [])
                    window.console.log(f"‚úÖ Loaded credit data: {self.credit_balance} credits")
                except Exception as e:
                    window.console.error(f"‚ö†Ô∏è Error loading credit data: {e}")

            # ============================================
            # PART 4: Auto-open first incomplete problem
            # ============================================

            if self.problem_set and len(self.problem_states) > 0:
                first_incomplete = None
                for prob_idx in range(len(self.problem_set)):
                    if prob_idx in self.problem_states:
                        steps = self.problem_states[prob_idx]
                        finished_count = sum(1 for step in steps if step.get("finished", False))
                        total_steps = len(steps)

                        if finished_count < total_steps:
                            first_incomplete = prob_idx
                            window.console.log(f"Found first incomplete problem at index {prob_idx}")
                            break
                    else:
                        first_incomplete = prob_idx
                        break

                if first_incomplete is not None:
                    window.console.log(f"‚úÖ Auto-opening first incomplete problem: {first_incomplete}")

                    def open_problem():
                        self.toggle_problem(first_incomplete)
                    window.setTimeout(create_proxy(open_problem), 500)

            window.console.log("‚úÖ Load complete")

        except Exception as e:
            window.console.error(f"‚ö†Ô∏è Critical error in load_from_storage: {e}")
            import traceback
            window.console.error(traceback.format_exc())


    def _try_load_legacy_compressed_format(self):
      """Try loading from old format where everything was compressed together"""
      try:
          import brotli
          import json
          import base64

          stored = window.localStorage.getItem("problem_solver_data")
          if stored:
              # Decompress
              compressed = base64.b64decode(stored)
              json_str = brotli.decompress(compressed).decode('utf-8')
              data = json.loads(json_str)

              # Extract data
              self.current_problem_set_uuid = data.get("problem_set_id")
              self.problem_set = data.get("problem_set", [])

              # ‚úÖ CRITICAL FIX: Load old problem_states
              loaded_states = data.get("problem_states", {})
              self.problem_states = {}

              # Convert keys and validate structure
              for k, v in loaded_states.items():
                  prob_idx = int(k)

                  # ‚úÖ VALIDATE: Ensure each step has required fields
                  if isinstance(v, list):
                      validated_steps = []
                      for step_data in v:
                          if isinstance(step_data, dict):
                              # Ensure all required fields exist with proper defaults
                              validated_step = {
                                  "finished": step_data.get("finished", False),
                                  "correct": step_data.get("correct", False),
                                  "user_answers": step_data.get("user_answers", []),
                                  "attempts": step_data.get("attempts", 0),
                                  "structure_correct": step_data.get("structure_correct", False),
                                  "points": step_data.get("points", 100),
                                  "score": step_data.get("score", 0)
                              }
                              validated_steps.append(validated_step)

                      # ‚úÖ Only save if we have valid steps
                      if len(validated_steps) > 0:
                          self.problem_states[prob_idx] = validated_steps

              # ‚úÖ CRITICAL: If problem_states are empty or wrong, initialize from problem_set
              for prob_idx, problem in enumerate(self.problem_set):
                  if prob_idx not in self.problem_states or len(self.problem_states[prob_idx]) == 0:
                      steps = problem.get("steps", [])
                      if len(steps) > 0:
                          window.console.log(f"‚ö†Ô∏è Initializing problem_states for problem {prob_idx} ({len(steps)} steps)")
                          self.problem_states[prob_idx] = []
                          for step in steps:
                              self.problem_states[prob_idx].append({
                                  "finished": False,
                                  "correct": False,
                                  "user_answers": [],
                                  "attempts": 0,
                                  "structure_correct": False,
                                  "points": step.get("points", 100),
                                  "score": 0
                              })

              self.current_problem_index = data.get("current_problem_index")
              self._problem_set_description = data.get("description", "")

              window.console.log("‚úÖ Loaded from legacy compressed format")

              # Debug: Verify what we loaded
              for prob_idx, steps in self.problem_states.items():
                  window.console.log(f"  Problem {prob_idx}: {len(steps)} steps initialized")

              # Migrate to new format
              self.save_to_storage()
              window.console.log("‚úÖ Migrated to new storage format")

      except Exception as e:
          window.console.error(f"‚ö†Ô∏è Could not load legacy format: {e}")
          import traceback
          window.console.error(traceback.format_exc())
    def save_problem_to_storage(self, problem_idx):
        """Save a specific problem's state - FAST (uncompressed JSON)"""

        if problem_idx not in self.problem_states:
            window.console.warn(f"‚ö†Ô∏è Cannot save problem {problem_idx} - not in problem_states")
            return

        try:
            import json

            # ‚úÖ Only update problem_states in localStorage (fast!)
            clean_problem_states = {}
            for prob_idx, steps in self.problem_states.items():
                clean_problem_states[str(prob_idx)] = []
                for step in steps:
                    clean_step = {
                        "finished": step.get("finished", False),
                        "correct": step.get("correct", False),
                        "user_answers": step.get("user_answers", []),
                        "attempts": step.get("attempts", 0),
                        "structure_correct": step.get("structure_correct", False),
                        "points": step.get("points", 100),
                        "score": step.get("score", 0)
                    }
                    clean_problem_states[str(prob_idx)].append(clean_step)

            # Save just the states (no compression needed - it's small and fast!)
            window.localStorage.setItem("problem_solver_states", json.dumps(clean_problem_states))

            steps = self.problem_states[problem_idx]
            finished_count = sum(1 for step in steps if step.get("finished", False))
            total_steps = len(steps)
            window.console.log(f"üíæ Saved problem {problem_idx}: {finished_count}/{total_steps} finished")

        except Exception as e:
            window.console.error(f"‚ùå Error saving problem {problem_idx}: {e}")
    
    def load_problem(self, index, body_container=None):
      """Load a problem into the solve UI"""
      window.console.log(f"üìÇ Loading problem {index}")

      # Get the container
      if body_container is None:
          body_container = document.querySelector(f"#problemBody{index}")

      if not body_container:
          window.console.error(f"‚ùå No container found for problem {index}")
          return

      # ‚úÖ GUARD: Check if already loading this problem
      if hasattr(self, '_currently_loading_problem') and self._currently_loading_problem == index:
          window.console.warn(f"‚ö†Ô∏è Already loading problem {index}, skipping duplicate call")
          return

      # ‚úÖ Check if container already has content and problem is loaded
      if body_container.children.length > 0 and self.current_problem_index == index:
          window.console.log(f"‚úÖ Problem {index} already loaded, skipping reload")
          return

      # Set loading flag
      self._currently_loading_problem = index
      window.console.log(f"üîí Set loading flag for problem {index}")

      container = body_container
      self.current_problem_index = index

      # Get problem data
      if index >= len(self.problem_set):
          window.console.error(f"‚ùå Problem {index} out of range")
          self._currently_loading_problem = None
          return

      problem = self.problem_set[index]
      steps = problem.get("steps", [])

      if len(steps) == 0:
          container.innerHTML = "<p style='color:#ef4444;'>‚ùå No steps found for this problem</p>"
          self._currently_loading_problem = None
          return

      # ============================================
      # ‚úÖ CHECK COMPLETION FROM problem_states (single source of truth)
      # ============================================

      is_complete = False
      finished_count = 0
      total_steps = len(steps)

      if index in self.problem_states:
          saved_state = self.problem_states[index]
          finished_count = sum(1 for step in saved_state if step.get("finished", False))

          window.console.log(f"Problem {index} completion check: {finished_count}/{total_steps} = {finished_count >= total_steps}")

          if finished_count >= total_steps and total_steps > 0:
              is_complete = True

      # ============================================
      # ‚úÖ IF COMPLETE: Show banner and RETURN
      # ============================================

      if is_complete:
          window.console.log(f"‚úÖ Problem {index} is complete, showing completion banner only")

          container.innerHTML = ""
          self.show_problem_completion_banner(index)

          # Hide attempt history
          history_container = document.querySelector(f"#globalHistory_{index}")
          if history_container:
              history_container.style.display = "none"

          # Render MathJax
          def render_mathjax(retry_count=0):
              try:
                  if hasattr(window, 'MathJax') and hasattr(window.MathJax, 'typesetPromise'):
                      window.MathJax.typesetPromise([container]).then(
                          create_proxy(lambda: window.console.log("‚úÖ MathJax re-rendered"))
                      )
              except Exception as e:
                  window.console.error(f"MathJax error: {e}")

          window.setTimeout(create_proxy(render_mathjax), 100)

          self._currently_loading_problem = None
          window.console.log(f"üîì Cleared loading flag for problem {index}")
          return

      # ============================================
      # ‚úÖ INCOMPLETE - Create solve UI
      # ============================================

      window.console.log(f"‚è≥ Problem {index} is incomplete, creating solve UI")
      container.innerHTML = ""

      # Global attempt history container
      global_history_div = document.createElement("div")
      global_history_div.id = f"globalHistory_{index}"
      global_history_div.className = "panel"
      global_history_div.style.cssText = "background:#f8fafc;margin-bottom:16px;display:none;max-height:400px;overflow-y:auto;padding:12px;border-radius:8px;"

      if index in self.problem_global_histories:
          saved_state = self.problem_global_histories[index]
          global_history_div.innerHTML = saved_state.get("html", "<div style='font-weight:700;margin-bottom:10px;font-size:16px;'>üìù All Attempts History:</div>")
          if saved_state.get("visible", False):
              global_history_div.style.display = "block"
      else:
          global_history_div.innerHTML = "<div style='font-weight:700;margin-bottom:10px;font-size:16px;'>üìù All Attempts History:</div>"

      container.appendChild(global_history_div)

      self.global_attempt_history = []
      self.solve_state = []

      # ‚úÖ Initialize problem_states for this problem if needed
      if index not in self.problem_states:
          self.problem_states[index] = []
          for step in steps:
              self.problem_states[index].append({
                  "finished": False,
                  "correct": False,
                  "user_answers": [],
                  "attempts": 0,
                  "structure_correct": False,
                  "points": step.get("points", 100),
                  "score": 0
              })
          window.console.log(f"‚úÖ Initialized problem_states for problem {index} with {len(steps)} steps")
          # Save immediately
          self.save_problem_to_storage(index)
      elif len(self.problem_states[index]) != len(steps):
          # ‚úÖ FIX: Mismatch between saved state and actual steps
          window.console.warn(f"‚ö†Ô∏è Problem {index} has {len(self.problem_states[index])} saved steps but {len(steps)} actual steps - reinitializing")
          self.problem_states[index] = []
          for step in steps:
              self.problem_states[index].append({
                  "finished": False,
                  "correct": False,
                  "user_answers": [],
                  "attempts": 0,
                  "structure_correct": False,
                  "points": step.get("points", 100),
                  "score": 0
              })
          self.save_problem_to_storage(index)

      # Create step UI
      for step_idx, step_data in enumerate(steps):
          step_div = document.createElement("div")
          step_div.className = "panel step"

          step_type = step_data.get("step_type", "math-expression")
          if step_type == "step-by-step":
              step_type = "math-expression"

          window.console.log(f"Creating step {step_idx} with type: {step_type}")

          # Render description
          step_desc = step_data.get("description", [])
          desc_html = self.render_content_blocks(step_desc)

          # Create UI based on type
          if step_type == "math-expression":
              self.create_math_expression_ui(step_div, step_idx, step_data, desc_html, len(steps))
          elif step_type == "multiple-choice-single":
              self.create_mc_single_ui(step_div, step_idx, step_data, desc_html, len(steps))
          elif step_type == "multiple-choice-multiple":
              self.create_mc_multiple_ui(step_div, step_idx, step_data, desc_html, len(steps))
          elif step_type == "true-false":
              self.create_truefalse_ui(step_div, step_idx, step_data, desc_html, len(steps))
          elif step_type == "fill-blank":
              self.create_fillblank_ui(step_div, step_idx, step_data, desc_html, len(steps))
          else:
              window.console.error(f"Unknown step type: {step_type}")
              continue

          container.appendChild(step_div)

          # ‚úÖ Get saved data from problem_states (single source of truth)
          saved_data = self.problem_states[index][step_idx] if step_idx < len(self.problem_states[index]) else {}

          window.console.log(f"Step {step_idx} saved data: finished={saved_data.get('finished')}, correct={saved_data.get('correct')}")

          # ‚úÖ Create step object with data from problem_states
          step_obj = {
              "step": step_data,
              "step_data": step_data,
              "container": step_div,
              "step_type": step_type,
              "attempts": saved_data.get("attempts", 0),
              "finished": saved_data.get("finished", False),
              "correct": saved_data.get("correct", False),
              "structure_correct": saved_data.get("structure_correct", False),
              "user_answers": saved_data.get("user_answers", [])
          }

          self.solve_state.append(step_obj)

      # ‚úÖ Store solve_state for this problem
      self.solve_states[index] = self.solve_state
      window.console.log(f"‚úÖ Stored solve_state for problem {index} with {len(self.solve_state)} steps")

      # Find and show first unfinished step
      first_unfinished_idx = None
      for i, step_obj in enumerate(self.solve_state):
          if not step_obj["finished"]:
              first_unfinished_idx = i
              break

      if first_unfinished_idx is None:
          first_unfinished_idx = 0

      window.console.log(f"üìç First unfinished step: {first_unfinished_idx}")

      # Hide all, show first unfinished
      for i, step in enumerate(self.solve_state):
          if i == first_unfinished_idx:
              step["container"].style.display = "block"
              step["container"].classList.add("active")
          else:
              step["container"].style.display = "none"
              step["container"].classList.remove("active")

      window.console.log(f"‚úÖ Showing step {first_unfinished_idx}")

      # Scroll to step
      def scroll_to_step():
          target_step = self.solve_state[first_unfinished_idx]["container"]
          if target_step:
              target_step.scrollIntoView({'behavior': 'smooth', 'block': 'start'})
              window.console.log(f"üìú Scrolled to step {first_unfinished_idx}")

      window.setTimeout(create_proxy(scroll_to_step), 300)

      # Update progress
      def update_after_load():
          self.update_problem_progress(index)
      window.setTimeout(create_proxy(update_after_load), 100)

      # Render MathJax
      def render_mathjax(retry_count=0):
          max_retries = 5
          try:
              if hasattr(window, 'MathJax') and hasattr(window.MathJax, 'typesetPromise'):
                  window.console.log(f"üé® Rendering MathJax (attempt {retry_count + 1})...")
                  window.MathJax.typesetPromise([container]).then(
                      create_proxy(lambda result: window.console.log("‚úÖ MathJax rendered successfully"))
                  ).catch(
                      create_proxy(lambda error: window.console.error(f"MathJax render error: {error}"))
                  )
              else:
                  if retry_count < max_retries:
                      window.console.warn(f"‚ö†Ô∏è MathJax not ready yet, retrying in 300ms... (attempt {retry_count + 1}/{max_retries})")
                      window.setTimeout(create_proxy(lambda: render_mathjax(retry_count + 1)), 300)
                  else:
                      window.console.error("‚ùå MathJax failed to load after maximum retries")
          except Exception as e:
              window.console.error(f"MathJax render exception: {e}")
              if retry_count < max_retries:
                  window.setTimeout(create_proxy(lambda: render_mathjax(retry_count + 1)), 300)

      window.setTimeout(create_proxy(lambda: render_mathjax(0)), 500)

      # ‚úÖ Clear loading flag
      self._currently_loading_problem = None
      window.console.log(f"üîì Cleared loading flag for problem {index}")

    def render_content_blocks(self, blocks):
      """Render Quill content blocks to HTML"""
      if not blocks or not isinstance(blocks, list):
          return ""

      html_parts = []
      for block in blocks:
          if not isinstance(block, dict):
              continue

          block_type = block.get("type", "")

          if block_type == "text":
              text = block.get("value", "")
              html_parts.append(text.replace('\n', '<br>'))

          elif block_type == "line_break":
              html_parts.append("<br>")

          elif block_type == "mathstring":
              # ‚úÖ Handle mathstring blocks (the actual export format)
              mode = block.get("mode", "")
              text = block.get("text", "")

              if mode == "latex":
                  html_parts.append(f"\\({text}\\)")
              elif mode == "asciimath":
                  html_parts.append(f"`{text}`")

          elif block_type == "image":
              src = block.get("src", "")
              alt = block.get("alt", "")
              if src:
                  html_parts.append(f'<img src="{html.escape(src)}" alt="{html.escape(alt)}" style="max-width:100%;height:auto;display:inline-block;margin:4px;border-radius:4px;">')

      return "".join(html_parts)
    
    def create_math_expression_ui(self, step_div, step_idx, step_data, desc_html, total_steps):
      """Create UI for math expression problems with submit and finalize buttons"""
      must_correct = step_data.get("requireCorrect", False)

      # Badge for must_correct
      must_correct_badge = ""
      if must_correct:
          must_correct_badge = "<span style='background:#fef3c7;color:#b45309;padding:4px 8px;border-radius:4px;font-size:12px;margin-left:8px;'>‚ö†Ô∏è Must be correct</span>"

      step_div.innerHTML = f"""
      <div style='font-weight:700;margin-bottom:8px;'>
          Step {step_idx+1} of {total_steps} {must_correct_badge}
      </div>
      <div class='step-description'>{desc_html}</div>
      <div style='margin-top:12px;'>
        <div style='font-weight:700;margin-bottom:8px;'>Your Answer:</div>
        <div style='border:2px solid #e6eef8;border-radius:8px;padding:10px;background:#fff;'>
          <div class='math-input step-answer'></div>
        </div>
        <div style='display:flex;flex-direction:column;gap:8px;margin-top:12px;'>
          <button class='btn submit-step'>Submit Answer</button>
          <button class='btn finalize-step' disabled style='opacity:0.5;'>Finalize Step</button>
          <button class='btn next-step' style='display:none;background:#10b981;'>Next Step ‚Üí</button>
        </div>
      </div>
      <div class='step-feedback'></div>
      <div class='attempts-history' style='display:none;'></div>
      """

      # Initialize MathQuill
      if self.MQ:
          answer_field = self.MQ.MathField(step_div.querySelector(".step-answer"))
      else:
          answer_field = None

      step_div.answer_mf = answer_field
      step_div.step_data = step_data

      # Submit button - checks correctness only
      submit_btn = step_div.querySelector(".submit-step")
      if submit_btn:
          def submit_handler(e):
              self.submit_math_expression(step_idx)
          submit_btn.addEventListener("click", create_proxy(submit_handler))

      # Finalize button - checks structure
      finalize_btn = step_div.querySelector(".finalize-step")
      if finalize_btn:
          def finalize_handler(e):
              self.finalize_math_expression(step_idx)
          finalize_btn.addEventListener("click", create_proxy(finalize_handler))

      # Next button
      next_btn = step_div.querySelector(".next-step")
      if next_btn:
          def next_handler(e):
              self.next_step(step_idx)
          next_btn.addEventListener("click", create_proxy(next_handler))
    
    def create_mc_single_ui(self, step_div, step_idx, step_data, desc_html, total_steps):
      """Create UI for multiple choice single answer"""
      options = step_data.get("options", [])
      must_correct = step_data.get("requireCorrect", False)  # ‚úÖ NEW

      # ‚úÖ NEW: Badge for must_correct
      must_correct_badge = ""
      if must_correct:
          must_correct_badge = "<span style='background:#fef3c7;color:#b45309;padding:4px 8px;border-radius:4px;font-size:12px;margin-left:8px;'>‚ö†Ô∏è Must be correct</span>"

      options_html = ""
      for opt in options:
          label = opt.get("label", "")
          content_blocks = opt.get("content", [])
          content_html = self.render_content_blocks(content_blocks)

          options_html += f"""
          <label class='mc-option' data-label='{label}'>
            <input type='radio' name='mc_single_{step_idx}' value='{label}'>
            <span>{label}. {content_html}</span>
          </label>
          """

      step_div.innerHTML = f"""
      <div style='font-weight:700;margin-bottom:8px;'>
          Step {step_idx+1} of {total_steps} {must_correct_badge}
      </div>
      <div class='step-description'>{desc_html}</div>
      <div style='margin-top:12px;'>
        <div style='font-weight:700;margin-bottom:8px;'>Select one answer:</div>
        {options_html}
        <button class='btn submit-step' style='margin-top:12px;'>Submit Answer</button>
        <button class='btn next-step' style='display:none;background:#10b981;'>Next Step ‚Üí</button>
      </div>
      <div class='step-feedback'></div>
      """

      # Add click handlers to options
      option_labels = step_div.querySelectorAll(".mc-option")
      for i in range(option_labels.length):
          option = option_labels[i]
          def make_option_handler(opt):
              def handler(e):
                  radio = opt.querySelector("input[type='radio']")
                  if radio:
                      radio.checked = True
                  all_opts = step_div.querySelectorAll(".mc-option")
                  for j in range(all_opts.length):
                      all_opts[j].classList.remove("selected")
                  opt.classList.add("selected")
              return handler
          option.addEventListener("click", create_proxy(make_option_handler(option)))

      # Submit button
      submit_btn = step_div.querySelector(".submit-step")
      if submit_btn:
          def submit_handler(e):
              self.submit_mc_single(step_idx, step_data)
          submit_btn.addEventListener("click", create_proxy(submit_handler))

      # Next button
      next_btn = step_div.querySelector(".next-step")
      if next_btn:
          def next_handler(e):
              self.next_step(step_idx)
          next_btn.addEventListener("click", create_proxy(next_handler))
    
    def create_mc_multiple_ui(self, step_div, step_idx, step_data, desc_html, total_steps):
      """Create UI for multiple choice multiple answers"""
      options = step_data.get("options", [])
      must_correct = step_data.get("requireCorrect", False)  # ‚úÖ NEW

      # ‚úÖ NEW: Badge for must_correct
      must_correct_badge = ""
      if must_correct:
          must_correct_badge = "<span style='background:#fef3c7;color:#b45309;padding:4px 8px;border-radius:4px;font-size:12px;margin-left:8px;'>‚ö†Ô∏è Must be correct</span>"

      options_html = ""
      for opt in options:
          label = opt.get("label", "")
          content_blocks = opt.get("content", [])
          content_html = self.render_content_blocks(content_blocks)

          options_html += f"""
          <label class='mc-option' data-label='{label}'>
            <input type='checkbox' name='mc_multiple_{step_idx}' value='{label}'>
            <span>{label}. {content_html}</span>
          </label>
          """

      step_div.innerHTML = f"""
      <div style='font-weight:700;margin-bottom:8px;'>
          Step {step_idx+1} of {total_steps} {must_correct_badge}
      </div>
      <div class='step-description'>{desc_html}</div>
      <div style='margin-top:12px;'>
        <div style='font-weight:700;margin-bottom:8px;'>Select all correct answers:</div>
        {options_html}
        <button class='btn submit-step' style='margin-top:12px;'>Submit Answer</button>
        <button class='btn next-step' style='display:none;background:#10b981;'>Next Step ‚Üí</button>
      </div>
      <div class='step-feedback'></div>
      """

      # Add click handlers
      option_labels = step_div.querySelectorAll(".mc-option")
      for i in range(option_labels.length):
          option = option_labels[i]
          def make_option_handler(opt):
              def handler(e):
                  checkbox = opt.querySelector("input[type='checkbox']")
                  if e.target.tagName.upper() != "INPUT":
                      if checkbox:
                          checkbox.checked = not checkbox.checked
                  if checkbox and checkbox.checked:
                      opt.classList.add("selected")
                  else:
                      opt.classList.remove("selected")
              return handler
          option.addEventListener("click", create_proxy(make_option_handler(option)))

      submit_btn = step_div.querySelector(".submit-step")
      if submit_btn:
          def submit_handler(e):
              self.submit_mc_multiple(step_idx, step_data)
          submit_btn.addEventListener("click", create_proxy(submit_handler))

      next_btn = step_div.querySelector(".next-step")
      if next_btn:
          def next_handler(e):
              self.next_step(step_idx)
          next_btn.addEventListener("click", create_proxy(next_handler))
    
    def create_truefalse_ui(self, step_div, step_idx, step_data, desc_html, total_steps):
      """Create true/false UI"""

      window.console.log(f"üîß Creating True/False UI for step {step_idx}")

      html = f"""
          <div class='step-header'>
              <div style='font-weight:700;font-size:18px;margin-bottom:12px;'>Step {step_idx + 1} of {total_steps}</div>
          </div>

          <div class='step-description'>
              {desc_html}
          </div>

          <div class='tf-options' style='margin:20px 0;'>
              <label style='display:block;padding:12px;border:2px solid #cbd5e1;border-radius:8px;margin-bottom:12px;cursor:pointer;'>
                  <input type='radio' name='tf_{step_idx}' value='true' style='margin-right:8px;'>
                  <span style='font-size:16px;'>True</span>
              </label>
              <label style='display:block;padding:12px;border:2px solid #cbd5e1;border-radius:8px;cursor:pointer;'>
                  <input type='radio' name='tf_{step_idx}' value='false' style='margin-right:8px;'>
                  <span style='font-size:16px;'>False</span>
              </label>
          </div>

          <div style='margin-top:20px;'>
              <button id='submitBtn{step_idx}' class='btn-primary' style='padding:10px 24px;'>
                  Submit Answer
              </button>
          </div>

          <div id='stepFeedback{step_idx}'></div>
      """

      step_div.innerHTML = html
      window.console.log(f"üìù HTML set for step {step_idx}")

      # ‚úÖ CRITICAL: Attach handler IMMEDIATELY (no setTimeout)
      submit_btn = step_div.querySelector(f"#submitBtn{step_idx}")

      if submit_btn:
          window.console.log(f"üîç Found button immediately after innerHTML")

          def submit_handler(event):
              window.console.log(f"üîò True/False submit button clicked for step {step_idx}")
              try:
                  self.submit_true_false(step_idx, step_data)
                  window.console.log("‚úÖ submit_true_false completed")
              except Exception as e:
                  window.console.error(f"‚ùå Error: {e}")
                  import traceback
                  window.console.error(traceback.format_exc())

          submit_btn.onclick = create_proxy(submit_handler)
          window.console.log(f"‚úÖ Handler attached, onclick={submit_btn.onclick}")

          # Verify it stuck
          if submit_btn.onclick:
              window.console.log(f"‚úÖ‚úÖ VERIFIED: Handler is attached!")
          else:
              window.console.error(f"‚ùå‚ùå FAILED: Handler didn't stick!")
      else:
          window.console.error(f"‚ùå Button not found immediately after innerHTML")

      window.console.log(f"‚úÖ True/False UI complete for step {step_idx}")
    
    def create_fillblank_ui(self, step_div, step_idx, step_data, desc_html, total_steps):
      """Create fill-in-the-blank UI with robust blank detection"""

      window.console.log(f"üîß Creating Fill-blank UI for step {step_idx}")

      try:
          # ‚úÖ Import html module at the top
          import html as html_module

          must_correct = step_data.get("requireCorrect", False)
          must_correct_badge = ""
          if must_correct:
              must_correct_badge = "<span style='background:#fef3c7;color:#b45309;padding:4px 8px;border-radius:4px;font-size:12px;margin-left:8px;'>‚ö†Ô∏è Must be correct</span>"

          # ========================================
          # ROBUST BLANK DETECTION
          # ========================================

          # Try multiple blank representations
          blank_patterns = [
              "___",           # Triple underscore
              "__",            # Double underscore
              "_",             # Single underscore
              "{{blank}}",     # Template-style
              "[blank]",       # Bracket-style
              "______",        # Many underscores
          ]

          # Get question text from multiple possible sources
          text_with_blanks = (
              step_data.get("text", "") or 
              step_data.get("question", "") or
              desc_html
          )

          window.console.log(f"Fill-blank text: {text_with_blanks}")

          # Detect which blank pattern is used (if any)
          detected_pattern = None
          blank_count = 0

          for pattern in blank_patterns:
              count = text_with_blanks.count(pattern)
              if count > 0:
                  detected_pattern = pattern
                  blank_count = count
                  window.console.log(f"‚úÖ Detected blank pattern: '{pattern}' ({count} instance(s))")
                  break

          # ========================================
          # BUILD HTML CONTENT
          # ========================================

          if detected_pattern and blank_count > 0:
              window.console.log(f"üìù Using inline blank mode with pattern: {detected_pattern}")

              html_content = f"""
                  <div class='step-header'>
                      <div style='font-weight:700;font-size:18px;margin-bottom:12px;'>
                          Step {step_idx + 1} of {total_steps} {must_correct_badge}
                      </div>
                  </div>

                  <div class='step-description'>
                      {desc_html}
                  </div>

                  <div class='fill-blank-container' style='margin:20px 0;'>
                      <div style='font-size:16px;line-height:2;'>
              """

              # Split by detected pattern and create inline inputs
              parts = text_with_blanks.split(detected_pattern)

              for i, part in enumerate(parts):
                  if part:
                      html_content += f"<span>{html_module.escape(part)}</span>"

                  if i < len(parts) - 1:
                      input_id = f"fillBlankInput{step_idx}_{i}" if blank_count > 1 else f"fillBlankInput{step_idx}"
                      html_content += f"""
                          <input 
                              type='text' 
                              id='{input_id}'
                              class='fill-blank-input'
                              data-blank-index='{i}'
                              style='display:inline-block;min-width:120px;max-width:200px;padding:6px 12px;
                                     border:2px solid #cbd5e1;border-radius:6px;font-size:16px;
                                     margin:0 4px;vertical-align:middle;'
                              placeholder='Your answer'
                          />
                      """

              html_content += """
                      </div>
                  </div>
              """

          else:
              window.console.log(f"üìù Using separate input mode (no blank pattern detected)")

              escaped_text = html_module.escape(text_with_blanks) if text_with_blanks else "Enter your answer below:"

              html_content = f"""
                  <div class='step-header'>
                      <div style='font-weight:700;font-size:18px;margin-bottom:12px;'>
                          Step {step_idx + 1} of {total_steps} {must_correct_badge}
                      </div>
                  </div>

                  <div class='step-description'>
                      {desc_html}
                  </div>

                  <div class='fill-blank-separate-container' style='margin:20px 0;'>
                      <div style='font-size:16px;margin-bottom:12px;color:#475569;'>
                          {escaped_text}
                      </div>

                      <div style='margin-top:12px;'>
                          <label style='display:block;font-weight:600;margin-bottom:8px;color:#334155;'>
                              Your Answer:
                          </label>
                          <input 
                              type='text' 
                              id='fillBlankInput{step_idx}'
                              class='fill-blank-input'
                              data-blank-index='0'
                              style='width:100%;max-width:500px;padding:12px;
                                     border:2px solid #cbd5e1;border-radius:8px;font-size:16px;'
                              placeholder='Type your answer here'
                          />
                      </div>
                  </div>
              """

          # Add common elements
          html_content += f"""
              <div style='margin-top:20px;'>
                  <button id='submitBtn{step_idx}' class='btn-primary' style='padding:10px 24px;'>
                      Submit Answer
                  </button>
              </div>

              <div id='stepFeedback{step_idx}'></div>
          """

          # ‚úÖ Set innerHTML
          step_div.innerHTML = html_content
          window.console.log(f"üìù HTML set for step {step_idx}")

          # ‚úÖ CRITICAL: Add explicit check to see if we reach this point
          window.console.log(f"üîç About to search for submit button for step {step_idx}")

          # ‚úÖ Query for submit button
          submit_btn = step_div.querySelector(f"#submitBtn{step_idx}")

          if submit_btn:
              window.console.log(f"‚úÖ Found submit button for step {step_idx}")

              def submit_handler(event):
                  window.console.log(f"üîò Fill-blank submit button clicked for step {step_idx}")
                  try:
                      self.submit_fill_blank(step_idx, step_data)
                      window.console.log("‚úÖ submit_fill_blank completed")
                  except Exception as e:
                      window.console.error(f"‚ùå Error in submit_fill_blank: {e}")
                      import traceback
                      window.console.error(traceback.format_exc())

              submit_btn.addEventListener("click", create_proxy(submit_handler))
              window.console.log(f"‚úÖ Handler attached for step {step_idx}")
              window.console.log(f"‚úÖ‚úÖ VERIFIED: Handler is attached for step {step_idx}!")
          else:
              window.console.error(f"‚ùå Submit button NOT FOUND for step {step_idx}")
              # Try alternative query
              all_buttons = step_div.querySelectorAll("button")
              window.console.log(f"   Found {all_buttons.length} button(s) in step_div")
              for i in range(all_buttons.length):
                  btn = all_buttons[i]
                  window.console.log(f"   Button {i}: id='{btn.id}', text='{btn.textContent}'")

          window.console.log(f"‚úÖ Fill-blank UI creation complete for step {step_idx}")

      except Exception as e:
          window.console.error(f"‚ùå CRITICAL ERROR in create_fillblank_ui for step {step_idx}: {e}")
          import traceback
          window.console.error(traceback.format_exc()) 
          
    def finalize_math_expression(self, step_idx):
      """Handle finalization for math expression problems - checks structure"""
      window.console.log(f"üîç Finalize step: problem {self.current_problem_index}, step {step_idx}")

      if step_idx >= len(self.solve_state):
          window.console.error(f"‚ùå Invalid state")
          window.alert("Error: Invalid step state. Please reload the problem.")
          return

      step = self.solve_state[step_idx]
      step_data = step.get("step_data") or step.get("step", {})
      container = step["container"]

      if not step.get("correct"):
          self.show_feedback(step_idx, "‚ùå Submit correct answer first", "#b91c1c")
          return

      # Get stored parsed expressions from submit
      parsed_user = step.get("parsed_user_answer")
      parsed_expected = step.get("parsed_expected_answer")

      if parsed_user is None or parsed_expected is None:
          self.show_feedback(step_idx, "‚ö†Ô∏è Could not validate structure. Finalized (no structure check).", "#92400e")
          self._finalize_step_ui(step_idx)
          return

      # Get expected structure from step data
      expected_struct = step_data.get("expected_structure")

      if not expected_struct:
          window.console.warn("‚ö†Ô∏è No expected_structure, finalizing without structure check")
          self._finalize_step_ui(step_idx)
          return

      # Extract user structure from parsed expression
      try:
          user_struct = self.math_parser.extract_structure(parsed_user)

          window.console.log("=" * 60)
          window.console.log("üìä STRUCTURE COMPARISON")
          window.console.log("=" * 60)
          window.console.log(f"Expected structure:")
          window.console.log(f"  Operators: {expected_struct.get('operators', {})}")
          window.console.log(f"  Operands: {expected_struct.get('operands', {})}")
          window.console.log(f"  Matrix ops: {expected_struct.get('matrix_ops', [])}")
          window.console.log(f"User structure:")
          window.console.log(f"  Operators: {user_struct.get('operators', {})}")
          window.console.log(f"  Operands: {user_struct.get('operands', {})}")
          window.console.log(f"  Matrix ops: {user_struct.get('matrix_ops', [])}")
          window.console.log("=" * 60)

      except Exception as e:
          window.console.error(f"‚ùå Structure extraction error: {e}")
          import traceback
          window.console.error(traceback.format_exc())

          self.show_feedback(step_idx, "‚ö†Ô∏è Error analyzing structure. Finalized (no structure check).", "#92400e")
          self._finalize_step_ui(step_idx)
          return

      # Track finalize attempts
      if not step.get("finalize_attempts"):
          step["finalize_attempts"] = 0
      step["finalize_attempts"] += 1

      # Compare structures
      same_operators = user_struct.get("operators", {}) == expected_struct.get("operators", {})
      same_operands = user_struct.get("operands", {}) == expected_struct.get("operands", {})
      same_matrix_ops = user_struct.get("matrix_ops", []) == expected_struct.get("matrix_ops", [])

      same_structure = same_operators and same_operands and same_matrix_ops

      window.console.log(f"  Operators match: {same_operators}")
      window.console.log(f"  Operands match: {same_operands}")
      window.console.log(f"  Matrix ops match: {same_matrix_ops}")
      window.console.log(f"üéØ Structure match result: {same_structure}")

      if same_structure:
          # ‚úÖ SUCCESS - finalize and proceed
          window.console.log("‚úÖ STRUCTURE MATCH - Finalizing step")

          step["structure_correct"] = True

          # ‚úÖ CRITICAL: Update problem_states
          current_prob_idx = self.current_problem_index
          if current_prob_idx is not None and current_prob_idx in self.problem_states:
              if step_idx < len(self.problem_states[current_prob_idx]):
                  self.problem_states[current_prob_idx][step_idx]["structure_correct"] = True
                  window.console.log(f"‚úÖ Updated problem_states: structure_correct=True")

          self.show_feedback(step_idx, "‚úÖ Finalized ‚Äî your solution method matches perfectly!", "#059669")

          # Disable buttons
          finalize_btn = container.querySelector(".finalize-step")
          if finalize_btn:
              finalize_btn.disabled = True
              finalize_btn.style.opacity = "0.5"

          submit_btn = container.querySelector(".submit-step")
          if submit_btn:
              submit_btn.disabled = True
              submit_btn.style.opacity = "0.5"

          # Show next button
          next_btn = container.querySelector(".next-step")
          if next_btn:
              next_btn.style.display = "block"

          # ‚úÖ Add to global history
          user_latex = step.get("last_correct_latex", "")
          self.add_to_global_history(step_idx, user_latex, True, 0, "finalize")

          # ‚úÖ Mark step as finished (this will update problem_states and check completion)
          self._mark_step_finished(step_idx)

      else:
          # ‚ùå FAILED - keep trying
          window.console.log("‚ùå STRUCTURE MISMATCH - Not finalizing")

          step["finished"] = False
          step["structure_correct"] = False

          # ‚úÖ CRITICAL: Update problem_states too
          current_prob_idx = self.current_problem_index
          if current_prob_idx is not None and current_prob_idx in self.problem_states:
              if step_idx < len(self.problem_states[current_prob_idx]):
                  self.problem_states[current_prob_idx][step_idx]["finished"] = False
                  self.problem_states[current_prob_idx][step_idx]["structure_correct"] = False
                  window.console.log(f"‚úÖ Updated problem_states: structure_correct=False")

          # Build detailed feedback
          msg_parts = [f"‚ùå Attempt {step['finalize_attempts']}: Structure mismatch.<br><br>"]

          if not same_operators and not same_operands:
              msg_parts.append(
                  "<strong>Both operations and values differ.</strong><br>"
                  f"<small>Expected: ops={expected_struct.get('operators', {})}, vals={expected_struct.get('operands', {})}</small><br>"
                  f"<small>Yours: ops={user_struct.get('operators', {})}, vals={user_struct.get('operands', {})}</small><br><br>"
              )
          elif not same_operators:
              msg_parts.append(
                  "<strong>Same values, different method.</strong><br>"
                  f"<small>Expected operators: {expected_struct.get('operators', {})}</small><br>"
                  f"<small>Your operators: {user_struct.get('operators', {})}</small><br><br>"
              )
          elif not same_operands:
              msg_parts.append(
                  "<strong>Correct operations, different values.</strong><br>"
                  f"<small>Expected values: {expected_struct.get('operands', {})}</small><br>"
                  f"<small>Your values: {user_struct.get('operands', {})}</small><br><br>"
              )

          if not same_matrix_ops:
              msg_parts.append(
                  "<strong>üî¢ Matrix operations differ:</strong><br>"
                  f"<small>Expected: {expected_struct.get('matrix_ops', [])}</small><br>"
                  f"<small>Yours: {user_struct.get('matrix_ops', [])}</small><br><br>"
              )

          msg_parts.append("<strong>üí° Try a different approach and click Finalize again.</strong>")
          msg = "".join(msg_parts)

          self.show_feedback(step_idx, msg, "#dc2626")

          # ‚úÖ Add failed finalize to global history
          user_latex = step.get("last_correct_latex", "")
          self.add_to_global_history(step_idx, user_latex, False, 0, "finalize")

          finalize_btn = container.querySelector(".finalize-step")
          if finalize_btn:
              finalize_btn.disabled = True
              finalize_btn.style.opacity = "0.5"

          # Enable submit button again
          submit_btn = container.querySelector(".submit-step")
          if submit_btn:
              submit_btn.disabled = False
              submit_btn.style.opacity = "1"

          # Save state (but don't mark as finished)
          self.save_to_storage()

    def _mark_step_finished(self, step_idx):
      """Mark a step as finished and trigger all related updates"""
      current_prob_idx = self.current_problem_index

      if current_prob_idx is None:
          window.console.error("‚ùå No current problem index")
          return

      # ‚úÖ Update solve_state (UI state)
      if step_idx >= len(self.solve_state):
          window.console.error(f"‚ùå Invalid step_idx: {step_idx}")
          return

      step = self.solve_state[step_idx]
      step["finished"] = True

      # ‚úÖ CRITICAL: Update problem_states (persisted state)
      if current_prob_idx in self.problem_states and step_idx < len(self.problem_states[current_prob_idx]):
          self.problem_states[current_prob_idx][step_idx]["finished"] = True
          self.problem_states[current_prob_idx][step_idx]["correct"] = step.get("correct", False)
          self.problem_states[current_prob_idx][step_idx]["user_answers"] = step.get("user_answers", [])
          self.problem_states[current_prob_idx][step_idx]["structure_correct"] = step.get("structure_correct", False)
          window.console.log(f"‚úÖ Updated problem_states for problem {current_prob_idx}, step {step_idx}")

      # Debug: Log all step statuses
      window.console.log("=" * 50)
      window.console.log(f"‚úÖ Step {step_idx} marked as finished")
      window.console.log(f"Current solve_state status:")
      for i, s in enumerate(self.solve_state):
          status = "‚úÖ DONE" if s.get("finished", False) else "‚è≥ TODO"
          window.console.log(f"  Step {i}: {status}")
      window.console.log("=" * 50)

      # IMPORTANT: Save to storage FIRST so problem_states is persisted
      self.save_to_storage()

      # Then update UI
      if current_prob_idx is not None:
          self.update_problem_progress(current_prob_idx)

      # ‚úÖ NEW: Check if this problem is now complete and handle accordingly
      self._check_problem_completion_and_show_next_step(step_idx)
      
    def update_problem_progress(self, problem_idx):
      """Update the progress summary in the problem accordion header"""
      if problem_idx >= len(self.problem_set):
          return

      # Get the problem
      problem = self.problem_set[problem_idx]
      title = problem.get("title", f"Problem {problem_idx+1}")
      steps = problem.get("steps", [])
      total = len(steps)

      # Count finished steps
      if problem_idx == self.current_problem_index and hasattr(self, 'solve_state'):
          # Use current solve_state
          finished = sum(1 for s in self.solve_state if s.get("finished", False))
          window.console.log(f"üìä Counting from solve_state: {finished}/{total}")
      elif problem_idx in self.problem_states:
          # Use saved state
          finished = sum(1 for s in self.problem_states[problem_idx] if s.get("finished", False))
          window.console.log(f"üìä Counting from problem_states: {finished}/{total}")
      else:
          finished = 0
          window.console.log(f"üìä No state found, defaulting to 0/{total}")

      window.console.log(f"üìä Problem {problem_idx} progress: {finished}/{total} steps finished")

      # Update the UI
      accordion = document.querySelector(f".accordion-problem[data-index='{problem_idx}']")
      if not accordion:
          window.console.error(f"‚ùå Accordion not found for problem {problem_idx}")
          return

      header = accordion.querySelector(".accordion-header")
      if not header:
          window.console.error(f"‚ùå Header not found for problem {problem_idx}")
          return

      is_done = finished == total and total > 0

      if is_done:
          # ‚úÖ Problem completed - show non-math count immediately

          # Count must-not-be-correct questions (where must_correct is False)
          non_math_count = 0
          for step in steps:
              if step.get("requireCorrect") == False:
                  non_math_count += 1

          window.console.log(f"Problem {problem_idx} completed with {non_math_count} non-math questions")

          # Build completion message with non-math count
          if non_math_count > 0:
              header.innerHTML = f"""
              <span>{problem_idx+1}. {html.escape(title)}</span>
              <span class='progress-summary' style='color:#059669;display:flex;align-items:center;gap:8px;'>
                  <span style='font-size:20px;'>üéâ</span>
                  <span style='font-weight:700;'>Completed! (non-math: {non_math_count})</span>
              </span>
              """
          else:
              header.innerHTML = f"""
              <span>{problem_idx+1}. {html.escape(title)}</span>
              <span class='progress-summary' style='color:#059669;display:flex;align-items:center;gap:8px;'>
                  <span style='font-size:20px;'>üéâ</span>
                  <span style='font-weight:700;'>Completed!</span>
              </span>
              """

          header.style.background = "#f0fdf4"
          accordion.classList.add("finished")

          window.console.log(f"‚úÖ Problem {problem_idx} marked as completed (non-math: {non_math_count})")
      else:
          # ‚úÖ Problem incomplete - show progress
          progress_color = "#6b7280"

          header.innerHTML = f"""
          <span>{problem_idx+1}. {html.escape(title)}</span>
          <span class='progress-summary' style='color:{progress_color}'>‚úÖ {finished}/{total} completed</span>
          """

          header.style.background = "#f0f4ff"
          accordion.classList.remove("finished")

          window.console.log(f"‚úÖ Updated progress display to: {finished}/{total}")
    
    def finalize_step(self, step_idx):
        """Finalize a step - marks it as finished and saves to storage"""
        window.console.log(f"üîç Finalize step: problem {self.current_problem_index}, step {step_idx}")

        # Get current problem index
        current_prob_idx = self.current_problem_index
        if current_prob_idx is None:
            window.console.error("‚ùå No current problem index")
            return

        # ‚úÖ CRITICAL: Mark step as finished in problem_states FIRST
        if current_prob_idx in self.problem_states:
            if step_idx < len(self.problem_states[current_prob_idx]):
                self.problem_states[current_prob_idx][step_idx]["finished"] = True
                window.console.log(f"‚úÖ Step {step_idx} marked as finished in problem_states")

        # ‚úÖ Mark step as finished in solve_state
        if current_prob_idx in self.solve_states:
            solve_state = self.solve_states[current_prob_idx]
            if step_idx < len(solve_state):
                solve_state[step_idx]["finished"] = True
                window.console.log(f"‚úÖ Step {step_idx} marked as finished in solve_state")

        # ‚úÖ CRITICAL: Save to storage IMMEDIATELY
        self.save_to_storage()
        window.console.log("üíæ Completion saved to storage")

        # Update progress display
        self.update_problem_progress(current_prob_idx)

        # Hide finalize button
        finalize_btn = document.querySelector(f"#finalizeBtn{step_idx}")
        if finalize_btn:
            finalize_btn.style.display = "none"

        # Show finalized message
        feedback_div = document.querySelector(f"#stepFeedback{step_idx}")
        if feedback_div:
            feedback_div.innerHTML = """
                <div style='background:#dbeafe;color:#1e40af;padding:16px;border-radius:8px;text-align:center;margin-top:12px;'>
                    <div style='font-size:20px;margin-bottom:8px;'>üîí</div>
                    <div style='font-weight:700;margin-bottom:4px;'>Step Finalized!</div>
                    <div style='font-size:14px;'>Your answer has been locked in.</div>
                </div>
            """

        # ‚úÖ Check completion status
        window.console.log("üîç Checking completion status...")

        # Count finished steps
        finished_count = self.count_finished_steps(current_prob_idx)
        total_steps = len(self.problem_states[current_prob_idx])

        window.console.log(f"Problem {current_prob_idx}: {finished_count}/{total_steps} steps finished")

        if finished_count >= total_steps:
            # This problem is complete!
            window.console.log(f"‚úÖ Problem {current_prob_idx} is now complete!")

            # ‚úÖ Save again to ensure completion is recorded
            self.save_to_storage()

            # Show completion banner
            self.show_problem_completion_banner(current_prob_idx)

            # ‚úÖ Check if ALL problems are complete
            if self._all_problems_complete():
                window.console.log("üéâ ALL PROBLEMS COMPLETE! Showing review...")

                # Small delay to let user see the completion message
                def show_review_delayed():
                    self.show_review_section()

                window.setTimeout(create_proxy(show_review_delayed), 1500)
            else:
                # Show which problems remain
                remaining = []
                for prob_idx in self.problem_states.keys():
                    if not self.is_problem_complete(prob_idx):
                        remaining.append(prob_idx + 1)

                window.console.log(f"Problems remaining: {remaining}")
        else:
            # Continue to next step in this problem
            window.console.log(f"Problem {current_prob_idx} not complete yet, continuing...")

            # Find and show next unfinished step
            next_step_idx = None
            for i, step_data in enumerate(self.problem_states[current_prob_idx]):
                if not step_data.get("finished", False):
                    next_step_idx = i
                    break

            if next_step_idx is not None:
                # Hide all steps
                if current_prob_idx in self.solve_states:
                    for step in self.solve_states[current_prob_idx]:
                        if step.get("container"):
                            step["container"].style.display = "none"

                # Show next step
                if current_prob_idx in self.solve_states and next_step_idx < len(self.solve_states[current_prob_idx]):
                    next_container = self.solve_states[current_prob_idx][next_step_idx].get("container")
                    if next_container:
                        next_container.style.display = "block"
                        next_container.scrollIntoView({'behavior': 'smooth', 'block': 'center'})
                        window.console.log(f"‚úÖ Showing next step: {next_step_idx}")

                      
    def show_problem_completion_banner(self, prob_idx):
        """Show a banner when a problem is completed"""
        # Find the problem body
        problem_body = document.querySelector(f"#problemBody{prob_idx}")
        if not problem_body:
            return

        # Remove any existing banner
        existing_banner = document.querySelector(f"#completionBanner_{prob_idx}")
        if existing_banner:
            existing_banner.remove()

        # Create completion banner
        banner = document.createElement("div")
        banner.id = f"completionBanner_{prob_idx}"
        banner.style.cssText = """
            background: linear-gradient(135deg, #10b981, #059669);
            color: white;
            padding: 20px;
            border-radius: 12px;
            margin: 20px 0;
            text-align: center;
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
        """

        # Calculate this problem's score
        total_score, max_score, problem_scores = self.calculate_total_score()
        prob_score_info = problem_scores.get(prob_idx, {'score': 0, 'max_score': 0, 'percentage': 0})

        banner.innerHTML = f"""
            <div style="font-size: 32px; margin-bottom: 8px;">üéâ</div>
            <div style="font-size: 20px; font-weight: 700; margin-bottom: 8px;">
                Problem {prob_idx + 1} Complete!
            </div>
            <!--
            <div style="font-size: 16px; opacity: 0.9;">
                Score: {prob_score_info['percentage']:.1f}% ({prob_score_info['score']:.1f}/{prob_score_info['max_score']:.1f} points)
            </div>
            -->
        """

        # Insert at top of problem body
        if problem_body.firstChild:
            problem_body.insertBefore(banner, problem_body.firstChild)
        else:
            problem_body.appendChild(banner)

        window.console.log(f"‚úÖ Completion banner shown for problem {prob_idx}")
    
    def test_state_update(self):
      """Diagnostic: Test if problem_states updates work"""
      window.console.log("üß™ TESTING STATE UPDATE...")

      # Test updating problem 0, step 0
      if 0 in self.problem_states and len(self.problem_states[0]) > 0:
          window.console.log(f"Before: problem_states[0][0] = {self.problem_states[0][0]}")

          # Try to update
          self.problem_states[0][0]["finished"] = True
          self.problem_states[0][0]["correct"] = True

          window.console.log(f"After: problem_states[0][0] = {self.problem_states[0][0]}")

          # Try to save
          self.save_to_storage()

          window.console.log("üß™ Test complete - check if save shows 1/6 finished")
      else:
          window.console.log("‚ùå problem_states[0] doesn't exist")
    # ============================================
    # ALL SUBMIT METHODS - UNIFIED STATE MANAGEMENT
    # ============================================

    def submit_mc_single(self, step_idx, step_data):
        """Submit multiple choice single answer"""
        current_prob_idx = self.current_problem_index
        if current_prob_idx is None:
            window.console.error("‚ùå No current problem index")
            return

        # Get selected answer
        selected = document.querySelector(f"input[name='mc_single_{step_idx}']:checked")
        if not selected:
            window.console.warn("No answer selected")

            # Show warning
            feedback_div = document.querySelector(f"#stepFeedback{step_idx}")
            if feedback_div:
                feedback_div.innerHTML = """
                    <div style='background:#fef2f2;color:#dc2626;padding:12px;border-radius:8px;margin-top:12px;'>
                        ‚ö†Ô∏è Please select an answer
                    </div>
                """
            return

        user_answer = selected.value
        correct_answer = step_data.get("correct_answer", "")
        is_correct = (user_answer == correct_answer)
        must_correct = step_data.get("requireCorrect", False)

        window.console.log(f"MC Single: user={user_answer}, correct={correct_answer}, is_correct={is_correct}")

        # ‚úÖ CRITICAL: Update BOTH solve_state AND problem_states
        if current_prob_idx in self.solve_states and step_idx < len(self.solve_states[current_prob_idx]):
            self.solve_states[current_prob_idx][step_idx]["finished"] = True
            self.solve_states[current_prob_idx][step_idx]["correct"] = is_correct
            self.solve_states[current_prob_idx][step_idx]["user_answers"] = [user_answer]
            window.console.log(f"‚úÖ Updated solve_state: Step {step_idx}, finished=True")

        # ‚úÖ CRITICAL: Update problem_states (persisted state)
        if current_prob_idx in self.problem_states and step_idx < len(self.problem_states[current_prob_idx]):
            self.problem_states[current_prob_idx][step_idx]["finished"] = True
            self.problem_states[current_prob_idx][step_idx]["correct"] = is_correct
            self.problem_states[current_prob_idx][step_idx]["user_answers"] = [user_answer]
            attempts = self.problem_states[current_prob_idx][step_idx].get("attempts", 0)
            self.problem_states[current_prob_idx][step_idx]["attempts"] = attempts + 1
            window.console.log(f"‚úÖ Updated problem_states: Problem {current_prob_idx}, Step {step_idx}, finished=True, correct={is_correct}")

        # Mark step as finished
        window.console.log("==================================================")
        window.console.log(f"‚úÖ Step {step_idx} marked as finished")
        window.console.log("Current solve_state status:")
        for i, step in enumerate(self.solve_states[current_prob_idx]):
            status = "‚úÖ DONE" if step.get("finished") else "‚è≥ TODO"
            window.console.log(f"  Step {i}: {status}")
        window.console.log("==================================================")

        # Show feedback
        feedback_div = document.querySelector(f"#stepFeedback{step_idx}")
        if feedback_div:
            if is_correct:
                feedback_div.innerHTML = """
                    <div style='background:#dcfce7;color:#16a34a;padding:12px;border-radius:8px;margin-top:12px;font-weight:600;'>
                        ‚úÖ Correct!
                    </div>
                """
            else:
                if must_correct:
                    feedback_div.innerHTML = """
                        <div style='background:#fef2f2;color:#dc2626;padding:12px;border-radius:8px;margin-top:12px;'>
                            ‚ùå Incorrect. This step requires the correct answer. Please try again.
                        </div>
                    """
                    # Reset finished status if must be correct
                    if current_prob_idx in self.solve_states and step_idx < len(self.solve_states[current_prob_idx]):
                        self.solve_states[current_prob_idx][step_idx]["finished"] = False
                    if current_prob_idx in self.problem_states and step_idx < len(self.problem_states[current_prob_idx]):
                        self.problem_states[current_prob_idx][step_idx]["finished"] = False
                    self.save_to_storage()
                    return
                else:
                    feedback_div.innerHTML = f"""
                        <div style='background:#fef2f2;color:#dc2626;padding:12px;border-radius:8px;margin-top:12px;'>
                            ‚ùå Incorrect. The correct answer was: {correct_answer}
                        </div>
                    """

        # Save and check completion
        self.save_to_storage()
        self._check_problem_completion_and_show_next_step(step_idx)


    def submit_mc_multiple(self, step_idx, step_data):
        """Submit multiple choice multiple answers"""
        current_prob_idx = self.current_problem_index
        if current_prob_idx is None:
            window.console.error("‚ùå No current problem index")
            return

        # Get all selected answers
        checkboxes = document.querySelectorAll(f"input[name='mc_multiple_{step_idx}']:checked")
        user_answers = set()
        for i in range(checkboxes.length):
            user_answers.add(checkboxes[i].value)

        if len(user_answers) == 0:
            window.console.warn("No answers selected")

            # Show warning
            feedback_div = document.querySelector(f"#stepFeedback{step_idx}")
            if feedback_div:
                feedback_div.innerHTML = """
                    <div style='background:#fef2f2;color:#dc2626;padding:12px;border-radius:8px;margin-top:12px;'>
                        ‚ö†Ô∏è Please select at least one answer
                    </div>
                """
            return

        correct_answers = set(step_data.get("correct_answers", []))
        is_correct = (user_answers == correct_answers)
        must_correct = step_data.get("requireCorrect", False)

        window.console.log(f"MC Multiple: user={user_answers}, correct={correct_answers}, is_correct={is_correct}")

        # ‚úÖ CRITICAL: Update BOTH solve_state AND problem_states
        if current_prob_idx in self.solve_states and step_idx < len(self.solve_states[current_prob_idx]):
            self.solve_states[current_prob_idx][step_idx]["finished"] = True
            self.solve_states[current_prob_idx][step_idx]["correct"] = is_correct
            self.solve_states[current_prob_idx][step_idx]["user_answers"] = list(user_answers)
            window.console.log(f"‚úÖ Updated solve_state: Step {step_idx}, finished=True")

        # ‚úÖ CRITICAL: Update problem_states (persisted state)
        if current_prob_idx in self.problem_states and step_idx < len(self.problem_states[current_prob_idx]):
            self.problem_states[current_prob_idx][step_idx]["finished"] = True
            self.problem_states[current_prob_idx][step_idx]["correct"] = is_correct
            self.problem_states[current_prob_idx][step_idx]["user_answers"] = list(user_answers)
            attempts = self.problem_states[current_prob_idx][step_idx].get("attempts", 0)
            self.problem_states[current_prob_idx][step_idx]["attempts"] = attempts + 1
            window.console.log(f"‚úÖ Updated problem_states: Problem {current_prob_idx}, Step {step_idx}, finished=True, correct={is_correct}")

        # Mark step as finished
        window.console.log("==================================================")
        window.console.log(f"‚úÖ Step {step_idx} marked as finished")
        window.console.log("Current solve_state status:")
        for i, step in enumerate(self.solve_states[current_prob_idx]):
            status = "‚úÖ DONE" if step.get("finished") else "‚è≥ TODO"
            window.console.log(f"  Step {i}: {status}")
        window.console.log("==================================================")

        # Show feedback
        feedback_div = document.querySelector(f"#stepFeedback{step_idx}")
        if feedback_div:
            if is_correct:
                feedback_div.innerHTML = """
                    <div style='background:#dcfce7;color:#16a34a;padding:12px;border-radius:8px;margin-top:12px;font-weight:600;'>
                        ‚úÖ Correct!
                    </div>
                """
            else:
                if must_correct:
                    feedback_div.innerHTML = """
                        <div style='background:#fef2f2;color:#dc2626;padding:12px;border-radius:8px;margin-top:12px;'>
                            ‚ùå Incorrect. This step requires the correct answer. Please try again.
                        </div>
                    """
                    # Reset finished status if must be correct
                    if current_prob_idx in self.solve_states and step_idx < len(self.solve_states[current_prob_idx]):
                        self.solve_states[current_prob_idx][step_idx]["finished"] = False
                    if current_prob_idx in self.problem_states and step_idx < len(self.problem_states[current_prob_idx]):
                        self.problem_states[current_prob_idx][step_idx]["finished"] = False
                    self.save_to_storage()
                    return
                else:
                    correct_list = ", ".join(sorted(correct_answers))
                    feedback_div.innerHTML = f"""
                        <div style='background:#fef2f2;color:#dc2626;padding:12px;border-radius:8px;margin-top:12px;'>
                            ‚ùå Incorrect. The correct answers were: {correct_list}
                        </div>
                    """

        # Save and check completion
        self.save_to_storage()
        self._check_problem_completion_and_show_next_step(step_idx)


    def submit_true_false(self, step_idx, step_data):
        """Submit true/false answer"""
        current_prob_idx = self.current_problem_index
        if current_prob_idx is None:
            window.console.error("‚ùå No current problem index")
            return

        # Get selected answer
        selected = document.querySelector(f"input[name='tf_{step_idx}']:checked")
        if not selected:
            window.console.warn("No answer selected")

            # Show warning
            feedback_div = document.querySelector(f"#stepFeedback{step_idx}")
            if feedback_div:
                feedback_div.innerHTML = """
                    <div style='background:#fef2f2;color:#dc2626;padding:12px;border-radius:8px;margin-top:12px;'>
                        ‚ö†Ô∏è Please select True or False
                    </div>
                """
            return

        user_answer = selected.value  # "true" or "false"
        correct_answer = str(step_data.get("correct_answer", "true")).lower()
        is_correct = (user_answer == correct_answer)
        must_correct = step_data.get("requireCorrect", False)

        window.console.log(f"True/False: user={user_answer}, correct={correct_answer}, is_correct={is_correct}")

        # ‚úÖ CRITICAL: Update BOTH solve_state AND problem_states
        if current_prob_idx in self.solve_states and step_idx < len(self.solve_states[current_prob_idx]):
            self.solve_states[current_prob_idx][step_idx]["finished"] = True
            self.solve_states[current_prob_idx][step_idx]["correct"] = is_correct
            self.solve_states[current_prob_idx][step_idx]["user_answers"] = [user_answer]
            window.console.log(f"‚úÖ Updated solve_state: Step {step_idx}, finished=True")

        # ‚úÖ CRITICAL: Update problem_states (persisted state)
        if current_prob_idx in self.problem_states and step_idx < len(self.problem_states[current_prob_idx]):
            self.problem_states[current_prob_idx][step_idx]["finished"] = True
            self.problem_states[current_prob_idx][step_idx]["correct"] = is_correct
            self.problem_states[current_prob_idx][step_idx]["user_answers"] = [user_answer]
            attempts = self.problem_states[current_prob_idx][step_idx].get("attempts", 0)
            self.problem_states[current_prob_idx][step_idx]["attempts"] = attempts + 1
            window.console.log(f"‚úÖ Updated problem_states: Problem {current_prob_idx}, Step {step_idx}, finished=True, correct={is_correct}")

        # Mark step as finished
        window.console.log("==================================================")
        window.console.log(f"‚úÖ Step {step_idx} marked as finished")
        window.console.log("Current solve_state status:")
        for i, step in enumerate(self.solve_states[current_prob_idx]):
            status = "‚úÖ DONE" if step.get("finished") else "‚è≥ TODO"
            window.console.log(f"  Step {i}: {status}")
        window.console.log("==================================================")

        # Show feedback
        feedback_div = document.querySelector(f"#stepFeedback{step_idx}")
        if feedback_div:
            if is_correct:
                feedback_div.innerHTML = """
                    <div style='background:#dcfce7;color:#16a34a;padding:12px;border-radius:8px;margin-top:12px;font-weight:600;'>
                        ‚úÖ Correct!
                    </div>
                """
            else:
                if must_correct:
                    feedback_div.innerHTML = """
                        <div style='background:#fef2f2;color:#dc2626;padding:12px;border-radius:8px;margin-top:12px;'>
                            ‚ùå Incorrect. This step requires the correct answer. Please try again.
                        </div>
                    """
                    # Reset finished status if must be correct
                    if current_prob_idx in self.solve_states and step_idx < len(self.solve_states[current_prob_idx]):
                        self.solve_states[current_prob_idx][step_idx]["finished"] = False
                    if current_prob_idx in self.problem_states and step_idx < len(self.problem_states[current_prob_idx]):
                        self.problem_states[current_prob_idx][step_idx]["finished"] = False
                    self.save_to_storage()
                    return
                else:
                    correct_display = "True" if correct_answer == "true" else "False"
                    feedback_div.innerHTML = f"""
                        <div style='background:#fef2f2;color:#dc2626;padding:12px;border-radius:8px;margin-top:12px;'>
                            ‚ùå Incorrect. The correct answer was: {correct_display}
                        </div>
                    """

        # Save and check completion
        self.save_to_storage()
        self._check_problem_completion_and_show_next_step(step_idx)


    def submit_fill_blank(self, step_idx, step_data):
        """Submit fill in the blank answer"""
        current_prob_idx = self.current_problem_index
        if current_prob_idx is None:
            window.console.error("‚ùå No current problem index")
            return

        # Get user input
        input_elem = document.querySelector(f"#fillBlankInput{step_idx}")
        if not input_elem:
            window.console.error(f"‚ùå Input element not found for step {step_idx}")
            return

        user_answer = input_elem.value.strip()
        if not user_answer:
            window.console.warn("No answer provided")

            # Show warning
            feedback_div = document.querySelector(f"#stepFeedback{step_idx}")
            if feedback_div:
                feedback_div.innerHTML = """
                    <div style='background:#fef2f2;color:#dc2626;padding:12px;border-radius:8px;margin-top:12px;'>
                        ‚ö†Ô∏è Please enter an answer
                    </div>
                """
            return

        # Check against accepted answers
        accepted_answers = step_data.get("accepted_answers", [])
        is_correct = False

        for accepted in accepted_answers:
            accepted_value = accepted.get("value", "").strip().lower()
            if user_answer.lower() == accepted_value:
                is_correct = True
                break

        must_correct = step_data.get("requireCorrect", False)

        window.console.log(f"Fill-blank check: '{user_answer}' against {accepted_answers} = {is_correct}")

        # ‚úÖ CRITICAL: Update BOTH solve_state AND problem_states
        if current_prob_idx in self.solve_states and step_idx < len(self.solve_states[current_prob_idx]):
            self.solve_states[current_prob_idx][step_idx]["finished"] = True
            self.solve_states[current_prob_idx][step_idx]["correct"] = is_correct
            self.solve_states[current_prob_idx][step_idx]["user_answers"] = [user_answer]
            window.console.log(f"‚úÖ Updated solve_state: Step {step_idx}, finished=True")

        # ‚úÖ CRITICAL: Update problem_states (persisted state)
        if current_prob_idx in self.problem_states and step_idx < len(self.problem_states[current_prob_idx]):
            self.problem_states[current_prob_idx][step_idx]["finished"] = True
            self.problem_states[current_prob_idx][step_idx]["correct"] = is_correct
            self.problem_states[current_prob_idx][step_idx]["user_answers"] = [user_answer]
            attempts = self.problem_states[current_prob_idx][step_idx].get("attempts", 0)
            self.problem_states[current_prob_idx][step_idx]["attempts"] = attempts + 1
            window.console.log(f"‚úÖ Updated problem_states: Problem {current_prob_idx}, Step {step_idx}, finished=True, correct={is_correct}")

        # Mark step as finished
        window.console.log("==================================================")
        window.console.log(f"‚úÖ Step {step_idx} marked as finished")
        window.console.log("Current solve_state status:")
        for i, step in enumerate(self.solve_states[current_prob_idx]):
            status = "‚úÖ DONE" if step.get("finished") else "‚è≥ TODO"
            window.console.log(f"  Step {i}: {status}")
        window.console.log("==================================================")

        # Show feedback
        feedback_div = document.querySelector(f"#stepFeedback{step_idx}")
        if feedback_div:
            if is_correct:
                feedback_div.innerHTML = """
                    <div style='background:#dcfce7;color:#16a34a;padding:12px;border-radius:8px;margin-top:12px;font-weight:600;'>
                        ‚úÖ Correct!
                    </div>
                """
            else:
                if must_correct:
                    feedback_div.innerHTML = """
                        <div style='background:#fef2f2;color:#dc2626;padding:12px;border-radius:8px;margin-top:12px;'>
                            ‚ùå Incorrect. This step requires the correct answer. Please try again.
                        </div>
                    """
                    # Reset finished status if must be correct
                    if current_prob_idx in self.solve_states and step_idx < len(self.solve_states[current_prob_idx]):
                        self.solve_states[current_prob_idx][step_idx]["finished"] = False
                    if current_prob_idx in self.problem_states and step_idx < len(self.problem_states[current_prob_idx]):
                        self.problem_states[current_prob_idx][step_idx]["finished"] = False
                    self.save_to_storage()
                    return
                else:
                    accepted_displays = ", ".join([a.get("display", a.get("value", "")) for a in accepted_answers])
                    feedback_div.innerHTML = f"""
                        <div style='background:#fef2f2;color:#dc2626;padding:12px;border-radius:8px;margin-top:12px;'>
                            ‚ùå Incorrect. Accepted answers: {accepted_displays}
                        </div>
                    """

        # Disable input
        input_elem.disabled = True

        # Save and check completion
        self.save_to_storage()
        self._check_problem_completion_and_show_next_step(step_idx)
    
    # ============================================
    # HELPER METHOD - Check completion after each step
    # ============================================

    def _check_problem_completion_and_show_next_step(self, step_idx):
      """Check if problem is complete and show next step or completion banner"""
      current_prob_idx = self.current_problem_index
      if current_prob_idx is None:
          return

      window.console.log("üîç Checking completion status...")

      # ‚úÖ Use your existing method
      problem_completed = self.check_problem_completion(current_prob_idx)

      if problem_completed:
          # This problem is complete!
          window.console.log(f"‚úÖ Problem {current_prob_idx} is now complete!")

          # Save to ensure completion is recorded
          self.save_to_storage()

          # Show completion banner (NO RELOAD!)
          self.show_problem_completion_banner(current_prob_idx)

          # ‚úÖ Use your existing method to check all problems
          all_completed = self.check_all_problems_completion()

          if all_completed:
              window.console.log("üéâ ALL PROBLEMS COMPLETE! Showing review...")

              # Small delay to let user see the completion message
              def show_review_delayed():
                  self.show_review_section()

              window.setTimeout(create_proxy(show_review_delayed), 1500)
          else:
              window.console.log("Some problems remain incomplete")
      else:
          # Problem not complete, show next step
          window.console.log(f"Problem {current_prob_idx} not complete yet")

          # Save progress
          self.save_to_storage()

          # Find and show next unfinished step
          next_step_idx = None
          if current_prob_idx in self.problem_states:
              for i, step_data in enumerate(self.problem_states[current_prob_idx]):
                  if not step_data.get("finished", False):
                      next_step_idx = i
                      break

          if next_step_idx is not None:
              window.console.log(f"üìç Next unfinished step: {next_step_idx}")

              # Hide all steps
              if current_prob_idx in self.solve_states:
                  for step in self.solve_states[current_prob_idx]:
                      if step.get("container"):
                          step["container"].style.display = "none"

              # Show next step
              if current_prob_idx in self.solve_states and next_step_idx < len(self.solve_states[current_prob_idx]):
                  next_container = self.solve_states[current_prob_idx][next_step_idx].get("container")
                  if next_container:
                      next_container.style.display = "block"
                      next_container.scrollIntoView({'behavior': 'smooth', 'block': 'center'})
                      window.console.log(f"‚úÖ Showing next step: {next_step_idx}")

                      # Render MathJax for next step
                      def render_mathjax(retry_count=0):
                          try:
                              if window.MathJax and window.MathJax.typesetPromise:
                                  window.MathJax.typesetPromise([next_container]).then(
                                      create_proxy(lambda: window.console.log("‚úÖ Step MathJax rendered"))
                                  ).catch(create_proxy(lambda e: window.console.error(f"MathJax error: {e}")))
                          except Exception as e:
                              window.console.error(f"Error rendering MathJax: {e}")

                      window.setTimeout(create_proxy(render_mathjax), 100)

    def show_problem_completion_banner(self, prob_idx):
        """Show a banner when a problem is completed"""
        # Find the problem body
        problem_body = document.querySelector(f"#problemBody{prob_idx}")
        if not problem_body:
            return

        # Remove any existing banner
        existing_banner = document.querySelector(f"#completionBanner_{prob_idx}")
        if existing_banner:
            existing_banner.remove()

        # Create completion banner
        banner = document.createElement("div")
        banner.id = f"completionBanner_{prob_idx}"
        banner.style.cssText = """
            background: linear-gradient(135deg, #10b981, #059669);
            color: white;
            padding: 20px;
            border-radius: 12px;
            margin: 20px 0;
            text-align: center;
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
            animation: slideIn 0.3s ease-out;
        """

        # Calculate this problem's score
        total_score, max_score, problem_scores = self.calculate_total_score()
        prob_score_info = problem_scores.get(prob_idx, {'score': 0, 'max_score': 0, 'percentage': 0})

        banner.innerHTML = f"""
            <div style="font-size: 32px; margin-bottom: 8px;">üéâ</div>
            <div style="font-size: 20px; font-weight: 700; margin-bottom: 8px;">
                Problem {prob_idx + 1} Complete!
            </div>
            <!--
            <div style="font-size: 16px; opacity: 0.9;">
                Score: {prob_score_info['percentage']:.1f}% ({prob_score_info['score']:.1f}/{prob_score_info['max_score']:.1f} points)
            </div>
            -->
        """

        # Insert at top of problem body
        if problem_body.firstChild:
            problem_body.insertBefore(banner, problem_body.firstChild)
        else:
            problem_body.appendChild(banner)

        window.console.log(f"‚úÖ Completion banner shown for problem {prob_idx}")
    
    def _finalize_step_ui(self, step_idx):
      """Helper method to update UI when step is finalized"""
      if step_idx >= len(self.solve_state):
          return

      step = self.solve_state[step_idx]
      container = step["container"]

      # Disable buttons
      finalize_btn = container.querySelector(".finalize-step")
      if finalize_btn:
          finalize_btn.disabled = True
          finalize_btn.style.opacity = "0.5"

      submit_btn = container.querySelector(".submit-step")
      if submit_btn:
          submit_btn.disabled = True
          submit_btn.style.opacity = "0.5"

      # Show next button
      next_btn = container.querySelector(".next-step")
      if next_btn:
          next_btn.style.display = "block"

      # ‚úÖ Mark step as finished (triggers progress update and completion check)
      self._mark_step_finished(step_idx)


    def check_problem_completion(self, problem_idx):
        """Check if all steps in a problem are completed correctly"""
        if problem_idx >= len(self.problem_set):
            return False

        problem = self.problem_set[problem_idx]
        steps = problem.get('steps', [])
        total_steps = len(steps)

        if total_steps == 0:
            return False

        # Check solve_state if this is the current problem
        if problem_idx == self.current_problem_index and hasattr(self, 'solve_state'):
            completed_count = sum(1 for step in self.solve_state if step.get("finished", False))
            window.console.log(f"Problem {problem_idx}: {completed_count}/{total_steps} steps finished")
            return completed_count == total_steps

        # Check saved state for other problems
        if problem_idx in self.problem_states:
            saved_state = self.problem_states[problem_idx]
            completed_count = sum(1 for step in saved_state if step.get("finished", False))
            window.console.log(f"Problem {problem_idx} (saved): {completed_count}/{total_steps} steps finished")
            return completed_count == total_steps

        return False

    def check_all_problems_completion(self):
        """Check if all problems are completed"""
        if not self.problem_set or len(self.problem_set) == 0:
            return False

        for i in range(len(self.problem_set)):
            if not self.check_problem_completion(i):
                window.console.log(f"Problem {i} not yet completed")
                return False

        window.console.log("üéâ All problems completed!")
        return True

    def show_problem_completion_message(self):
        """Show congratulations message for completing a problem"""
        if self.current_problem_index is None:
            return

        # Create or update congratulations section
        congrats_id = f"problemCongrats_{self.current_problem_index}"
        congrats_el = document.querySelector(f"#{congrats_id}")

        if congrats_el:
            # Already shown, don't duplicate
            return

        # Create new congratulations element
        congrats_el = document.createElement("div")
        congrats_el.id = congrats_id

        # Insert after the problem's global history
        global_history = document.querySelector(f"#globalHistory_{self.current_problem_index}")
        if global_history and global_history.parentNode:
            # Insert after global history
            if global_history.nextSibling:
                global_history.parentNode.insertBefore(congrats_el, global_history.nextSibling)
            else:
                global_history.parentNode.appendChild(congrats_el)

        problem_name = self.problem_set[self.current_problem_index].get('title', f'Problem {self.current_problem_index + 1}')

        congrats_el.innerHTML = f"""
        <div style='background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                    color: white;
                    padding: 24px;
                    border-radius: 12px;
                    margin: 16px 0;
                    text-align: center;
                    box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);'>
            <div style='font-size: 48px; margin-bottom: 12px;'>üéâ</div>
            <div style='font-size: 24px; font-weight: 700; margin-bottom: 8px;'>
                Congratulations!
            </div>
            <div style='font-size: 16px; opacity: 0.95;'>
                You've completed all steps for {html.escape(problem_name)}!
            </div>
        </div>
        """

        # Scroll to show the message
        congrats_el.scrollIntoView({'behavior': 'smooth', 'block': 'center'})

        window.console.log(f"‚úÖ Displayed problem completion message for problem {self.current_problem_index}")

    def show_all_problems_completion_message(self):
      """Show congratulations message for completing all problems with total score"""
      window.console.log("üéâ show_all_problems_completion_message called!")

      # Remove existing message first (in case of reload)
      existing = document.querySelector("#allProblemsComplete")
      if existing:
          existing.remove()
          window.console.log("üóëÔ∏è Removed existing all-problems banner")

      # ‚úÖ FIXED: Unpack 3 values, calculate percentage from first 2
      total_score, max_score, problem_scores = self.calculate_total_score()
      percentage = (total_score / max_score * 100.0) if max_score > 0 else 0.0
      window.console.log(f"üìä Score calculated: {percentage:.1f}%")

      # Determine grade/message based on score
      if percentage >= 90:
          grade_emoji = "üèÜ"
          grade_text = "Outstanding!"
          grade_color = "#f59e0b"
      elif percentage >= 80:
          grade_emoji = "üåü"
          grade_text = "Excellent!"
          grade_color = "#10b981"
      elif percentage >= 70:
          grade_emoji = "üëç"
          grade_text = "Good Job!"
          grade_color = "#3b82f6"
      elif percentage >= 60:
          grade_emoji = "‚úì"
          grade_text = "Well Done!"
          grade_color = "#8b5cf6"
      else:
          grade_emoji = "üìö"
          grade_text = "Keep Practicing!"
          grade_color = "#6b7280"

      # Create congratulations element
      all_congrats_el = document.createElement("div")
      all_congrats_el.id = "allProblemsComplete"

      # Find the main content area to append to
      main_content = document.querySelector("#solveProblemsContainer")
      if main_content:
          # Insert at the very top
          if main_content.firstChild:
              main_content.insertBefore(all_congrats_el, main_content.firstChild)
          else:
              main_content.appendChild(all_congrats_el)
      else:
          # Fallback to body
          document.body.appendChild(all_congrats_el)

      total_problems = len(self.problem_set)

      all_congrats_el.innerHTML = f"""
      <div style='background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
                  color: white;
                  padding: 40px;
                  border-radius: 16px;
                  margin: 0 0 24px 0;
                  text-align: center;
                  max-width: 100%;
                  box-shadow: 0 8px 24px rgba(240, 147, 251, 0.4);'>
          <div style='font-size: 64px; margin-bottom: 16px;'>{grade_emoji}</div>
          <div style='font-size: 32px; font-weight: 700; margin-bottom: 12px;'>
              {grade_text}
          </div>
          <div style='font-size: 20px; margin-bottom: 16px;'>
              You've completed all {total_problems} problem{'' if total_problems == 1 else 's'}!
          </div>

          <div style='background: rgba(255,255,255,0.15); 
                      padding: 24px; 
                      border-radius: 12px; 
                      margin: 20px 0;
                      backdrop-filter: blur(10px);'>
              <div style='font-size: 16px; opacity: 0.9; margin-bottom: 12px; font-weight: 600;'>
                  üìä Your Total Score
              </div>
              <div style='font-size: 48px; font-weight: 700; margin-bottom: 8px;'>
                  {percentage:.1f}%
              </div>
              <div style='font-size: 14px; opacity: 0.85;'>
                  {total_score:.0f} / {max_score:.0f} points
              </div>
          </div>

          <div style='font-size: 16px; opacity: 0.95; margin-top: 16px;'>
              Great job on mastering these concepts! üåü
          </div>
      </div>
      """

      # Scroll to the message
      all_congrats_el.scrollIntoView({'behavior': 'smooth', 'block': 'start'})

      window.console.log(f"üéä Displayed completion message with score: {percentage:.1f}%!")
    
    def calculate_step_score(self, step_idx, step_data, step_state):
      """
      Calculate score for a step based on its type and user's answer.
      Returns a score between 0 and 100.
      """
      step_type = step_state.get("step_type", "math-expression")

      window.console.log(f"üî¢ Calculating score for step {step_idx}, type: {step_type}")
      window.console.log(f"   Finished: {step_state.get('finished', False)}, Correct: {step_state.get('correct', False)}")
      window.console.log(f"   User answers: {step_state.get('user_answers', [])}")

      # If not finished, score is 0
      if not step_state.get("finished", False):
          window.console.log(f"   Score: 0 (not finished)")
          return 0.0

      # Math expression and other simple types
      if step_type == "math-expression":
          score = 100.0 if step_state.get("correct", False) else 0.0
          window.console.log(f"   Score: {score} (math-expression)")
          return score

      # Multiple choice - single answer
      elif step_type == "multiple-choice-single":
          score = 100.0 if step_state.get("correct", False) else 0.0
          window.console.log(f"   Score: {score} (mc-single)")
          return score

      # Multiple choice - multiple answers (with negative scoring)
      elif step_type == "multiple-choice-multiple":
          score = self._calculate_mc_multiple_score(step_data, step_state)
          window.console.log(f"   Score: {score} (mc-multiple)")
          return score

      # True/False
      elif step_type == "true-false":
          score = 100.0 if step_state.get("correct", False) else 0.0
          window.console.log(f"   Score: {score} (true-false)")
          return score

      # Fill in the blank (proportional scoring)
      elif step_type == "fill-blank":
          score = self._calculate_fill_blank_score(step_data, step_state)
          window.console.log(f"   Score: {score} (fill-blank)")
          return score

      # Default
      window.console.log(f"   Score: 0 (unknown type)")
      return 0.0


    def calculate_total_score(self):
      """
      Calculate total score across all problems.
      Returns (total_score, max_score, problem_scores)
      """
      window.console.log("=" * 60)
      window.console.log("üìä CALCULATING TOTAL SCORE")
      window.console.log("=" * 60)

      total_score = 0.0
      max_score = 0.0
      problem_scores = {}  # ‚úÖ Initialize here

      for prob_idx, problem in enumerate(self.problem_set):
          steps = problem.get("steps", [])
          window.console.log(f"\nProblem {prob_idx}: {len(steps)} steps")

          prob_score = 0.0
          prob_max = 0.0

          # Get saved state for this problem
          if prob_idx in self.problem_states:
              saved_state = self.problem_states[prob_idx]
              window.console.log(f"  Found saved state with {len(saved_state)} steps")

              for step_idx, step_data in enumerate(steps):
                  prob_max += 100.0  # Each step worth 100 points

                  if step_idx < len(saved_state):
                      step_state = saved_state[step_idx]
                      step_score = self.calculate_step_score(step_idx, step_data, step_state)
                      prob_score += step_score

                      window.console.log(f"  Problem {prob_idx}, Step {step_idx}: {step_score:.2f}/100")
                  else:
                      window.console.log(f"  Problem {prob_idx}, Step {step_idx}: No saved state")
          else:
              # No saved state, just add to max score
              prob_max = len(steps) * 100.0
              window.console.log(f"  No saved state for problem {prob_idx}")

          # ‚úÖ Store problem score info
          problem_scores[prob_idx] = {
              'score': prob_score,
              'max_score': prob_max,
              'percentage': (prob_score / prob_max * 100.0) if prob_max > 0 else 0.0
          }

          # Add to totals
          total_score += prob_score
          max_score += prob_max

      percentage = (total_score / max_score * 100.0) if max_score > 0 else 0.0

      window.console.log("=" * 60)
      window.console.log(f"üìä TOTAL: {total_score:.2f}/{max_score:.2f} = {percentage:.2f}%")
      window.console.log("=" * 60)

      # Return total_score, max_score, and percentage (not problem_scores)
      return (total_score, max_score, percentage)


    def _calculate_mc_multiple_score(self, step_data, step_state):
      """
      Calculate score for multiple-choice-multiple with penalty scoring.

      Logic:
      1. Selecting a correct option: +points (100% / num_correct_options)
      2. NOT selecting an incorrect option: 0 points (neutral)
      3. Selecting an incorrect option: -points (100% / num_incorrect_options)
      4. NOT selecting a correct option: 0 points (neutral, miss the +points)

      This ensures:
      - Selecting all options ‚Üí score = 0
      - Selecting nothing ‚Üí score = 0
      - Selecting only correct options ‚Üí score = 100
      """
      correct_answers = step_data.get("correct_answers", [])
      user_answers = step_state.get("user_answers", [])

      if not correct_answers:
          return 0.0

      # Get all options
      all_options = step_data.get("options", [])
      total_options = len(all_options)

      if total_options == 0:
          return 0.0

      # Determine correct and incorrect option labels
      correct_labels = set(correct_answers)
      all_labels = set([opt.get("label", "") for opt in all_options])
      incorrect_labels = all_labels - correct_labels

      num_correct = len(correct_labels)
      num_incorrect = len(incorrect_labels)

      # Points distribution
      points_per_correct = 100.0 / num_correct if num_correct > 0 else 0.0
      penalty_per_incorrect = 100.0 / num_incorrect if num_incorrect > 0 else 0.0

      # Calculate score based on selections only
      score = 0.0
      user_set = set(user_answers)

      # Add points for each correct option selected
      for label in user_set:
          if label in correct_labels:
              score += points_per_correct
          elif label in incorrect_labels:
              score -= penalty_per_incorrect

      # Clamp score between 0 and 100
      score = max(0.0, min(100.0, score))

      window.console.log(f"MC-Multiple Score: {score:.2f}%")
      window.console.log(f"  Correct selected: {len(user_set & correct_labels)}/{num_correct} (+{points_per_correct:.2f} each)")
      window.console.log(f"  Incorrect selected: {len(user_set & incorrect_labels)}/{num_incorrect} (-{penalty_per_incorrect:.2f} each)")

      return score


    def _calculate_fill_blank_score(self, step_data, step_state):
      """
      Calculate score for fill-in-the-blank questions.
      Since there's only one blank with multiple possible correct answers,
      score is either 100 (correct) or 0 (incorrect).
      """
      correct_answers = step_data.get("correct_answers", [])
      user_answers = step_state.get("user_answers", [])

      if not correct_answers or not user_answers:
          return 0.0

      user_answer = user_answers[0].strip().lower() if len(user_answers) > 0 else ""

      # Check if user answer matches any correct answer
      for correct_ans in correct_answers:
          if isinstance(correct_ans, dict):
              # Old format support: {"value": "answer"}
              correct_value = correct_ans.get("value", "").strip().lower()
          else:
              # New format: just string
              correct_value = str(correct_ans).strip().lower()

          if user_answer == correct_value:
              window.console.log(f"Fill-Blank Score: 100% (matched '{correct_value}')")
              return 100.0

      window.console.log(f"Fill-Blank Score: 0% (no match found)")
      return 0.0
    
    def submit_math_expression(self, step_idx):
      """Handle submission for math expression problems - checks correctness only"""
      if step_idx >= len(self.solve_state):
          return

      step = self.solve_state[step_idx]
      step_data = step.get("step_data") or step.get("step", {})
      container = step["container"]

      # Get answer field
      answer_mf = getattr(container, "answer_mf", None)

      # Get user answer
      user_latex = answer_mf.latex().strip() if answer_mf else ""
      if not user_latex:
          self.show_feedback(step_idx, "‚ö†Ô∏è Please enter an answer", "#92400e")
          return

      # Get expected answer
      expected_latex = step_data.get("expected", "").strip()

      if not expected_latex:
          self.show_feedback(step_idx, "‚ö†Ô∏è No expected answer defined", "#92400e")
          return

      window.console.log(f"üìù User LaTeX: {user_latex}")
      window.console.log(f"üìù Expected LaTeX: {expected_latex}")

      # Try to parse with error recovery
      try:
          window.console.log("Attempting to parse user expression...")
          user_expr = self.math_parser.parse_latex(user_latex)

          if user_expr is None:
              window.console.log("‚ùå Parser returned None, attempting recovery...")
              self.show_parsing_error_with_recovery(step_idx, user_latex, "Parser returned None")
              return

      except Exception as e:
          window.console.log(f"‚ùå Exception during parsing: {e}")
          self.show_parsing_error_with_recovery(step_idx, user_latex, e)
          return

      # Parse expected answer
      try:
          expected_expr = self.math_parser.parse_latex(expected_latex)

          if expected_expr is None:
              self.show_feedback(step_idx, "‚ö†Ô∏è Could not parse expected answer (instructor error)", "#92400e")
              return

      except Exception as e:
          window.console.error(f"‚ùå Expected expression parsing error: {e}")
          self.show_feedback(step_idx, "‚ö†Ô∏è Could not parse expected answer (instructor error)", "#92400e")
          return

      window.console.log(f"‚úÖ User parsed: {user_expr}")
      window.console.log(f"‚úÖ Expected parsed: {expected_expr}")

      # Store for finalize
      step["parsed_user_answer"] = user_expr
      step["parsed_expected_answer"] = expected_expr
      step["last_correct_latex"] = user_latex
      step["user_answers"] = [user_latex]

      # ‚úÖ NEW: Get current problem index
      current_prob_idx = self.current_problem_index

      try:
          user_normalized = self.math_parser.normalize_expr(user_expr)
          expected_normalized = self.math_parser.normalize_expr(expected_expr)

          window.console.log(f"üîÑ User normalized: {user_normalized}")
          window.console.log(f"üîÑ Expected normalized: {expected_normalized}")

          is_correct = self.math_parser.final_eq(user_normalized, expected_normalized)
          window.console.log(f"{'‚úÖ' if is_correct else '‚ùå'} Correctness check: {is_correct}")

      except Exception as e:
          window.console.error(f"‚ùå Validation error: {e}")
          import traceback
          window.console.error(traceback.format_exc())
          self.show_feedback(step_idx, f"‚ö†Ô∏è Error checking answer: {str(e)}", "#92400e")
          return

      step["attempts"] = step.get("attempts", 0) + 1
      time_taken = 0

      if is_correct:
          step["correct"] = True

          # ‚úÖ CRITICAL: Update problem_states too
          if current_prob_idx is not None and current_prob_idx in self.problem_states:
              if step_idx < len(self.problem_states[current_prob_idx]):
                  self.problem_states[current_prob_idx][step_idx]["correct"] = True
                  self.problem_states[current_prob_idx][step_idx]["user_answers"] = [user_latex]
                  self.problem_states[current_prob_idx][step_idx]["attempts"] = step["attempts"]
                  window.console.log(f"‚úÖ Updated problem_states: correct=True")

          self.show_feedback(step_idx, "‚úÖ Correct! Now click Finalize to verify your solution method.", "#059669")

          finalize_btn = container.querySelector(".finalize-step")
          if finalize_btn:
              finalize_btn.disabled = False
              finalize_btn.style.opacity = "1"

          submit_btn = container.querySelector(".submit-step")
          if submit_btn:
              submit_btn.disabled = True
              submit_btn.style.opacity = "0.5"

          self.add_to_global_history(step_idx, user_latex, True, time_taken, "submit")
      else:
          step["correct"] = False

          # ‚úÖ CRITICAL: Update problem_states too
          if current_prob_idx is not None and current_prob_idx in self.problem_states:
              if step_idx < len(self.problem_states[current_prob_idx]):
                  self.problem_states[current_prob_idx][step_idx]["correct"] = False
                  self.problem_states[current_prob_idx][step_idx]["user_answers"] = [user_latex]
                  self.problem_states[current_prob_idx][step_idx]["attempts"] = step["attempts"]
                  window.console.log(f"‚úÖ Updated problem_states: correct=False")

          self.show_feedback(step_idx, "‚ùå Incorrect. Try again!", "#b91c1c")
          self.add_to_global_history(step_idx, user_latex, False, time_taken, "submit")

      self.save_to_storage()
    
    def show_parsing_error_with_recovery(self, step_idx, latex_str, error):
      """
      Show a helpful parsing error message with attempted recovery.
      """
      error_msg = str(error)
      window.console.log(f"‚ùå Parsing error: {error_msg}")

      # Try to get error position context
      position_info = self.get_error_position_context(latex_str, error_msg)

      # Attempt to recover
      success, fixed_latex, fix_description = self.attempt_latex_recovery(latex_str, error_msg)

      if success:
          # Recovery successful - show what was fixed and ask if they want to use it
          # Escape quotes in fixed_latex for JavaScript
          fixed_latex_escaped = fixed_latex.replace('\\', '\\\\').replace('"', '\\"')

          feedback = f"""
          <div style='background:#fef3c7;border:2px solid #f59e0b;border-radius:8px;padding:16px;'>
              <div style='font-weight:700;color:#92400e;margin-bottom:12px;'>
                  ‚ö†Ô∏è Syntax Error Detected (but we fixed it!)
              </div>
              <div style='margin-bottom:8px;'>
                  <strong>Your input:</strong><br>
                  <code style='background:#fff;padding:4px 8px;border-radius:4px;display:inline-block;margin-top:4px;'>{html.escape(latex_str)}</code>
              </div>
              <div style='margin-bottom:8px;'>
                  <strong>Issue found:</strong> {html.escape(fix_description)}
              </div>
              <div style='margin-bottom:12px;'>
                  <strong>Corrected to:</strong><br>
                  <code style='background:#fff;padding:4px 8px;border-radius:4px;display:inline-block;margin-top:4px;'>{html.escape(fixed_latex)}</code>
              </div>
              <button class='btn' onclick='window.problem_solver_app.use_corrected_latex({step_idx}, "{fixed_latex_escaped}");' 
                      style='background:#059669;color:white;'>
                  Use Corrected Version
              </button>
          </div>
          """
          self.show_feedback(step_idx, feedback, "#f59e0b")

          # Store the corrected version for later use
          step = self.solve_state[step_idx]
          step["suggested_correction"] = fixed_latex

      else:
          # Recovery failed - show helpful error message
          feedback_parts = [
              "<div style='background:#fee2e2;border:2px solid #dc2626;border-radius:8px;padding:16px;'>",
              "<div style='font-weight:700;color:#991b1b;margin-bottom:12px;'>‚ùå Cannot Parse Expression</div>",
              f"<div style='margin-bottom:8px;'><strong>Your input:</strong><br><code style='background:#fff;padding:4px 8px;border-radius:4px;display:inline-block;margin-top:4px;'>{html.escape(latex_str)}</code></div>",
          ]

          if position_info:
              feedback_parts.append(f"<div style='margin-bottom:8px;'><strong>{html.escape(position_info)}</strong></div>")

          feedback_parts.append("<div style='margin-bottom:8px;'><strong>Common issues:</strong></div>")
          feedback_parts.append("<ul style='margin:8px 0;padding-left:20px;'>")
          feedback_parts.append("<li>Check for matching brackets: ( ), { }, [ ]</li>")
          feedback_parts.append("<li>Remove empty power braces: x^{} should be x</li>")
          feedback_parts.append("<li>Remove trailing power symbols: x^ should be x</li>")
          feedback_parts.append("<li>Ensure fractions are complete: \\frac{numerator}{denominator}</li>")
          feedback_parts.append("<li>Check for double operators like ++ or --</li>")
          feedback_parts.append("</ul>")
          feedback_parts.append("<div style='margin-top:12px;font-size:14px;'>Please correct your input and try again.</div>")
          feedback_parts.append("</div>")

          self.show_feedback(step_idx, "".join(feedback_parts), "#dc2626")
    
    def get_error_position_context(self, latex_str, error_msg):
        """
        Try to extract position information from error message and provide context.
        Returns a string showing the error location visually.
        """
        import re

        # Look for patterns like "at position X" or "column X" or "index X"
        position_patterns = [
            r'position\s+(\d+)',
            r'column\s+(\d+)',
            r'index\s+(\d+)',
            r'at\s+(\d+)',
            r'col\s+(\d+)',
        ]

        position = None
        for pattern in position_patterns:
            match = re.search(pattern, str(error_msg), re.IGNORECASE)
            if match:
                position = int(match.group(1))
                break

        if position is not None and 0 <= position < len(latex_str):
            at_error = latex_str[position] if position < len(latex_str) else ''
            context = f"\n{latex_str}\n{' ' * position}^ Error here"
            window.console.log(f"Error position: {position}")
            window.console.log(context)
            return f"Error at position {position}: '{at_error}'"

        return None


    def show_parsing_error_with_recovery(self, step_idx, latex_str, error):
        """
        Show a helpful parsing error message with attempted recovery.
        """
        error_msg = str(error)
        window.console.log(f"‚ùå Parsing error: {error_msg}")

        # Try to get error position context
        position_info = self.get_error_position_context(latex_str, error_msg)

        # Attempt to recover
        success, fixed_latex, fix_description = self.attempt_latex_recovery(latex_str, error_msg)

        if success:
            # Recovery successful - show what was fixed
            fixed_latex_escaped = fixed_latex.replace('\\', '\\\\').replace('"', '\\"')

            feedback = f"""
            <div style='background:#fef3c7;border:2px solid #f59e0b;border-radius:8px;padding:16px;'>
                <div style='font-weight:700;color:#92400e;margin-bottom:12px;'>
                    ‚ö†Ô∏è Syntax Error Detected (but we fixed it!)
                </div>
                <div style='margin-bottom:8px;'>
                    <strong>Your input:</strong><br>
                    <code style='background:#fff;padding:4px 8px;border-radius:4px;display:inline-block;margin-top:4px;'>{html.escape(latex_str)}</code>
                </div>
                <div style='margin-bottom:8px;'>
                    <strong>Issue found:</strong> {html.escape(fix_description)}
                </div>
                <div style='margin-bottom:12px;'>
                    <strong>Corrected to:</strong><br>
                    <code style='background:#fff;padding:4px 8px;border-radius:4px;display:inline-block;margin-top:4px;'>{html.escape(fixed_latex)}</code>
                </div>
                <button class='btn' onclick='window.problem_solver_app.use_corrected_latex({step_idx}, "{fixed_latex_escaped}");' 
                        style='background:#059669;color:white;'>
                    Use Corrected Version
                </button>
            </div>
            """
            self.show_feedback(step_idx, feedback, "#f59e0b")

            # Store the corrected version
            step = self.solve_state[step_idx]
            step["suggested_correction"] = fixed_latex

        else:
            # Recovery failed - show helpful error message
            feedback_parts = [
                "<div style='background:#fee2e2;border:2px solid #dc2626;border-radius:8px;padding:16px;'>",
                "<div style='font-weight:700;color:#991b1b;margin-bottom:12px;'>‚ùå Cannot Parse Expression</div>",
                f"<div style='margin-bottom:8px;'><strong>Your input:</strong><br><code style='background:#fff;padding:4px 8px;border-radius:4px;display:inline-block;margin-top:4px;'>{html.escape(latex_str)}</code></div>",
            ]

            if position_info:
                feedback_parts.append(f"<div style='margin-bottom:8px;'><strong>{html.escape(position_info)}</strong></div>")

            feedback_parts.append("<div style='margin-bottom:8px;'><strong>Common issues:</strong></div>")
            feedback_parts.append("<ul style='margin:8px 0;padding-left:20px;'>")
            feedback_parts.append("<li>Check for matching brackets: ( ), { }, [ ]</li>")
            feedback_parts.append("<li>Remove empty power braces: x^{} should be x</li>")
            feedback_parts.append("<li>Remove trailing power symbols: x^ should be x</li>")
            feedback_parts.append("<li>Ensure fractions are complete: \\frac{numerator}{denominator}</li>")
            feedback_parts.append("</ul>")
            feedback_parts.append("<div style='margin-top:12px;font-size:14px;'>Please correct your input and try again.</div>")
            feedback_parts.append("</div>")

            self.show_feedback(step_idx, "".join(feedback_parts), "#dc2626")


    def use_corrected_latex(self, step_idx, corrected_latex):
        """
        Use the suggested corrected LaTeX string and submit it.
        """
        window.console.log(f"use_corrected_latex called: step={step_idx}, latex={corrected_latex}")

        if step_idx >= len(self.solve_state):
            window.console.error(f"Invalid step index: {step_idx}")
            return

        step = self.solve_state[step_idx]
        container = step["container"]

        # Get the MathQuill field and set the corrected value
        answer_mf = getattr(container, "answer_mf", None)
        if answer_mf:
            answer_mf.latex(corrected_latex)
            window.console.log(f"‚úÖ Applied corrected LaTeX: {corrected_latex}")

            # Clear the feedback
            self.show_feedback(step_idx, "üîÑ Using corrected version...", "#3b82f6")

            # Auto-submit after a short delay
            def delayed_submit():
                self.submit_math_expression(step_idx)

            window.setTimeout(create_proxy(delayed_submit), 100)
        else:
            window.console.error("Could not find MathQuill field")
    
    def attempt_latex_recovery(self, latex_str, error_msg):
      """
      Attempt to recover from LaTeX parsing errors by trying common fixes.
      Returns (success, fixed_latex, fix_description) or (False, None, None)
      """
      window.console.log(f"üîß Attempting to recover from error: {error_msg}")
      window.console.log(f"üîß Original LaTeX: {latex_str}")

      import re

      # ===== FIX FUNCTIONS =====

      def fix_empty_power_braces(s):
          """Fix empty power braces like x^{} or x^{ } to x"""
          try:
              original = s
              # Remove ^{} (no space)
              s = s.replace('^{}', '')

              # Remove ^{ } (with any whitespace)
              pattern = r'\^\{\s*\}'
              s = re.sub(pattern, '', s)

              if s != original:
                  window.console.log(f"  Fixed: Removed empty power braces")
              return s
          except Exception as e:
              window.console.log(f"  Error in fix_empty_power_braces: {e}")
              return s

      def remove_trailing_power_symbol(s):
          """Remove trailing ^ at the end of expression or before operators"""
          try:
              original = s
              # Remove ^ at end
              if s.endswith('^'):
                  s = s[:-1]
              # Remove ^ before operators
              for op in ['+', '-', '*', '/', ')', ']', '}', ' ', '\\']:
                  s = s.replace('^' + op, op)
              if s != original:
                  window.console.log(f"  Fixed: Removed trailing power symbol(s)")
          except Exception as e:
              window.console.log(f"  Error in remove_trailing_power_symbol: {e}")
          return s

      def fix_double_power_symbol(s):
          """Fix double power symbols like x^^2 to x^2"""
          try:
              if '^^' in s:
                  fixed = s.replace('^^', '^')
                  window.console.log(f"  Fixed: Double power symbol (^^)")
                  return fixed
          except Exception as e:
              window.console.log(f"  Error in fix_double_power_symbol: {e}")
          return s

      def remove_empty_power(s):
          """Remove power symbol with no exponent like x^ y"""
          try:
              # Look for ^ followed by space or operator
              fixed = s
              fixed = fixed.replace('^ ', ' ')
              fixed = fixed.replace('^+', '+')
              fixed = fixed.replace('^-', '-')
              fixed = fixed.replace('^*', '*')
              fixed = fixed.replace('^/', '/')
              if fixed != s:
                  window.console.log(f"  Fixed: Removed empty power symbol(s)")
                  return fixed
          except Exception as e:
              window.console.log(f"  Error in remove_empty_power: {e}")
          return s

      def smart_bracket_balance(s):
          """Balance all types of brackets"""
          try:
              fixed = s

              # Parentheses
              open_p = fixed.count('(')
              close_p = fixed.count(')')
              if open_p > close_p:
                  fixed = fixed + ')' * (open_p - close_p)
              elif close_p > open_p:
                  for _ in range(close_p - open_p):
                      fixed = fixed.replace(')', '', 1)

              # Braces
              open_b = fixed.count('{')
              close_b = fixed.count('}')
              if open_b > close_b:
                  fixed = fixed + '}' * (open_b - close_b)
              elif close_b > open_b:
                  for _ in range(close_b - open_b):
                      fixed = fixed.replace('}', '', 1)

              if fixed != s:
                  window.console.log(f"  Fixed: Balanced brackets")
              return fixed
          except Exception as e:
              window.console.log(f"  Error in smart_bracket_balance: {e}")
              return s

      def fix_row_operation_subscripts(s):
          """Fix R1, R2, etc. to R_1, R_2"""
          try:
              fixed = s
              # Simple replacement for common cases
              for i in range(1, 10):
                  # Don't replace if already has underscore
                  if f'R{i}' in fixed and f'R_{i}' not in fixed:
                      # Check if R is followed by digit but not preceded by underscore
                      parts = fixed.split(f'R{i}')
                      result = []
                      for j, part in enumerate(parts):
                          result.append(part)
                          if j < len(parts) - 1:
                              # Check if previous part doesn't end with underscore
                              if not part.endswith('_'):
                                  result.append(f'R_{{{i}}}')
                              else:
                                  result.append(f'R{i}')
                      fixed = ''.join(result)

              if fixed != s:
                  window.console.log(f"  Fixed: Row operation subscripts")
              return fixed
          except Exception as e:
              window.console.log(f"  Error in fix_row_operation_subscripts: {e}")
              return s

      # ===== LIST OF FIXES =====

      fixes = [
          (fix_empty_power_braces, "Removed empty power braces (^{} or ^{ })"),
          (remove_trailing_power_symbol, "Removed trailing power symbol (^)"),
          (fix_double_power_symbol, "Fixed double power symbol (^^)"),
          (remove_empty_power, "Removed empty power symbol"),
          (fix_row_operation_subscripts, "Fixed row operation subscripts"),
          (smart_bracket_balance, "Balanced brackets and parentheses"),
      ]

      # ===== TRY EACH FIX =====

      for fix_func, description in fixes:
          try:
              fixed = fix_func(latex_str)
              if fixed != latex_str:
                  window.console.log(f"  Trying: {description}")
                  window.console.log(f"    Original: {latex_str}")
                  window.console.log(f"    Fixed: {fixed}")

                  # Try to parse
                  try:
                      parsed = self.math_parser.parse_latex(fixed)
                      if parsed is not None:
                          window.console.log(f"  ‚úÖ SUCCESS: {description}")
                          return (True, fixed, description)
                      else:
                          window.console.log(f"  ‚ùå Parser returned None")
                  except Exception as parse_error:
                      window.console.log(f"  ‚ùå Parse failed: {parse_error}")
          except Exception as e:
              window.console.log(f"  ‚ùå Fix error: {e}")

      # Try combined fixes
      window.console.log("  Trying combined fixes...")
      try:
          combined = latex_str
          combined = fix_empty_power_braces(combined)
          combined = remove_trailing_power_symbol(combined)
          combined = fix_double_power_symbol(combined)
          combined = remove_empty_power(combined)
          combined = fix_row_operation_subscripts(combined)
          combined = smart_bracket_balance(combined)

          if combined != latex_str:
              window.console.log(f"    Original: {latex_str}")
              window.console.log(f"    Combined result: {combined}")
              parsed = self.math_parser.parse_latex(combined)
              if parsed is not None:
                  window.console.log(f"  ‚úÖ Combined fix successful!")
                  return (True, combined, "Fixed power symbols and brackets")
              else:
                  window.console.log(f"  ‚ùå Combined fix: Parser returned None")
      except Exception as e:
          window.console.log(f"  ‚ùå Combined fix failed: {e}")

      window.console.log("‚ùå No successful recovery found")
      return (False, None, None)
    
    def show_feedback(self, step_idx, message, color):
        """Show feedback message"""
        if step_idx >= len(self.solve_state):
            return
        
        step = self.solve_state[step_idx]
        feedback = step["container"].querySelector(".step-feedback")
        if feedback:
            feedback.innerHTML = f"<div style='color:{color};background:{color}20;padding:12px;border-radius:6px;'>{message}</div>"
    
    def next_step(self, step_idx):
      """Move to next step"""
      if step_idx >= len(self.solve_state):
          return

      # Hide current step
      self.solve_state[step_idx]["container"].style.display = "none"
      self.solve_state[step_idx]["container"].classList.remove("active")

      # Show next step
      if step_idx + 1 < len(self.solve_state):
          next_container = self.solve_state[step_idx + 1]["container"]
          next_container.style.display = "block"
          next_container.classList.add("active")

          # ‚úÖ Render MathJax for the newly visible step
          def render_step_mathjax(retry_count=0):
              max_retries = 3
              try:
                  if hasattr(window, 'MathJax') and hasattr(window.MathJax, 'typesetPromise'):
                      window.console.log("üé® Rendering MathJax for next step...")
                      # ‚úÖ Fix: Lambda needs to accept the result argument
                      window.MathJax.typesetPromise([next_container]).then(
                          create_proxy(lambda result: window.console.log("‚úÖ Step MathJax rendered"))
                      )
                  elif retry_count < max_retries:
                      window.setTimeout(create_proxy(lambda: render_step_mathjax(retry_count + 1)), 200)
              except Exception as e:
                  window.console.error(f"Step MathJax render error: {e}")

          window.setTimeout(create_proxy(render_step_mathjax), 100)

      self.save_to_storage()
    
    def export_progress(self, event):
        """Export progress"""
        if not self.problem_set:
            window.alert("No problems to submit")
            return
        
        try:
            # Build export data
            export_data = {
                "problem_set_id": self.current_problem_set_uuid,
                "problem_set": self.problem_set,
                "problem_states": self.problem_states,
                "export_date": window.Date.new().toISOString()
            }
            
            json_str = json.dumps(export_data)
            
            # Compress
            import brotli
            compressed = brotli.compress(json_str.encode('utf-8'))
            b64_str = base64.b64encode(compressed).decode('utf-8')
            
            # Create file
            output = f"=== STUDENT PROGRESS EXPORT ===\n{b64_str}\n=== END EXPORT ==="
            
            blob = window.Blob.new([output], {"type": "text/plain"})
            url = window.URL.createObjectURL(blob)
            a = document.createElement("a")
            a.href = url
            a.download = f"progress_{window.Date.new().toISOString().split('T')[0]}.txt"
            document.body.appendChild(a)
            a.click()
            a.remove()
            
            window.setTimeout(create_proxy(lambda: window.URL.revokeObjectURL(url)), 1000)
            
            window.alert("‚úÖ Progress exported successfully!")
            
        except Exception as e:
            window.console.error(f"Export failed: {e}")
            window.alert(f"‚ùå Export failed: {e}")
    
    def handle_freestyle_input(self, action):
        """Handle keyboard input for freestyle practice"""
        try:
            # Determine which field to target
            if self.freestyle_problem:
                target_field = self.freestyle_answer_mf
            else:
                target_field = self.freestyle_problem_mf

            if not target_field:
                return

            # Handle special actions
            if action == "BACKSPACE":
                target_field.keystroke("Backspace")
            elif action == "CLEAR":
                target_field.latex("")
            elif action == "MOVE_LEFT":
                target_field.keystroke("Left")
            elif action == "MOVE_RIGHT":
                target_field.keystroke("Right")
            elif action.startswith("SEQ:"):
                # Handle sequences like "d,/,d,x"
                parts = action[4:].split(",")
                for part in parts:
                    if part.startswith("{") and part.endswith("}"):
                        target_field.keystroke(part[1:-1])
                    else:
                        target_field.write(part)
            else:
                target_field.write(action)

            target_field.focus()

        except Exception as e:
            window.console.error(f"Input handler error: {e}")

    def set_freestyle_problem(self, event):
      """Set the freestyle problem with limit validation"""
      window.console.log("=== set_freestyle_problem called ===")

      if not self.freestyle_problem_mf:
          window.alert("‚ö†Ô∏è Problem input not ready")
          return

      problem_latex = self.freestyle_problem_mf.latex().strip()
      window.console.log(f"Problem latex: {problem_latex}")

      if not problem_latex:
          window.alert("‚ö†Ô∏è Please enter a problem first")
          return

      # Check if this is a matrix row operation problem
      # Multiple patterns to catch different formats
      is_matrix_row_op = (
          '|R_' in problem_latex or 
          '|\\mathrm{R}_' in problem_latex or
          '\\left|R_' in problem_latex or
          '\\left|\\mathrm{R}_' in problem_latex or
          '\\right|' in problem_latex  # Closing pipe for row ops
      )

      if is_matrix_row_op:
        window.console.log("üîç Detected matrix row operation problem")
        window.console.log(f"Original LaTeX: {problem_latex}")

        # Parse to validate/check for errors, but don't use the result
        try:
            window.console.log("Parsing row operation to check for errors...")
            parsed_for_validation = self.math_parser.parse_latex(problem_latex)
            window.console.log(f"‚úÖ Parse successful (for validation): {parsed_for_validation}")
            window.console.log("‚ö†Ô∏è BUT we will NOT use this parsed result - only for error checking")
        except Exception as e:
            window.console.error(f"‚ùå Parse error in row operation: {e}")
            import traceback
            window.console.error(traceback.format_exc())
            window.alert(f"‚ö†Ô∏è Parse error: {e}")
            return  # Exit if there's a parse error

        # Store the ORIGINAL LaTeX (not the parsed/solved version)
        self.freestyle_problem = {
            "latex": problem_latex,  # ORIGINAL LaTeX with row operation
            "parsed": None,  # Don't store parsed for row operations
            "is_row_operation": True  # Flag to indicate special handling
        }

        window.console.log(f"‚úÖ Row operation stored with ORIGINAL LaTeX (not solved)")

        # Reset state
        self.freestyle_attempts = []
        self.freestyle_correct = False
        self.freestyle_finalized = False

        if self.freestyle_answer_mf:
            self.freestyle_answer_mf.latex("")

        # Show solve area
        solve_area = document.querySelector("#freestyleSolveArea")
        if solve_area:
            solve_area.style.display = "block"

        # Display problem - convert matrix part, keep operation part
        problem_display = document.querySelector("#freestyleProblemDisplay")
        if problem_display:
            try:
                import sympy as sp
                import re

                # Split at the pipe: matrix part | operation part
                match = re.match(r'(.+?)(\\left\|.*?\\right\|)', problem_latex)

                if match:
                    matrix_part = match.group(1)
                    operation_part = match.group(2)

                    window.console.log(f"Split row operation for display:")
                    window.console.log(f"  Matrix part: {matrix_part}")
                    window.console.log(f"  Operation part: {operation_part}")

                    # Parse and convert only the matrix part (NOT the whole row operation)
                    parsed_matrix = self.math_parser.parse_latex(matrix_part)
                    converted_matrix = self._convert_latex_preserve_order(parsed_matrix)

                    # Combine: converted matrix + original operation
                    display_latex = converted_matrix + operation_part

                    window.console.log(f"  ‚úÖ Combined for display: {display_latex}")
                    problem_display.innerHTML = f"$$\\displaystyle {display_latex}$$"
                else:
                    # Fallback if regex doesn't match
                    window.console.log("Regex didn't match, using original")
                    problem_display.innerHTML = f"$$\\displaystyle {problem_latex}$$"

            except Exception as e:
                window.console.error(f"Error converting row operation for display: {e}")
                import traceback
                window.console.error(traceback.format_exc())
                # Fallback to original
                problem_display.innerHTML = f"$$\\displaystyle {problem_latex}$$"

            if hasattr(window, 'MathJax') and hasattr(window.MathJax, 'typesetPromise'):
                window.MathJax.typesetPromise([problem_display])

        # Clear feedback
        feedback_el = document.querySelector("#freestyleFeedback")
        if feedback_el:
            feedback_el.innerHTML = ""

        history_el = document.querySelector("#freestyleHistory")
        if history_el:
            history_el.innerHTML = ""

        # For row operations, difficulty is always 3 (medium)
        difficulty = 3
        credits_needed = difficulty

        giveup_btn = document.querySelector("#freestyleGiveUp")
        if giveup_btn:
            giveup_btn.textContent = f"Give Up (üíé {credits_needed} credit{'s' if credits_needed != 1 else ''})"

            if self.credit_balance >= credits_needed:
                giveup_btn.disabled = False
                giveup_btn.style.opacity = "1"
                giveup_btn.title = f"Use {credits_needed} credit{'s' if credits_needed != 1 else ''} to reveal solution"
            else:
                giveup_btn.disabled = True
                giveup_btn.style.opacity = "0.5"
                shortage = credits_needed - self.credit_balance
                giveup_btn.title = f"Need {shortage} more credit{'s' if shortage != 1 else ''} to use this (you have {self.credit_balance})"

        # For row operations, disable finalize button (they work manually)
        finalize_btn = document.querySelector("#freestyleFinalize")
        if finalize_btn:
            finalize_btn.disabled = True
            finalize_btn.style.opacity = "0.5"
            finalize_btn.title = "Row operation problems don't need simplification check"

        # Enable submit button
        submit_btn = document.querySelector("#freestyleSubmit")
        if submit_btn:
            submit_btn.disabled = False
            submit_btn.style.opacity = "1"

        window.alert("‚úÖ Matrix row operation problem set! Solve it by performing the operation.")
        return  # Exit early for row operations


      # REGULAR PROBLEMS (not row operations) - parse and normalize as usual
      # Parse the problem to validate it
      try:
          window.console.log("Parsing problem...")
          parsed = self.math_parser.parse_latex(problem_latex)
          window.console.log(f"Parsed: {parsed}")
          window.console.log(f"Parsed type: {type(parsed)}")

          if parsed is None:
              window.alert("‚ö†Ô∏è Could not parse the problem. Please check your input.")
              return
      except Exception as e:
          window.console.error(f"Parse error: {e}")
          import traceback
          window.console.error(traceback.format_exc())
          window.alert(f"‚ö†Ô∏è Parse error: {e}")
          return

      # ‚úÖ VALIDATE LIMIT PROBLEMS
      import sympy as sp
      if isinstance(parsed, sp.Limit):
          try:
              window.console.log("üîç Validating limit problem...")
              is_valid, error_msg = self.math_parser.validate_limit(parsed)

              if not is_valid:
                  window.console.error(f"Invalid limit problem: {error_msg}")

                  full_error_msg = f"""{error_msg}

  Please choose a limit problem with a finite, well-defined value.

  Common issues to avoid:
  - Limits that equal infinity or negative infinity
  - Limits with different left and right values (discontinuities)
  - Oscillating limits that don't converge to a single value
  - Limits that are undefined or indeterminate

  Try using limits that evaluate to specific finite numbers instead."""

                  self._show_limit_validation_error_popup(full_error_msg)
                  return

              window.console.log("‚úÖ Limit validation passed")
          except Exception as e:
              window.console.error(f"Limit validation error: {e}")
              import traceback
              window.console.error(traceback.format_exc())
              pass

      # Normal problems: normalize to check for errors and get expected answer
      try:
          window.console.log("Normalizing to check for errors...")
          normalized = self.math_parser.normalize_expr(parsed)
          window.console.log(f"Normalization check passed. Result: {normalized}")

          # Store the problem with the RAW parsed expression
          self.freestyle_problem = {
              "latex": problem_latex,
              "parsed": parsed,
              "is_row_operation": False
          }
          window.console.log("‚úÖ Problem stored successfully")

      except Exception as e:
          window.console.error(f"Error processing problem: {e}")
          import traceback
          window.console.error(traceback.format_exc())
          window.alert(f"‚ö†Ô∏è Error: {e}")
          return

      # Reset state
      self.freestyle_attempts = []
      self.freestyle_correct = False
      self.freestyle_finalized = False

      if self.freestyle_answer_mf:
          self.freestyle_answer_mf.latex("")

      # Show solve area
      solve_area = document.querySelector("#freestyleSolveArea")
      if solve_area:
          solve_area.style.display = "block"

      # Display problem
      problem_display = document.querySelector("#freestyleProblemDisplay")
      if problem_display:
          # Helper function to check if expression contains a matrix anywhere
          def contains_matrix(expr):
              """Check if expression contains a matrix at any level"""
              try:
                  if isinstance(expr, (sp.Matrix, sp.MutableDenseMatrix, sp.ImmutableDenseMatrix)):
                      return True
                  if hasattr(expr, 'args'):
                      for arg in expr.args:
                          if contains_matrix(arg):
                              return True
              except Exception as e:
                  window.console.error(f"Error in contains_matrix: {e}")
              return False

          # Check if it contains matrices
          has_matrix_in_latex = '[[' in problem_latex or '\\left[\\left[' in problem_latex
          has_matrix_in_tree = contains_matrix(parsed) if parsed else False

          window.console.log(f"=== Display Problem Debug ===")
          window.console.log(f"Problem LaTeX: {problem_latex}")
          window.console.log(f"Has [[ in LaTeX: {has_matrix_in_latex}")
          window.console.log(f"Has matrix in tree: {has_matrix_in_tree}")
          window.console.log(f"Parsed type: {type(parsed)}")
          window.console.log(f"Parsed value: {parsed}")

          # Should we convert?
          should_convert = has_matrix_in_latex or has_matrix_in_tree

          if should_convert:
              try:
                  window.console.log("üîÑ Attempting conversion...")
                  display_latex = self._convert_latex_preserve_order(parsed)
                  window.console.log(f"‚úÖ Conversion successful!")
                  window.console.log(f"Result: {display_latex}")
                  problem_display.innerHTML = f"$$\\displaystyle {display_latex}$$"
              except Exception as e:
                  # Fallback to original if conversion fails
                  window.console.error(f"‚ùå Conversion failed: {e}")
                  import traceback
                  window.console.error(traceback.format_exc())
                  window.console.log("‚ö†Ô∏è Using original LaTeX as fallback")
                  problem_display.innerHTML = f"$$\\displaystyle {problem_latex}$$"
          else:
              # No matrices, use original LaTeX
              window.console.log("No matrix detected, using original LaTeX")
              problem_display.innerHTML = f"$$\\displaystyle {problem_latex}$$"

          # Render with MathJax
          if hasattr(window, 'MathJax') and hasattr(window.MathJax, 'typesetPromise'):
              window.console.log("Rendering with MathJax...")
              window.MathJax.typesetPromise([problem_display])

      # Clear feedback
      feedback_el = document.querySelector("#freestyleFeedback")
      if feedback_el:
          feedback_el.innerHTML = ""

      history_el = document.querySelector("#freestyleHistory")
      if history_el:
          history_el.innerHTML = ""

      # Update Give Up button
      difficulty = self.calculate_problem_difficulty(parsed)
      credits_needed = difficulty

      giveup_btn = document.querySelector("#freestyleGiveUp")
      if giveup_btn:
          giveup_btn.textContent = f"Give Up (üíé {credits_needed} credit{'s' if credits_needed != 1 else ''})"

          if self.credit_balance >= credits_needed:
              giveup_btn.disabled = False
              giveup_btn.style.opacity = "1"
              giveup_btn.title = f"Use {credits_needed} credit{'s' if credits_needed != 1 else ''} to reveal solution"
          else:
              giveup_btn.disabled = True
              giveup_btn.style.opacity = "0.5"
              shortage = credits_needed - self.credit_balance
              giveup_btn.title = f"Need {shortage} more credit{'s' if shortage != 1 else ''} to use this (you have {self.credit_balance})"

      submit_btn = document.querySelector("#freestyleSubmit")
      if submit_btn:
          submit_btn.disabled = False
          submit_btn.style.opacity = "1"

      finalize_btn = document.querySelector("#freestyleFinalize")
      if finalize_btn:
          finalize_btn.disabled = True
          finalize_btn.style.opacity = "0.5"

      window.alert("‚úÖ Problem set! Now solve it below.")

    def freestyle_submit(self, event):
        """Submit an attempt for the freestyle problem"""
        window.console.log("=== freestyle_submit called ===")

        if not self.freestyle_problem:
            window.alert("‚ö†Ô∏è Please set a problem first")
            return

        if not self.freestyle_answer_mf:
            window.alert("‚ö†Ô∏è Answer field not ready")
            return

        answer_latex = self.freestyle_answer_mf.latex().strip()

        if not answer_latex:
            window.alert("‚ö†Ô∏è Please enter your answer")
            return

        # Parse answer
        try:
            parsed_answer = self.math_parser.parse_latex(answer_latex)

            if parsed_answer is None:
                window.alert("‚ö†Ô∏è Could not parse your answer")
                return

            # Normalize both for comparison
            expected_normalized = self.math_parser.normalize_expr(self.freestyle_problem["parsed"])
            answer_normalized = self.math_parser.normalize_expr(parsed_answer)

            # Check correctness
            is_correct = self.math_parser.final_eq(answer_normalized, expected_normalized)

            # Record attempt
            attempt = {
                "latex": answer_latex,
                "correct": is_correct
            }
            self.freestyle_attempts.append(attempt)

            # Update UI
            feedback_el = document.querySelector("#freestyleFeedback")
            finalize_btn = document.querySelector("#freestyleFinalize")

            if is_correct:
                self.freestyle_correct = True
                
                if feedback_el:
                  feedback_el.innerHTML = "<div style='color:#059669;background:#d1fae5;padding:12px;border-radius:6px;'>‚úÖ Correct! Now click <strong>Check Simplest Form</strong> to verify it's simplified and earn credits.</div>"
                # Enable finalize button
                if finalize_btn:
                    finalize_btn.disabled = False
                    finalize_btn.style.opacity = "1"
                # Disable give up button (no longer needed)
                giveup_btn = document.querySelector("#freestyleGiveUp")
                if giveup_btn:
                    giveup_btn.disabled = True
                    giveup_btn.style.opacity = "0.5"
            else:
                if feedback_el:
                    feedback_el.innerHTML = f"<div style='color:#b91c1c;background:#fee2e2;padding:12px;border-radius:6px;'>‚ùå Incorrect (Attempt {len(self.freestyle_attempts)}). Try again!</div>"

            # Update history
            self._update_freestyle_history()

        except Exception as e:
            window.console.error(f"Submit error: {e}")
            import traceback
            window.console.error(traceback.format_exc())
            window.alert(f"‚ö†Ô∏è Error: {e}")

    def freestyle_finalize(self, event):
      """Check if answer is in simplest form"""
      window.console.log("=== freestyle_finalize called ===")

      if not self.freestyle_correct:
          window.alert("‚ö†Ô∏è Please submit a correct answer first")
          return

      if self.freestyle_finalized:
          window.alert("‚úÖ Already checked!")
          return

      # Get the last correct answer
      last_attempt = self.freestyle_attempts[-1] if self.freestyle_attempts else None

      if not last_attempt or not last_attempt.get("correct"):
          window.alert("‚ö†Ô∏è No correct answer found")
          return

      try:
          import sympy as sp

          # Parse the answer WITHOUT normalizing (to preserve user's form)
          answer_latex = last_attempt["latex"]
          answer_expr = self.math_parser.parse_latex(answer_latex)

          window.console.log(f"Answer expression: {answer_expr}")
          window.console.log(f"Answer srepr: {sp.srepr(answer_expr)}")

          # Get the expected simplest form by normalizing the original problem
          expected_simplest = self.math_parser.normalize_expr(self.freestyle_problem["parsed"])
          window.console.log(f"Expected simplest form: {expected_simplest}")
          window.console.log(f"Expected srepr: {sp.srepr(expected_simplest)}")

          feedback_el = document.querySelector("#freestyleFeedback")
          finalize_btn = document.querySelector("#freestyleFinalize")

          # Helper function to normalize only representation (not structure)
          def normalize_representation(expr):
              """
              Normalize only representation issues (like division to rational)
              WITHOUT changing algebraic structure (like expanding or factoring)
              """
              if isinstance(expr, (sp.Matrix, sp.MutableDenseMatrix, sp.ImmutableDenseMatrix)):
                  # For matrices, normalize each element
                  normalized_elements = []
                  for element in expr:
                      normalized_elements.append(normalize_representation(element))

                  # Reconstruct matrix with same shape
                  rows, cols = expr.shape
                  result = sp.Matrix(rows, cols, normalized_elements)
                  return sp.ImmutableMatrix(result)

              elif isinstance(expr, sp.Mul):
                  # Check if this is a division (a * b^(-1))
                  # Convert to Rational if both are integers
                  args = expr.args
                  if len(args) == 2:
                      a, b = args
                      if isinstance(a, sp.Integer) and isinstance(b, sp.Pow):
                          if isinstance(b.base, sp.Integer) and b.exp == -1:
                              # This is division: a * b^(-1) ‚Üí Rational(a, b)
                              return sp.Rational(a, b.base)

                  # Not a simple division, recurse on args
                  new_args = [normalize_representation(arg) for arg in args]
                  return sp.Mul(*new_args)

              elif isinstance(expr, sp.Add):
                  new_args = [normalize_representation(arg) for arg in expr.args]
                  return sp.Add(*new_args)

              elif isinstance(expr, sp.Pow):
                  new_base = normalize_representation(expr.base)
                  new_exp = normalize_representation(expr.exp)
                  return sp.Pow(new_base, new_exp)

              else:
                  # For other types, return as-is
                  return expr

          # Normalize representations for both (fix division notation)
          answer_normalized_repr = normalize_representation(answer_expr)
          expected_normalized_repr = normalize_representation(expected_simplest)

          window.console.log(f"Answer (repr normalized): {answer_normalized_repr}")
          window.console.log(f"Answer (repr normalized) srepr: {sp.srepr(answer_normalized_repr)}")
          window.console.log(f"Expected (repr normalized): {expected_normalized_repr}")
          window.console.log(f"Expected (repr normalized) srepr: {sp.srepr(expected_normalized_repr)}")

          # Compare structures
          answer_srepr = sp.srepr(answer_normalized_repr)
          expected_srepr = sp.srepr(expected_normalized_repr)

          is_simplest = (answer_srepr == expected_srepr)

          window.console.log(f"Structural match: {is_simplest}")
          window.console.log(f"Answer srepr: {answer_srepr}")
          window.console.log(f"Expected srepr: {expected_srepr}")

          if is_simplest:
              # Answer is in simplest form!
              window.console.log("‚úÖ Answer is in simplest form")
              self.freestyle_finalized = True

              # Award credits if not already awarded
              if 'credits_awarded' not in self.freestyle_problem or not self.freestyle_problem['credits_awarded']:
                  difficulty = self.calculate_problem_difficulty(self.freestyle_problem["parsed"])
                  self.award_credits(self.freestyle_problem["latex"], self.freestyle_problem["parsed"], difficulty)
                  self.freestyle_problem['credits_awarded'] = True

                  if feedback_el:
                      feedback_el.innerHTML = f"<div style='color:#059669;background:#d1fae5;padding:12px;border-radius:6px;'>‚úÖ <strong>Simplified!</strong> Your answer is in simplest form.<br><br>üíé <strong>+{difficulty} credit{'s' if difficulty != 1 else ''} earned!</strong></div>"
              else:
                  if feedback_el:
                      feedback_el.innerHTML = "<div style='color:#059669;background:#d1fae5;padding:12px;border-radius:6px;'>‚úÖ <strong>Simplified!</strong> Your answer is in simplest form.</div>"

              if finalize_btn:
                  finalize_btn.disabled = True
                  finalize_btn.style.opacity = "0.5"
          else:
              # Not in simplest form - show structural comparison with operation counts
              window.console.log("‚ö†Ô∏è Answer is not in simplest form")

              # Count operations for both expressions
              def count_operations(expr):
                  """Count different types of operations in an expression"""
                  counts = {
                      'Add': 0,
                      'Mul': 0,
                      'Pow': 0,
                      'Log': 0,
                      'Exp': 0,
                      'Trig': 0,
                      'Hyperbolic': 0,
                      'Derivative': 0,
                      'Integral': 0,
                      'Limit': 0,
                      'Abs': 0,
                      'Sqrt': 0,
                      'Factorial': 0,
                      'Min/Max': 0,
                      'Floor/Ceil': 0,
                      'Complex': 0,
                      'Symbols': 0,
                      'Numbers': 0,
                      'Total': 0
                  }

                  def traverse(e):
                      # Handle matrices - traverse their elements
                      if isinstance(e, (sp.Matrix, sp.MutableDenseMatrix, sp.ImmutableDenseMatrix)):
                          for element in e:
                              traverse(element)
                          return

                      # Get the class name for string matching
                      class_name = type(e).__name__

                      # Basic arithmetic
                      if isinstance(e, sp.Add):
                          counts['Add'] += 1
                          counts['Total'] += 1
                      elif isinstance(e, sp.Mul):
                          counts['Mul'] += 1
                          counts['Total'] += 1
                      elif isinstance(e, sp.Pow):
                          counts['Pow'] += 1
                          counts['Total'] += 1

                      # Logarithms and exponentials (use class name)
                      elif class_name in ['log', 'ln']:
                          counts['Log'] += 1
                          counts['Total'] += 1
                      elif class_name == 'exp':
                          counts['Exp'] += 1
                          counts['Total'] += 1

                      # Trigonometric functions (use class name)
                      elif class_name in ['sin', 'cos', 'tan', 'cot', 'sec', 'csc', 
                                         'asin', 'acos', 'atan', 'acot', 'asec', 'acsc', 'atan2']:
                          counts['Trig'] += 1
                          counts['Total'] += 1

                      # Hyperbolic functions
                      elif class_name in ['sinh', 'cosh', 'tanh', 'coth', 'sech', 'csch',
                                         'asinh', 'acosh', 'atanh', 'acoth', 'asech', 'acsch']:
                          counts['Hyperbolic'] += 1
                          counts['Total'] += 1

                      # Calculus operations
                      elif isinstance(e, sp.Derivative):
                          counts['Derivative'] += 1
                          counts['Total'] += 1
                      elif isinstance(e, sp.Integral):
                          counts['Integral'] += 1
                          counts['Total'] += 1
                      elif isinstance(e, sp.Limit):
                          counts['Limit'] += 1
                          counts['Total'] += 1

                      # Absolute value and sqrt
                      elif isinstance(e, sp.Abs):
                          counts['Abs'] += 1
                          counts['Total'] += 1
                      elif class_name == 'sqrt':
                          counts['Sqrt'] += 1
                          counts['Total'] += 1

                      # Factorial
                      elif class_name in ['factorial', 'factorial2', 'binomial', 'RisingFactorial', 'FallingFactorial']:
                          counts['Factorial'] += 1
                          counts['Total'] += 1

                      # Min/Max
                      elif class_name in ['Min', 'Max']:
                          counts['Min/Max'] += 1
                          counts['Total'] += 1

                      # Floor/Ceiling
                      elif class_name in ['floor', 'ceiling', 'frac']:
                          counts['Floor/Ceil'] += 1
                          counts['Total'] += 1

                      # Complex number functions
                      elif class_name in ['re', 'im', 'conjugate', 'arg', 'Abs']:
                          counts['Complex'] += 1
                          counts['Total'] += 1

                      # Symbols and numbers (including Rational)
                      elif isinstance(e, sp.Symbol):
                          counts['Symbols'] += 1
                      elif isinstance(e, (sp.Integer, sp.Float, sp.Rational, sp.Number)):
                          counts['Numbers'] += 1

                      if hasattr(e, 'args'):
                          for arg in e.args:
                              traverse(arg)

                  traverse(expr)
                  return counts

              # Count using the representation-normalized versions
              user_counts = count_operations(answer_normalized_repr)
              expected_counts = count_operations(expected_normalized_repr)

              if feedback_el:
                  # Build comparison table
                  comparison_html = """
                  <div style='color:#f59e0b;background:#fef3c7;padding:16px;border-radius:6px;'>
                      <div style='font-weight:700;font-size:16px;margin-bottom:12px;'>‚ö†Ô∏è Not in simplest form!</div>

                      <div style='margin-bottom:12px;font-size:14px;color:#92400e;'>
                          Your answer has a different structure than the simplest form. Compare the operation counts:
                      </div>

                      <table style='width:100%;border-collapse:collapse;margin-bottom:12px;background:white;border-radius:6px;overflow:hidden;'>
                          <thead>
                              <tr style='background:#fbbf24;color:#78350f;'>
                                  <th style='padding:10px;text-align:left;font-weight:600;border-bottom:2px solid #f59e0b;'>Operation Type</th>
                                  <th style='padding:10px;text-align:center;font-weight:600;border-bottom:2px solid #f59e0b;'>Your Answer</th>
                                  <th style='padding:10px;text-align:center;font-weight:600;border-bottom:2px solid #f59e0b;'>Expected</th>
                              </tr>
                          </thead>
                          <tbody>
                  """

                  # Add rows for each operation type
                  operations = [
                      ('Additions (+)', 'Add'),
                      ('Multiplications (√ó)', 'Mul'),
                      ('Powers (^)', 'Pow'),
                      ('Square Roots (‚àö)', 'Sqrt'),
                      ('Logarithms (log, ln)', 'Log'),
                      ('Exponentials (e^x)', 'Exp'),
                      ('Trigonometric (sin, cos, tan, etc.)', 'Trig'),
                      ('Hyperbolic (sinh, cosh, etc.)', 'Hyperbolic'),
                      ('Derivatives (d/dx)', 'Derivative'),
                      ('Integrals (‚à´)', 'Integral'),
                      ('Limits (lim)', 'Limit'),
                      ('Absolute Values (|x|)', 'Abs'),
                      ('Factorials (n!)', 'Factorial'),
                      ('Min/Max', 'Min/Max'),
                      ('Floor/Ceiling', 'Floor/Ceil'),
                      ('Complex (re, im, conjugate)', 'Complex'),
                      ('Symbols (x, y, etc.)', 'Symbols'),
                      ('Numbers', 'Numbers'),
                      ('Total Operations', 'Total')
                  ]

                  for label, key in operations:
                      user_val = user_counts[key]
                      expected_val = expected_counts[key]

                      # Skip rows where both are 0 (except Total and basic operations)
                      if user_val == 0 and expected_val == 0 and key not in ['Total', 'Symbols', 'Numbers']:
                          continue

                      # Highlight differences
                      if user_val != expected_val:
                          row_style = 'background:#fef3c7;font-weight:600;'
                          user_cell_style = 'color:#dc2626;'
                          expected_cell_style = 'color:#059669;'
                      else:
                          row_style = 'background:white;'
                          user_cell_style = ''
                          expected_cell_style = ''

                      if key == 'Total':
                          row_style += 'border-top:2px solid #f59e0b;font-weight:700;'

                      comparison_html += f"""
                          <tr style='{row_style}'>
                              <td style='padding:10px;border-bottom:1px solid #fde68a;'>{label}</td>
                              <td style='padding:10px;text-align:center;border-bottom:1px solid #fde68a;{user_cell_style}'>{user_val}</td>
                              <td style='padding:10px;text-align:center;border-bottom:1px solid #fde68a;{expected_cell_style}'>{expected_val}</td>
                          </tr>
                      """

                  comparison_html += """
                          </tbody>
                      </table>

                      <div style='font-size:13px;color:#78350f;background:#fffbeb;padding:10px;border-radius:4px;border-left:3px solid #f59e0b;'>
                          üí° <strong>Tip:</strong> The simplest form has fewer operations. Look for common factors to factor out, or terms to combine.
                      </div>
                  </div>
                  """

                  feedback_el.innerHTML = comparison_html

      except Exception as e:
          window.console.error(f"Finalize error: {e}")
          import traceback
          window.console.error(traceback.format_exc())
          window.alert(f"‚ö†Ô∏è Error: {e}")

    def freestyle_giveup(self, event):
        """Show the solution when user gives up"""
        window.console.log("=== freestyle_giveup called ===")

        if not self.freestyle_problem:
            window.alert("‚ö†Ô∏è Please set a problem first")
            return

        if self.freestyle_correct:
            window.alert("‚úÖ You already solved this problem!")
            return

        # Check if user has enough credits
        difficulty = self.calculate_problem_difficulty(self.freestyle_problem["parsed"])
        credits_needed = difficulty
        
        if self.credit_balance < credits_needed:
            shortage = credits_needed - self.credit_balance
            window.alert(f"‚ö†Ô∏è Not enough credits!\n\nYou need {credits_needed} credit{'s' if credits_needed != 1 else ''} to reveal this solution (Difficulty: {difficulty})\n\nYou have: {self.credit_balance} credit{'s' if self.credit_balance != 1 else ''}\nYou need: {shortage} more credit{'s' if shortage != 1 else ''}\n\nüí° Solve more problems of similar difficulty to earn credits!")
            return

        # Confirm spending credits
        if not window.confirm(f"üíé Use {credits_needed} credit{'s' if credits_needed != 1 else ''} to reveal the solution?\n\n(Difficulty: {difficulty})\nYour balance: {self.credit_balance} ‚Üí {self.credit_balance - credits_needed}"):
            return

        try:
            import sympy as sp

            # Spend the credits
            if not self.spend_credits(credits_needed, self.freestyle_problem["latex"]):
                window.alert("‚ö†Ô∏è Unable to spend credits")
                return

            # Get the solution by normalizing the problem
            solution_expr = self.math_parser.normalize_expr(self.freestyle_problem["parsed"])
            solution_latex = sp.latex(solution_expr)

            window.console.log(f"Solution: {solution_expr}")
            window.console.log(f"Solution LaTeX: {solution_latex}")

            # Display the solution
            feedback_el = document.querySelector("#freestyleFeedback")
            if feedback_el:
                feedback_el.innerHTML = f"""
                <div style='color:#6366f1;background:#e0e7ff;padding:16px;border-radius:8px;border-left:4px solid #6366f1;'>
                    <div style='font-weight:700;font-size:16px;margin-bottom:12px;'>üí° Solution:</div>
                    <div style='font-size:20px;margin-bottom:8px;'>$$\\displaystyle {solution_latex}$$</div>
                    <div style='font-size:14px;color:#4338ca;margin-top:8px;'>You can study this solution and try a similar problem next time!</div>
                </div>
                """

                # Re-render MathJax
                if hasattr(window, 'MathJax') and hasattr(window.MathJax, 'typesetPromise'):
                    window.MathJax.typesetPromise([feedback_el])

            # Disable submit and give-up buttons
            submit_btn = document.querySelector("#freestyleSubmit")
            if submit_btn:
                submit_btn.disabled = True
                submit_btn.style.opacity = "0.5"

            giveup_btn = document.querySelector("#freestyleGiveUp")
            if giveup_btn:
                giveup_btn.disabled = True
                giveup_btn.style.opacity = "0.5"

            # Mark as finalized (can't submit anymore)
            self.freestyle_finalized = True

        except Exception as e:
            window.console.error(f"Give up error: {e}")
            import traceback
            window.console.error(traceback.format_exc())
            window.alert(f"‚ö†Ô∏è Error showing solution: {e}")

    def freestyle_reset(self, event):
        """Reset the freestyle problem"""
        window.console.log("=== freestyle_reset called ===")

        self.freestyle_problem = None
        self.freestyle_attempts = []
        self.freestyle_correct = False
        self.freestyle_finalized = False

        # Clear fields
        if self.freestyle_problem_mf:
            self.freestyle_problem_mf.latex("")

        if self.freestyle_answer_mf:
            self.freestyle_answer_mf.latex("")

        # Hide solve area
        solve_area = document.querySelector("#freestyleSolveArea")
        if solve_area:
            solve_area.style.display = "none"

        # Clear feedback
        feedback_el = document.querySelector("#freestyleFeedback")
        if feedback_el:
            feedback_el.innerHTML = ""

        history_el = document.querySelector("#freestyleHistory")
        if history_el:
            history_el.innerHTML = ""

        # Re-enable submit and give-up buttons
        submit_btn = document.querySelector("#freestyleSubmit")
        if submit_btn:
            submit_btn.disabled = False
            submit_btn.style.opacity = "1"

        giveup_btn = document.querySelector("#freestyleGiveUp")
        if giveup_btn:
            giveup_btn.textContent = "Give Up (Show Solution)"
            giveup_btn.disabled = False
            giveup_btn.style.opacity = "1"
            giveup_btn.title = ""

        window.alert("‚úÖ Problem reset. Enter a new problem!")

    def _update_freestyle_history(self):
      """Update the attempt history display"""
      history_el = document.querySelector("#freestyleHistory")
      if not history_el:
          return

      if not self.freestyle_attempts:
          history_el.innerHTML = ""
          return

      html = "<div style='background:#f8fafc;padding:12px;border-radius:8px;'>"
      html += "<div style='font-weight:700;margin-bottom:8px;'>Attempt History:</div>"

      for idx, attempt in enumerate(self.freestyle_attempts):
          status = "‚úÖ" if attempt["correct"] else "‚ùå"
          color = "#059669" if attempt["correct"] else "#b91c1c"
          bg = "#d1fae5" if attempt["correct"] else "#fee2e2"

          attempt_latex = attempt['latex']

          # Check if this is a row operation (has pipe operators)
          is_row_op = (
              '|R_' in attempt_latex or 
              '|\\mathrm{R}_' in attempt_latex or
              '\\left|R_' in attempt_latex or
              '\\left|\\mathrm{R}_' in attempt_latex or
              '\\right|' in attempt_latex
          )

          # Check if contains matrices (multiple patterns)
          has_matrix = (
              '[[' in attempt_latex or 
              '\\left[\\left[' in attempt_latex or 
              '\\begin{matrix}' in attempt_latex or
              '\\begin{bmatrix}' in attempt_latex or
              '\\begin{pmatrix}' in attempt_latex
          )

          # Handle row operations specially: convert matrix part, keep operation part
          if is_row_op and has_matrix:
              try:
                  import sympy as sp
                  import re

                  # Split at the pipe: matrix part | operation part
                  match = re.match(r'(.+?)(\\left\|.*?\\right\|)', attempt_latex)

                  if match:
                      matrix_part = match.group(1)
                      operation_part = match.group(2)

                      window.console.log(f"Attempt {idx + 1} - Split row operation:")
                      window.console.log(f"  Matrix part: {matrix_part}")
                      window.console.log(f"  Operation part: {operation_part}")

                      # Convert only the matrix part
                      parsed_matrix = self.math_parser.parse_latex(matrix_part)
                      converted_matrix = self._convert_latex_preserve_order(parsed_matrix)

                      # Combine: converted matrix + original operation
                      display_latex = converted_matrix + operation_part

                      window.console.log(f"  ‚úÖ Combined: {display_latex}")
                  else:
                      # Fallback if regex doesn't match
                      window.console.log(f"Attempt {idx + 1} - Regex didn't match, using original")
                      display_latex = attempt_latex

              except Exception as e:
                  window.console.error(f"Row operation conversion error in attempt {idx + 1}: {e}")
                  import traceback
                  window.console.error(traceback.format_exc())
                  display_latex = attempt_latex

          # Regular matrices (not row operations)
          elif has_matrix and not is_row_op:
              try:
                  import sympy as sp

                  window.console.log(f"üìù Converting attempt {idx + 1}: {attempt_latex}")

                  # Parse the expression
                  parsed = self.math_parser.parse_latex(attempt_latex)

                  # Convert using part-by-part strategy
                  display_latex = self._convert_latex_preserve_order(parsed)

                  window.console.log(f"   ‚úÖ Converted to: {display_latex}")

              except Exception as e:
                  # If conversion fails, use original LaTeX
                  window.console.error(f"‚ùå LaTeX conversion error in attempt {idx + 1}: {e}")
                  import traceback
                  window.console.error(traceback.format_exc())
                  display_latex = attempt_latex
          else:
              # No matrices, use original LaTeX
              display_latex = attempt_latex
              window.console.log(f"Attempt {idx + 1} - No conversion needed")

          html += f"""
          <div style='background:{bg};color:{color};padding:8px;border-radius:4px;margin-bottom:6px;'>
              <strong>{status} Attempt {idx + 1}:</strong> 
              <div style='overflow-x:auto;'>$$\\displaystyle {display_latex}$$</div>
          </div>
          """

      html += "</div>"
      history_el.innerHTML = html

      # Render MathJax
      if hasattr(window, 'MathJax') and hasattr(window.MathJax, 'typesetPromise'):
          window.MathJax.typesetPromise([history_el])

    def _convert_latex_preserve_order(self, expr):
        """Convert SymPy expression to LaTeX, preserving order and converting matrices properly"""
        import sympy as sp

        # Matrix: convert to proper LaTeX format
        if isinstance(expr, (sp.Matrix, sp.MutableDenseMatrix, sp.ImmutableDenseMatrix)):
            return sp.latex(expr)

        # Simple types: direct conversion
        elif isinstance(expr, sp.Symbol):
            return str(expr)

        elif isinstance(expr, (sp.Integer, sp.Rational)):
            return sp.latex(expr)

        elif isinstance(expr, sp.Float):
            return sp.latex(expr)

        # Addition: preserve order of terms
        elif isinstance(expr, sp.Add):
            parts = []
            for i, arg in enumerate(expr.args):
                arg_latex = self._convert_latex_preserve_order(arg)

                # Check if this term is negative
                if isinstance(arg, sp.Mul) and len(arg.args) > 0:
                    if isinstance(arg.args[0], sp.Integer) and arg.args[0] < 0:
                        # Negative term
                        parts.append(arg_latex)
                        continue

                # Add + for non-first positive terms
                if i > 0 and not arg_latex.startswith("-"):
                    parts.append("+" + arg_latex)
                else:
                    parts.append(arg_latex)

            return " ".join(parts)

        # Multiplication: preserve order of factors
        elif isinstance(expr, sp.Mul):
            parts = []
            for arg in expr.args:
                arg_latex = self._convert_latex_preserve_order(arg)

                # Add parentheses if needed
                if isinstance(arg, sp.Add):
                    arg_latex = f"\\left({arg_latex}\\right)"

                parts.append(arg_latex)

            # Use \cdot for multiplication
            return " \\cdot ".join(parts)

        # Power: base^exponent
        elif isinstance(expr, sp.Pow):
            base = self._convert_latex_preserve_order(expr.base)
            exp = self._convert_latex_preserve_order(expr.exp)

            # Add parentheses to base if needed
            if isinstance(expr.base, (sp.Add, sp.Mul)):
                base = f"\\left({base}\\right)"

            # Handle special cases
            if expr.exp == sp.Rational(1, 2):
                return f"\\sqrt{{{base}}}"
            elif isinstance(expr.exp, sp.Rational) and expr.exp.p == 1:
                return f"\\sqrt[{expr.exp.q}]{{{base}}}"
            else:
                return f"{{{base}}}^{{{exp}}}"

        # Derivative
        elif isinstance(expr, sp.Derivative):
            func_latex = self._convert_latex_preserve_order(expr.expr)
            var_latex = self._convert_latex_preserve_order(expr.variables[0])
            return f"\\frac{{d}}{{d{var_latex}}}\\left({func_latex}\\right)"

        # Integral
        elif isinstance(expr, sp.Integral):
            func_latex = self._convert_latex_preserve_order(expr.function)
            var_latex = self._convert_latex_preserve_order(expr.variables[0])
            return f"\\int {func_latex} \\, d{var_latex}"

        # Limit
        elif isinstance(expr, sp.Limit):
            func_latex = self._convert_latex_preserve_order(expr.args[0])
            var_latex = self._convert_latex_preserve_order(expr.args[1])
            point_latex = self._convert_latex_preserve_order(expr.args[2])
            return f"\\lim_{{{var_latex} \\to {point_latex}}} {func_latex}"

        # Trigonometric and other functions
        elif isinstance(expr, sp.Function):
            func_name = type(expr).__name__
            args_latex = ", ".join([self._convert_latex_preserve_order(arg) for arg in expr.args])

            # Map function names to LaTeX
            func_map = {
                'sin': '\\sin', 'cos': '\\cos', 'tan': '\\tan',
                'cot': '\\cot', 'sec': '\\sec', 'csc': '\\csc',
                'asin': '\\arcsin', 'acos': '\\arccos', 'atan': '\\arctan',
                'sinh': '\\sinh', 'cosh': '\\cosh', 'tanh': '\\tanh',
                'log': '\\log', 'ln': '\\ln', 'exp': '\\exp',
                'sqrt': '\\sqrt'
            }

            latex_func = func_map.get(func_name, func_name)

            if func_name == 'sqrt':
                return f"\\sqrt{{{args_latex}}}"
            else:
                return f"{latex_func}\\left({args_latex}\\right)"

        # Absolute value
        elif isinstance(expr, sp.Abs):
            arg_latex = self._convert_latex_preserve_order(expr.args[0])
            return f"\\left|{arg_latex}\\right|"

        # Factorial
        elif hasattr(expr, 'is_factorial') or type(expr).__name__ == 'factorial':
            arg_latex = self._convert_latex_preserve_order(expr.args[0])
            return f"{arg_latex}!"

        # Default: use SymPy's latex (fallback)
        else:
            return sp.latex(expr)


    # ========================================
    # CREDIT SYSTEM METHODS
    # ========================================
    
    def load_credit_data(self):
        """Load credit data from localStorage"""
        try:
            storage = window.localStorage
            credit_data_str = storage.getItem("freestyle_credit_data")
            
            if credit_data_str:
                credit_data = json.loads(credit_data_str)
                self.credit_balance = credit_data.get("balance", 0)
                self.credit_earned_total = credit_data.get("earned_total", 0)
                self.credit_spent_total = credit_data.get("spent_total", 0)
                self.credit_history = credit_data.get("history", [])
                self.freestyle_solved_problems = credit_data.get("solved_problems", [])
                
                window.console.log(f"‚úÖ Loaded credit data: {self.credit_balance} credits")
            else:
                window.console.log("‚ÑπÔ∏è No credit data found, starting fresh")
                
            self.update_credit_display()
            
        except Exception as e:
            window.console.error(f"Error loading credit data: {e}")

    def save_credit_data(self):
        """Save credit data to localStorage"""
        try:
            storage = window.localStorage
            credit_data = {
                "balance": self.credit_balance,
                "earned_total": self.credit_earned_total,
                "spent_total": self.credit_spent_total,
                "history": self.credit_history,
                "solved_problems": self.freestyle_solved_problems
            }
            storage.setItem("freestyle_credit_data", json.dumps(credit_data))
            window.console.log(f"‚úÖ Saved credit data: {self.credit_balance} credits")
        except Exception as e:
            window.console.error(f"Error saving credit data: {e}")

    def calculate_problem_difficulty(self, parsed_expr):
        """Calculate problem difficulty (1-5) based on expression complexity"""
        import sympy as sp

        try:
            difficulty = 1  # Base difficulty

            # Count all operation types
            def count_operations(expr):
                """Count different types of operations"""
                counts = {
                    'Add': 0, 'Mul': 0, 'Pow': 0, 'Sqrt': 0,
                    'Log': 0, 'Exp': 0, 'Trig': 0, 'Hyperbolic': 0,
                    'Derivative': 0, 'Integral': 0, 'Limit': 0,
                    'Abs': 0, 'Factorial': 0, 'Complex': 0,
                    'Total': 0
                }

                def traverse(e):
                    class_name = type(e).__name__

                    if isinstance(e, sp.Add):
                        counts['Add'] += 1
                        counts['Total'] += 1
                    elif isinstance(e, sp.Mul):
                        counts['Mul'] += 1
                        counts['Total'] += 1
                    elif isinstance(e, sp.Pow):
                        counts['Pow'] += 1
                        counts['Total'] += 1
                    elif class_name == 'sqrt':
                        counts['Sqrt'] += 1
                        counts['Total'] += 1
                    elif class_name in ['log', 'ln']:
                        counts['Log'] += 1
                        counts['Total'] += 1
                    elif class_name == 'exp':
                        counts['Exp'] += 1
                        counts['Total'] += 1
                    elif class_name in ['sin', 'cos', 'tan', 'cot', 'sec', 'csc', 
                                       'asin', 'acos', 'atan', 'acot', 'asec', 'acsc', 'atan2']:
                        counts['Trig'] += 1
                        counts['Total'] += 1
                    elif class_name in ['sinh', 'cosh', 'tanh', 'coth', 'sech', 'csch',
                                       'asinh', 'acosh', 'atanh', 'acoth', 'asech', 'acsch']:
                        counts['Hyperbolic'] += 1
                        counts['Total'] += 1
                    elif isinstance(e, sp.Derivative):
                        counts['Derivative'] += 1
                        counts['Total'] += 1
                    elif isinstance(e, sp.Integral):
                        counts['Integral'] += 1
                        counts['Total'] += 1
                    elif isinstance(e, sp.Limit):
                        counts['Limit'] += 1
                        counts['Total'] += 1
                    elif isinstance(e, sp.Abs):
                        counts['Abs'] += 1
                        counts['Total'] += 1
                    elif class_name in ['factorial', 'factorial2', 'binomial']:
                        counts['Factorial'] += 1
                        counts['Total'] += 1
                    elif class_name in ['re', 'im', 'conjugate', 'arg']:
                        counts['Complex'] += 1
                        counts['Total'] += 1

                    if hasattr(e, 'args'):
                        for arg in e.args:
                            traverse(arg)

                traverse(expr)
                return counts

            ops = count_operations(parsed_expr)

            # Calculus operations - highest difficulty boost
            if ops['Limit'] > 0:
                difficulty += 4  # Limits are very difficult
            elif ops['Integral'] > 0:
                difficulty += 3  # Integrals are difficult
            elif ops['Derivative'] > 0:
                difficulty += 2  # Derivatives are moderately difficult

            # Advanced functions - significant difficulty
            if ops['Hyperbolic'] > 0:
                difficulty += 2  # Hyperbolic functions are advanced
            if ops['Complex'] > 0:
                difficulty += 2  # Complex operations are advanced

            # Standard functions - moderate difficulty
            if ops['Trig'] > 0:
                difficulty += 1  # Trigonometric functions
            if ops['Log'] > 0:
                difficulty += 1  # Logarithms
            if ops['Exp'] > 0:
                difficulty += 1  # Exponentials

            # Special operations
            if ops['Factorial'] > 0:
                difficulty += 1  # Factorials
            if ops['Abs'] > 0:
                difficulty += 1  # Absolute values

            # Powers and roots
            if ops['Pow'] > 2:  # More than 2 powers
                difficulty += 1
            if ops['Sqrt'] > 0:
                difficulty += 1

            # Total operation count matters
            total_ops = ops['Total']
            if total_ops > 10:
                difficulty += 2
            elif total_ops > 6:
                difficulty += 1
            elif total_ops > 3:
                difficulty += 1

            # Expression depth/nesting
            depth = self._expr_depth(parsed_expr)
            if depth > 6:
                difficulty += 2
            elif depth > 4:
                difficulty += 1
            elif depth > 2:
                difficulty += 1

            # Cap at 5
            difficulty = min(difficulty, 5)
            # Ensure minimum of 1
            difficulty = max(difficulty, 1)

            window.console.log(f"Difficulty calculation: {difficulty} (Total ops: {total_ops}, Depth: {depth})")
            window.console.log(f"Operation breakdown: Limit={ops['Limit']}, Integral={ops['Integral']}, Derivative={ops['Derivative']}, Trig={ops['Trig']}, Log={ops['Log']}, Exp={ops['Exp']}")

            return difficulty

        except Exception as e:
            window.console.error(f"Error calculating difficulty: {e}")
            return 2  # Default to medium difficulty

    def _expr_depth(self, expr):
        """Calculate the nesting depth of an expression"""
        import sympy as sp
        
        if not hasattr(expr, 'args') or not expr.args:
            return 1
        
        return 1 + max(self._expr_depth(arg) for arg in expr.args)

    def get_problem_canonical_form(self, parsed_expr):
        """Get a canonical string representation of a problem for duplicate detection"""
        import sympy as sp
        
        try:
            # Normalize and simplify the expression
            normalized = self.math_parser.normalize_expr(parsed_expr)
            simplified = sp.simplify(normalized)
            
            # Convert to a canonical string representation
            # Use srepr for structural representation
            canonical = sp.srepr(simplified)
            
            window.console.log(f"Canonical form: {canonical}")
            return canonical
            
        except Exception as e:
            window.console.error(f"Error getting canonical form: {e}")
            # Fallback to string representation
            return str(parsed_expr)

    def is_problem_solved_before(self, parsed_expr):
        """Check if this problem has been solved before"""
        try:
            canonical = self.get_problem_canonical_form(parsed_expr)
            
            # Check against all solved problems
            for solved in self.freestyle_solved_problems:
                if solved.get("canonical_form") == canonical:
                    window.console.log(f"‚ö†Ô∏è Problem already solved before")
                    return True
            
            window.console.log(f"‚úÖ New problem, not solved before")
            return False
            
        except Exception as e:
            window.console.error(f"Error checking if problem solved: {e}")
            # If we can't check, assume it's new
            return False

    def award_credits(self, problem_latex, parsed_expr, difficulty):
        """Award credits for solving a problem"""
        # Award credits equal to difficulty
        credits_earned = difficulty
        
        self.credit_balance += credits_earned
        self.credit_earned_total += credits_earned
        
        # Record transaction
        import datetime
        timestamp = datetime.datetime.now().isoformat()
        
        self.credit_history.append({
            "type": "earned",
            "amount": credits_earned,
            "difficulty": difficulty,
            "problem": problem_latex,
            "timestamp": timestamp
        })
        
        # Record solved problem
        canonical_form = self.get_problem_canonical_form(parsed_expr)
        self.freestyle_solved_problems.append({
            "problem": problem_latex,
            "canonical_form": canonical_form,
            "difficulty": difficulty,
            "credits_earned": credits_earned,
            "timestamp": timestamp
        })
        
        # Save and update display
        self.save_credit_data()
        self.update_credit_display()
        
        # Show notification
        self._show_credit_notification(f"+{credits_earned} credit{'s' if credits_earned != 1 else ''}", "#10b981")
        
        window.console.log(f"‚úÖ Awarded {credits_earned} credits for difficulty {difficulty} problem")

    def spend_credits(self, amount, problem_latex):
        """Spend credits to reveal solution"""
        if self.credit_balance < amount:
            return False
        
        self.credit_balance -= amount
        self.credit_spent_total += amount
        
        # Record transaction
        import datetime
        timestamp = datetime.datetime.now().isoformat()
        
        self.credit_history.append({
            "type": "spent",
            "amount": amount,
            "problem": problem_latex,
            "timestamp": timestamp
        })
        
        # Save and update display
        self.save_credit_data()
        self.update_credit_display()
        
        window.console.log(f"üíé Spent {amount} credits")
        return True

    def update_credit_display(self):
        """Update the credit display UI"""
        balance_el = document.querySelector("#creditBalance")
        if balance_el:
            balance_el.textContent = str(self.credit_balance)
        
        earned_el = document.querySelector("#creditEarned")
        if earned_el:
            earned_el.textContent = str(self.credit_earned_total)
        
        spent_el = document.querySelector("#creditSpent")
        if spent_el:
            spent_el.textContent = str(self.credit_spent_total)

    def _show_credit_notification(self, message, color):
        """Show a brief notification about credit change"""
        notification = document.createElement("div")
        notification.style.cssText = f"""
            position: fixed;
            top: 80px;
            right: 20px;
            background: {color};
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            font-weight: 600;
            font-size: 16px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            z-index: 10000;
            animation: slideInRight 0.3s ease-out;
        """
        notification.textContent = f"üíé {message}"
        document.body.appendChild(notification)
        
        def remove_notification():
            notification.style.opacity = "0"
            notification.style.transition = "opacity 0.3s"
            window.setTimeout(create_proxy(lambda: notification.remove()), 300)
        
        window.setTimeout(create_proxy(remove_notification), 2000)

    def show_credit_history_modal(self, event):
      """Show the credit history modal"""
      modal = document.querySelector("#creditHistoryModal")
      if not modal:
          return

      # Populate history
      content = document.querySelector("#creditHistoryContent")
      if content:
          if not self.credit_history:
              content.innerHTML = """
                  <div style='text-align:center;padding:40px;color:#64748b;'>
                      <div style='font-size:48px;margin-bottom:16px;'>üìä</div>
                      <div style='font-size:16px;font-weight:600;margin-bottom:8px;'>No Credit History Yet</div>
                      <div style='font-size:14px;'>Start solving problems to earn credits!</div>
                  </div>
              """
          else:
              html = "<div style='display:flex;flex-direction:column;gap:8px;'>"

              # Show in reverse order (most recent first)
              for i in range(len(self.credit_history) - 1, -1, -1):
                  transaction = self.credit_history[i]
                  trans_type = transaction["type"]
                  amount = transaction["amount"]
                  problem = transaction.get("problem", "")
                  timestamp = transaction.get("timestamp", "")

                  # Format timestamp
                  try:
                      import datetime
                      dt = datetime.datetime.fromisoformat(timestamp)
                      time_str = dt.strftime("%m/%d/%Y %H:%M")
                  except:
                      time_str = timestamp[:16] if len(timestamp) > 16 else timestamp

                  if trans_type == "earned":
                      difficulty = transaction.get("difficulty", "?")
                      icon = "‚úÖ"
                      color = "#10b981"
                      bg = "#d1fae5"
                      desc = f"Solved (Difficulty: {difficulty})"
                  else:
                      icon = "üí°"
                      color = "#f59e0b"
                      bg = "#fef3c7"
                      desc = "Revealed solution"

                  # Check if this is a row operation
                  is_row_op = (
                      '|R_' in problem or 
                      '|\\mathrm{R}_' in problem or
                      '\\left|R_' in problem or
                      '\\right|' in problem
                  )

                  # Check if contains matrices
                  has_matrix = (
                      '[[' in problem or 
                      '\\left[\\left[' in problem or 
                      '\\begin{matrix}' in problem or
                      '\\begin{bmatrix}' in problem or
                      '\\begin{pmatrix}' in problem
                  )

                  # Handle row operations specially: convert matrix part, keep operation part
                  if is_row_op and has_matrix:
                      try:
                          import sympy as sp
                          import re

                          # Split at the pipe: matrix part | operation part
                          # Pattern: capture everything before |R_ or |\mathrm{R}_
                          match = re.match(r'(.+?)(\\left\|.*?\\right\|)', problem)

                          if match:
                              matrix_part = match.group(1)
                              operation_part = match.group(2)

                              window.console.log(f"Split row operation:")
                              window.console.log(f"  Matrix part: {matrix_part}")
                              window.console.log(f"  Operation part: {operation_part}")

                              # Convert only the matrix part
                              parsed_matrix = self.math_parser.parse_latex(matrix_part)
                              converted_matrix = self._convert_latex_preserve_order(parsed_matrix)

                              # Combine: converted matrix + original operation
                              problem_display = converted_matrix + operation_part

                              window.console.log(f"  Combined result: {problem_display}")
                          else:
                              # Fallback if regex doesn't match
                              window.console.log("Regex didn't match, using original")
                              problem_display = problem

                      except Exception as e:
                          window.console.error(f"Row operation conversion error: {e}")
                          import traceback
                          window.console.error(traceback.format_exc())
                          problem_display = problem

                  # Regular matrices (not row operations)
                  elif has_matrix and not is_row_op:
                      try:
                          import sympy as sp
                          parsed_problem = self.math_parser.parse_latex(problem)
                          problem_display = self._convert_latex_preserve_order(parsed_problem)
                          window.console.log(f"Credit history - converted: {problem} ‚Üí {problem_display}")
                      except Exception as e:
                          window.console.error(f"Credit history conversion error: {e}")
                          import traceback
                          window.console.error(traceback.format_exc())
                          problem_display = problem
                  else:
                      # No matrices, use original
                      problem_display = problem

                  html += f"""
                  <div style='background:{bg};padding:12px;border-radius:8px;border-left:4px solid {color};'>
                      <div style='display:flex;justify-content:space-between;align-items:start;margin-bottom:6px;'>
                          <div style='font-weight:600;color:{color};'>
                              {icon} {'+' if trans_type == 'earned' else '-'}{amount} credit{'s' if amount != 1 else ''}
                          </div>
                          <div style='font-size:12px;color:#64748b;'>{time_str}</div>
                      </div>
                      <div style='font-size:13px;color:#475569;margin-bottom:4px;'>{desc}</div>
                      <div style='font-size:13px;color:#64748b;padding:6px;background:white;border-radius:4px;overflow-x:auto;max-width:100%;'>
                          $$\\displaystyle {problem_display}$$
                      </div>
                  </div>
                  """

              html += "</div>"
              content.innerHTML = html

              # Render MathJax for all the problems
              if hasattr(window, 'MathJax') and hasattr(window.MathJax, 'typesetPromise'):
                  window.MathJax.typesetPromise([content])

      # Show modal
      modal.style.display = "flex"


    def close_credit_history_modal(self, event):
        """Close the credit history modal"""
        modal = document.querySelector("#creditHistoryModal")
        if modal:
            modal.style.display = "none"

    def _show_limit_validation_error_popup(self, error_msg):
      """Show limit validation error popup with extensive examples"""
      import sympy as sp

      # Valid examples - limits that evaluate to finite numbers
      valid_examples = [
          (r"\lim_{x\to 0}\frac{\sin(x)}{x}", "Evaluates to 1"),
          (r"\lim_{x\to 0}\frac{1-\cos(x)}{x^2}", "Evaluates to 1/2"),
          (r"\lim_{x\to 0}\frac{e^x-1}{x}", "Evaluates to 1"),
          (r"\lim_{x\to 2}(x^2 + 1)", "Evaluates to 5"),
          (r"\lim_{x\to 0}\frac{x^2}{2}", "Evaluates to 0"),
          (r"\lim_{x\to 1}\frac{x^2-1}{x-1}", "Evaluates to 2"),
          (r"\lim_{x\to 0}\frac{\tan(x)}{x}", "Evaluates to 1"),
          (r"\lim_{x\to 0}\frac{\ln(1+x)}{x}", "Evaluates to 1"),
          (r"\lim_{x\to\infty}\frac{3x^2+2x}{x^2+1}", "Evaluates to 3"),
          (r"\lim_{x\to\infty}\frac{5x+3}{2x+1}", "Evaluates to 5/2"),
      ]

      # Invalid examples - limits that don't work
      invalid_examples = [
          (r"\lim_{x\to 0}\frac{1}{x^2}", "Goes to infinity", "The limit approaches ‚àû, not a finite number"),
          (r"\lim_{x\to 0}\frac{1}{x}", "Left/right differ", "Left limit is -‚àû, right limit is +‚àû"),
          (r"\lim_{x\to 0}\sin\left(\frac{1}{x}\right)", "Oscillates", "Oscillates infinitely between -1 and 1"),
          (r"\lim_{x\to\infty}x", "Goes to infinity", "The limit is ‚àû, not a finite value"),
          (r"\lim_{x\to\infty}e^x", "Goes to infinity", "Exponential growth to ‚àû"),
          (r"\lim_{x\to\infty}\sin(x)", "Oscillates", "Does not converge to a single value"),
          (r"\lim_{x\to 1}\frac{1}{x-1}", "Goes to infinity", "Vertical asymptote at x=1"),
          (r"\lim_{x\to 0^+}\ln(x)", "Goes to -infinity", "Logarithm approaches -‚àû"),
          (r"\lim_{x\to\infty}x\sin(x)", "Oscillates unbounded", "Oscillates with increasing amplitude"),
          (r"\lim_{x\to 0}\frac{\sin(x)}{x^2}", "Goes to infinity", "Denominator vanishes faster than numerator"),
          (r"\lim_{x\to\infty}\cos(x)", "Oscillates", "Oscillates between -1 and 1 forever"),
          (r"\lim_{x\to 0^+}\frac{1}{\sqrt{x}}", "Goes to infinity", "Approaches ‚àû as x‚Üí0+"),
      ]

      # Build HTML for valid examples
      valid_html = ""
      for latex, desc in valid_examples:
          valid_html += f"""
          <div style="margin-bottom:8px;padding:8px;background:#f0fdf4;border-left:3px solid #10b981;border-radius:4px;">
              <div style="margin-bottom:4px;">$$\\displaystyle {latex}$$</div>
              <div style="font-size:12px;color:#166534;">‚úì {desc}</div>
          </div>
          """

      # Build HTML for invalid examples
      invalid_html = ""
      for latex, title, reason in invalid_examples:
          invalid_html += f"""
          <div style="margin-bottom:8px;padding:8px;background:#fef2f2;border-left:3px solid #dc2626;border-radius:4px;">
              <div style="margin-bottom:4px;">$$\\displaystyle {latex}$$</div>
              <div style="font-size:12px;color:#991b1b;font-weight:600;">‚ùå {title}</div>
              <div style="font-size:11px;color:#7f1d1d;">{reason}</div>
          </div>
          """

      # Escape error message for display
      error_msg_display = error_msg.replace('<', '&lt;').replace('>', '&gt;')

      # Build complete HTML
      popup_html = f"""
  <div id="limitErrorPopupOverlay" style="position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.7);z-index:10000;display:flex;align-items:center;justify-content:center;padding:20px;">
      <div id="limitErrorPopupContent" style="background:white;border-radius:12px;max-width:900px;max-height:90vh;overflow-y:auto;box-shadow:0 20px 60px rgba(0,0,0,0.3);">

          <div style="padding:24px;border-bottom:2px solid #fee2e2;">
              <div style="display:flex;justify-content:space-between;align-items:start;">
                  <div>
                      <h2 style="margin:0 0 8px 0;color:#dc2626;font-size:24px;">
                          ‚ö†Ô∏è Invalid Limit Problem
                      </h2>
                      <p style="margin:0;color:#991b1b;font-size:14px;">
                          {error_msg_display}
                      </p>
                  </div>
                  <button id="closeLimitPopup" style="background:none;border:none;font-size:28px;cursor:pointer;color:#6b7280;padding:0;width:32px;height:32px;line-height:1;">
                      √ó
                  </button>
              </div>
          </div>

          <div style="padding:24px;">
              <div style="margin-bottom:24px;">
                  <h3 style="margin:0 0 12px 0;color:#059669;font-size:18px;display:flex;align-items:center;">
                      <span style="font-size:24px;margin-right:8px;">‚úÖ</span>
                      Valid Limit Problems
                  </h3>
                  <p style="margin:0 0 12px 0;color:#6b7280;font-size:13px;">
                      These limits evaluate to finite, well-defined numbers:
                  </p>
                  <div style="max-height:300px;overflow-y:auto;padding-right:8px;">
                      {valid_html}
                  </div>
              </div>

              <div style="margin-bottom:24px;padding-top:20px;border-top:2px solid #e5e7eb;">
                  <h3 style="margin:0 0 12px 0;color:#dc2626;font-size:18px;display:flex;align-items:center;">
                      <span style="font-size:24px;margin-right:8px;">‚ùå</span>
                      Invalid Limit Problems
                  </h3>
                  <p style="margin:0 0 12px 0;color:#6b7280;font-size:13px;">
                      These limits do NOT work in freestyle practice:
                  </p>
                  <div style="max-height:400px;overflow-y:auto;padding-right:8px;">
                      {invalid_html}
                  </div>
              </div>

              <div style="background:#eff6ff;padding:16px;border-radius:8px;border-left:4px solid #3b82f6;">
                  <div style="font-weight:600;color:#1e40af;margin-bottom:8px;font-size:14px;">
                      üí° Guidelines for Freestyle Practice Limits
                  </div>
                  <ul style="margin:0;padding-left:20px;color:#1e3a8a;font-size:13px;line-height:1.6;">
                      <li><strong>Must evaluate to a finite number</strong> (not ‚àû, -‚àû, or undefined)</li>
                      <li><strong>Must converge</strong> (not oscillate indefinitely)</li>
                      <li><strong>Left and right limits must match</strong> (no discontinuities)</li>
                      <li><strong>Should be solvable</strong> using standard calculus techniques</li>
                      <li>Use L'H√¥pital's rule, algebraic manipulation, or standard limit formulas</li>
                      <li>Indeterminate forms (0/0, ‚àû/‚àû) are fine if they resolve to a finite value</li>
                  </ul>
              </div>
          </div>

          <div style="padding:16px 24px;background:#f9fafb;border-top:1px solid #e5e7eb;display:flex;justify-content:flex-end;border-radius:0 0 12px 12px;">
              <button id="gotItButton" style="background:#3b82f6;color:white;border:none;padding:10px 24px;border-radius:6px;font-size:14px;font-weight:600;cursor:pointer;box-shadow:0 1px 3px rgba(0,0,0,0.1);">
                  Got it, I'll try a different problem
              </button>
          </div>
      </div>
  </div>
  """

      # Remove existing popup
      existing = document.querySelector('#limitErrorPopupOverlay')
      if existing:
          existing.remove()

      # Create overlay div directly
      overlay = document.createElement('div')
      overlay.innerHTML = popup_html.strip()

      # Get the actual popup element (first child of the innerHTML)
      popup_element = overlay.firstChild

      # Append to body
      document.body.appendChild(popup_element)

      # Add event listeners
      close_btn = document.querySelector('#closeLimitPopup')
      if close_btn:
          close_btn.addEventListener('click', create_proxy(lambda e: popup_element.remove()))

      got_it_btn = document.querySelector('#gotItButton')
      if got_it_btn:
          got_it_btn.addEventListener('click', create_proxy(lambda e: popup_element.remove()))

      # Close on overlay click
      popup_element.addEventListener('click', create_proxy(lambda e: popup_element.remove() if e.target.id == 'limitErrorPopupOverlay' else None))

      # Close on Escape key
      def handle_escape(e):
          if e.key == 'Escape':
              elem = document.querySelector('#limitErrorPopupOverlay')
              if elem:
                  elem.remove()

      escape_proxy = create_proxy(handle_escape)
      document.addEventListener('keydown', escape_proxy)

      # Render MathJax
      try:
          popup_content = document.querySelector('#limitErrorPopupContent')
          if popup_content and hasattr(window, 'MathJax') and hasattr(window.MathJax, 'typesetPromise'):
              window.console.log("Rendering MathJax for limit popup...")
              window.MathJax.typesetPromise([popup_content])
              window.console.log("‚úÖ MathJax rendering initiated")
      except Exception as e:
          window.console.error(f"Error setting up MathJax: {e}")
          import traceback
          window.console.error(traceback.format_exc())
    
    # ========================================
    # FIX FOR MATHQUILL INITIALIZATION
    # Replace the existing methods in your ProblemSolverApp class
    # ========================================

    def show_page(self, page_name):
        """Show page - MODIFIED to initialize freestyle on first view"""
        # Hide all pages
        pages = document.querySelectorAll(".page")
        for i in range(pages.length):
            pages[i].classList.remove("active")

        # Show selected page
        target = document.querySelector(f"#{page_name}Page")
        if target:
            target.classList.add("active")

        # Update nav
        nav_items = document.querySelectorAll(".nav-item")
        for i in range(nav_items.length):
            nav_items[i].classList.remove("active")

        active_nav = document.querySelector(f".nav-item[data-page='{page_name}']")
        if active_nav:
            active_nav.classList.add("active")

        # ‚úÖ NEW: Initialize freestyle page when first shown
        if page_name == "freestyle":
            # Use setTimeout to ensure page is visible before initialization
            def delayed_init():
                self.ensure_freestyle_initialized()
            window.setTimeout(create_proxy(delayed_init), 100)

        self.close_sidebar(None)

    def ensure_freestyle_initialized(self):
        """
        Ensure freestyle page is initialized - can be called multiple times safely.
        This is called when the freestyle page is shown.
        """
        window.console.log("üîß Ensuring freestyle page is initialized...")

        # Check if already initialized
        if hasattr(self, '_freestyle_initialized') and self._freestyle_initialized:
            window.console.log("‚úÖ Freestyle already initialized, skipping...")
            return

        try:
            # Initialize MathQuill fields (now that page is visible)
            problem_input = document.querySelector("#freestyleProblemInput")
            answer_input = document.querySelector("#freestyleAnswerInput")

            if not self.MQ:
                window.console.error("‚ùå MathQuill not available")
                window.alert("‚ö†Ô∏è MathQuill not loaded. Please refresh the page.")
                return

            # Initialize problem field
            if problem_input:
              problem_input.innerHTML = ""
              self.freestyle_problem_mf = self.MQ.MathField(problem_input)  # ‚Üê Just this
              window.console.log("‚úÖ Problem MathField initialized")
              window.setTimeout(create_proxy(lambda: self.freestyle_problem_mf.focus()), 100)
            else:
                window.console.error("‚ùå Problem input element not found")

            # Initialize answer field
            if answer_input:
              answer_input.innerHTML = ""
              self.freestyle_answer_mf = self.MQ.MathField(answer_input)
              window.console.log("‚úÖ Answer MathField initialized")
            else:
                window.console.error("‚ùå Answer input element not found")

            # Initialize state
            if not hasattr(self, 'freestyle_problem'):
                self.freestyle_problem = None
            if not hasattr(self, 'freestyle_attempts'):
                self.freestyle_attempts = []
            if not hasattr(self, 'freestyle_correct'):
                self.freestyle_correct = False
            if not hasattr(self, 'freestyle_finalized'):
                self.freestyle_finalized = False

            # Setup button handlers (only once)
            self._setup_freestyle_buttons()

            # Setup keyboard handlers (only once)
            self._setup_freestyle_keyboard()

            # Update credit display
            self.update_credit_display()

            # Mark as initialized
            self._freestyle_initialized = True
            window.console.log("‚úÖ Freestyle page fully initialized")

        except Exception as e:
            window.console.error(f"‚ùå Freestyle initialization error: {e}")
            import traceback
            window.console.error(traceback.format_exc())
            window.alert(f"‚ö†Ô∏è Error initializing freestyle page: {e}")

    def _setup_freestyle_buttons(self):
        """Setup button event handlers for freestyle page"""
        try:
            # Set problem button
            set_btn = document.querySelector("#setFreestyleProblem")
            if set_btn and not hasattr(set_btn, '_handler_attached'):
                set_btn.addEventListener("click", create_proxy(lambda e: self.set_freestyle_problem(e)))
                set_btn._handler_attached = True
                window.console.log("‚úÖ Set button handler attached")

            # Submit button
            submit_btn = document.querySelector("#freestyleSubmit")
            if submit_btn and not hasattr(submit_btn, '_handler_attached'):
                submit_btn.addEventListener("click", create_proxy(lambda e: self.freestyle_submit(e)))
                submit_btn._handler_attached = True
                window.console.log("‚úÖ Submit button handler attached")

            # Give Up button
            giveup_btn = document.querySelector("#freestyleGiveUp")
            if giveup_btn and not hasattr(giveup_btn, '_handler_attached'):
                giveup_btn.addEventListener("click", create_proxy(lambda e: self.freestyle_giveup(e)))
                giveup_btn._handler_attached = True
                window.console.log("‚úÖ Give Up button handler attached")

            # Finalize button
            finalize_btn = document.querySelector("#freestyleFinalize")
            if finalize_btn and not hasattr(finalize_btn, '_handler_attached'):
                finalize_btn.addEventListener("click", create_proxy(lambda e: self.freestyle_finalize(e)))
                finalize_btn._handler_attached = True
                window.console.log("‚úÖ Finalize button handler attached")

            # Reset button
            reset_btn = document.querySelector("#freestyleReset")
            if reset_btn and not hasattr(reset_btn, '_handler_attached'):
                reset_btn.addEventListener("click", create_proxy(lambda e: self.freestyle_reset(e)))
                reset_btn._handler_attached = True
                window.console.log("‚úÖ Reset button handler attached")

        except Exception as e:
            window.console.error(f"Button setup error: {e}")

    def _setup_freestyle_keyboard(self):
        """Setup keyboard event handlers for freestyle page"""
        try:
            # Setup keyboard button handlers
            keyboard_btns = document.querySelectorAll("#keyboardAccordionsContainer .input-btn")
            window.console.log(f"Found {keyboard_btns.length} keyboard buttons")

            for i in range(keyboard_btns.length):
                btn = keyboard_btns[i]
                action = btn.getAttribute("data-action")

                if action and not hasattr(btn, '_handler_attached'):
                    def make_handler(act):
                        def handler(e):
                            self.handle_freestyle_input(act)
                        return handler
                    btn.addEventListener("click", create_proxy(make_handler(action)))
                    btn._handler_attached = True

            window.console.log("‚úÖ Keyboard button handlers attached")

            # Setup keyboard accordion headers
            headers = document.querySelectorAll("#keyboardAccordionsContainer .keyboard-accordion-header")
            window.console.log(f"Found {headers.length} accordion headers")

            for i in range(headers.length):
                header = headers[i]

                if not hasattr(header, '_handler_attached'):
                    def make_accordion_handler(h):
                        def handler(e):
                            target_id = h.getAttribute("data-target")
                            body = document.querySelector(f"#{target_id}")
                            if body:
                                is_open = body.style.display == "block"
                                body.style.display = "none" if is_open else "block"
                                icon = h.querySelector(".keyboard-accordion-icon")
                                if icon:
                                    icon.textContent = "‚ñ≤" if not is_open else "‚ñº"
                        return handler
                    header.addEventListener("click", create_proxy(make_accordion_handler(header)))
                    header._handler_attached = True

            window.console.log("‚úÖ Accordion handlers attached")

        except Exception as e:
            window.console.error(f"Keyboard setup error: {e}")
            import traceback
            window.console.error(traceback.format_exc())

    def handle_freestyle_input(self, action):
        """Handle keyboard input for freestyle practice"""
        try:
            # Determine which field to target
            if self.freestyle_problem:
                target_field = self.freestyle_answer_mf
            else:
                target_field = self.freestyle_problem_mf

            if not target_field:
                window.console.error("‚ùå No MathQuill field available")
                return

            # Handle special actions
            if action == "BACKSPACE":
                target_field.keystroke("Backspace")
            elif action == "CLEAR":
                target_field.latex("")
            elif action == "MOVE_LEFT":
                target_field.keystroke("Left")
            elif action == "MOVE_RIGHT":
                target_field.keystroke("Right")
            elif action == "SELECT_LEFT":
                target_field.keystroke("Shift-Left")
            elif action == "SELECT_RIGHT":
                target_field.keystroke("Shift-Right")
            elif action.startswith("SEQ:"):
                # Handle sequences like "SEQ:d,/,d,x" or "SEQ:\lim,_,x,\to,0,{Right},{Right}"
                parts = action[4:].split(",")
                for part in parts:
                    part = part.strip()
                    if part.startswith("{") and part.endswith("}"):
                        # Keystroke like {Right}, {Left}
                        target_field.keystroke(part[1:-1])
                    else:
                        # Regular text
                        target_field.write(part)
            else:
                target_field.write(action)

            # Always refocus after action
            target_field.focus()

        except Exception as e:
            window.console.error(f"Input handler error: {e}")
            import traceback
            window.console.error(traceback.format_exc())

# ========================================
# REMOVE THIS METHOD FROM YOUR CODE:
# def init_freestyle_page(self)
# 
# It's no longer needed - initialization happens automatically
# when the page is shown via ensure_freestyle_initialized()
# ========================================

# ========================================
# UPDATE YOUR init() METHOD:
# Remove the call to self.init_freestyle_page()
# The new system initializes automatically when page is shown
# ========================================
# Initialize app
app = ProblemSolverApp()
window.setTimeout(create_proxy(app.init), 700)

print("‚úÖ Problem Solver initialized with multi-type support")
    </script>
  </body>
</html>