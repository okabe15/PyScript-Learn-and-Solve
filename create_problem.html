<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Problem Creator ‚Äî Accordion Toolbar</title>

  <!-- MathQuill CSS -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mathquill/0.10.1/mathquill.min.css">

  <!-- Quill.js -->
  <link href="https://cdn.quilljs.com/1.3.7/quill.snow.css" rel="stylesheet">
  <script src="https://cdn.quilljs.com/1.3.7/quill.js"></script>

  <!-- MathJax Configuration -->
  <script>
    window.MathJax = {
      tex: {
        inlineMath: [['\\(', '\\)'], ['$', '$']],
        displayMath: [['\\[', '\\]'], ['$$', '$$']]
      },
      asciimath: {
        delimiters: [['`', '`']]
      },
      loader: {
        load: ['input/tex', 'input/asciimath', 'output/chtml']
      },
      chtml: { 
        scale: 1.2 
      },
      startup: { 
        typeset: false,
        ready: () => {
          console.log('‚úÖ MathJax ready');
          MathJax.startup.defaultReady();
        }
      }
    };
  </script>
  
  <!-- MathJax -->
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

  <!-- PyScript -->
  <link rel="stylesheet" href="https://pyscript.net/releases/2024.1.1/core.css" />
  <script type="module" src="https://pyscript.net/releases/2024.1.1/core.js"></script>

  <style>
  /* Search highlight borders (non-destructive) */
.search-highlight-border {
    outline: 2px solid #fef08a !important;
    outline-offset: 2px;
    border-radius: 6px;
    background: rgba(254, 240, 138, 0.1) !important;
    transition: all 0.3s ease;
}

.search-highlight-border-current {
    outline: 3px solid #f97316 !important;
    outline-offset: 3px;
    background: rgba(249, 115, 22, 0.15) !important;
    box-shadow: 0 0 0 4px rgba(249, 115, 22, 0.1);
}
    * {
      box-sizing: border-box;
    }

    body {
      font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial;
      max-width: 1100px;
      margin: 20px auto;
      background: #f3f6fb;
      padding: 16px;
      padding-bottom: 100px;
      color: #0b1020;
    }

    header {
      display: flex;
      gap: 12px;
      align-items: center;
      margin-bottom: 20px;
    }

    header h1 {
      margin: 0;
      font-size: 20px;
    }

    .btn {
      padding: 8px 12px;
      border-radius: 8px;
      border: none;
      cursor: pointer;
      background: #0b6efd;
      color: #fff;
      font-size: 14px;
      font-weight: 500;
      transition: all 0.2s ease;
    }

    .btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(11, 110, 253, 0.3);
    }

    .btn.ghost {
      background: transparent;
      color: #0b6efd;
      border: 1px solid #dbe9ff;
    }

    .btn.ghost:hover {
      background: rgba(11, 110, 253, 0.05);
    }

    .panel {
      background: #fff;
      padding: 12px;
      border-radius: 10px;
      box-shadow: 0 6px 20px rgba(11, 20, 40, 0.06);
      margin-bottom: 12px;
    }

    /* ============================================
       EXPANDABLE ACCORDION TOOLBAR WITH UPWARD ANIMATION
       ============================================ */
    
    .toolbar-container {
      position: fixed;
      bottom: 30px;
      right: 30px;
      z-index: 9998;
    }

    .toolbar-backdrop {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      opacity: 0;
      visibility: hidden;
      transition: all 0.3s ease;
      z-index: 9997;
    }

    .toolbar-backdrop.active {
      opacity: 1;
      visibility: visible;
    }

    /* Collapsed toolbar button */
    .toolbar-toggle {
      width: 64px;
      height: 64px;
      border-radius: 16px;
      background: linear-gradient(135deg, #0b6efd 0%, #0052cc 100%);
      color: white;
      border: none;
      cursor: pointer;
      box-shadow: 0 8px 24px rgba(11, 110, 253, 0.4);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 2px;
      transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
      position: relative;
      z-index: 9999;
    }

    .toolbar-toggle:hover {
      transform: scale(1.05);
      box-shadow: 0 12px 32px rgba(11, 110, 253, 0.5);
    }

    .toolbar-toggle.active {
      transform: rotate(90deg) translateY(-20px);
      background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
      box-shadow: 0 8px 24px rgba(239, 68, 68, 0.4);
    }

    .toolbar-toggle-icon {
      width: 24px;
      height: 3px;
      background: white;
      border-radius: 2px;
      transition: all 0.3s ease;
    }

    .toolbar-toggle.active .toolbar-toggle-icon:nth-child(1) {
      transform: rotate(45deg) translateY(8px);
    }

    .toolbar-toggle.active .toolbar-toggle-icon:nth-child(2) {
      opacity: 0;
    }

    .toolbar-toggle.active .toolbar-toggle-icon:nth-child(3) {
      transform: rotate(-45deg) translateY(-8px);
    }

    /* Expanded toolbar panel with upward animation */
    .toolbar-panel {
      position: absolute;
      bottom: 80px;
      right: 0;
      background: transparent;
      border-radius: 20px;
      box-shadow: none;
      width: 380px;
      max-height: 80vh;
      overflow: visible;
      opacity: 0;
      visibility: hidden;
      transform: translateY(40px) scale(0.95);
      transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
      z-index: 9998;
      display: flex;
      flex-direction: column;
    }

    .toolbar-panel.active {
      opacity: 1;
      visibility: visible;
      transform: translateY(0) scale(1);
    }

    /* Hide all scrollbars during closing */
    .toolbar-panel.closing {
      overflow: hidden !important;
    }

    .toolbar-panel.closing * {
      overflow: visible !important;
      scrollbar-width: none !important;
    }

    .toolbar-panel.closing *::-webkit-scrollbar {
      display: none !important;
    }

    /* Panel background removed - always invisible */
    .toolbar-panel::before {
      display: none;
    }

    .toolbar-header {
      padding: 20px;
      border-bottom: 2px solid transparent;
      background: transparent;
      border-radius: 20px 20px 0 0;
      opacity: 0;
      display: none;
    }

    .toolbar-title {
      font-size: 18px;
      font-weight: 700;
      color: #0f172a;
      margin: 0;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .toolbar-subtitle {
      font-size: 12px;
      color: #64748b;
      margin-top: 4px;
    }

    .toolbar-content {
      overflow-y: visible;
      overflow-x: hidden;
      flex: 1;
      padding: 12px;
    }

    .toolbar-panel.active .toolbar-content {
      overflow-y: auto;
      transition: overflow-y 0s ease 0.6s;
    }

    /* Higher specificity to override .active state immediately */
    .toolbar-panel.active.closing .toolbar-content {
      overflow-y: visible !important;
      transition: none !important;
    }

    .toolbar-content::-webkit-scrollbar {
      width: 6px;
    }

    .toolbar-content::-webkit-scrollbar-track {
      background: #f1f5f9;
    }

    .toolbar-content::-webkit-scrollbar-thumb {
      background: #cbd5e1;
      border-radius: 3px;
    }

    .toolbar-content::-webkit-scrollbar-thumb:hover {
      background: #94a3b8;
    }

    /* Accordion sections with staggered animation */
    .accordion-section {
      margin-bottom: 8px;
      border-radius: 12px;
      overflow: hidden;
      background: white;
      border: 2px solid #e2e8f0;
      transition: all 0.3s ease;
    }

    /* Initial state - hidden when toolbar is closed */
    .toolbar-panel:not(.active) .accordion-section {
      opacity: 0;
      transform: translateY(20px);
      animation: none;
    }

    /* Slide in animation when opening */
    .toolbar-panel.active .accordion-section {
      opacity: 1;
      transform: translateY(0);
      animation: slideInAccordion 0.4s cubic-bezier(0.34, 1.56, 0.64, 1) both;
    }

    @keyframes slideInAccordion {
      from {
        opacity: 0;
        transform: translateY(20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    /* Slide out animation when closing */
    .toolbar-panel.closing .accordion-section {
      animation: slideOutAccordion 0.3s cubic-bezier(0.6, 0.04, 0.98, 0.34) both;
    }

    @keyframes slideOutAccordion {
      from {
        opacity: 1;
        transform: translateY(0);
      }
      to {
        opacity: 0;
        transform: translateY(30px);
      }
    }

    /* Staggered delays for each accordion - bottom to top when opening */
    .toolbar-panel.active #searchAccordion {
      animation-delay: 0.4s;
    }

    .toolbar-panel.active #problemAccordion {
      animation-delay: 0.3s;
    }

    .toolbar-panel.active #viewAccordion {
      animation-delay: 0.2s;
    }

    .toolbar-panel.active #dataAccordion {
      animation-delay: 0.1s;
    }

    /* Staggered delays when closing - top to bottom (Search disappears first) */
    .toolbar-panel.closing #searchAccordion {
      animation-delay: 0s;
    }

    .toolbar-panel.closing #problemAccordion {
      animation-delay: 0.05s;
    }

    .toolbar-panel.closing #viewAccordion {
      animation-delay: 0.1s;
    }

    .toolbar-panel.closing #dataAccordion {
      animation-delay: 0.15s;
    }

    .accordion-section:hover {
      border-color: #cbd5e1;
    }

    .accordion-section.active {
      border-color: #0b6efd;
      box-shadow: 0 4px 12px rgba(11, 110, 253, 0.1);
    }

    .accordion-header {
      padding: 14px 16px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: #f8fafc;
      transition: all 0.2s ease;
      user-select: none;
    }

    .accordion-header:hover {
      background: #f1f5f9;
    }

    .accordion-section.active .accordion-header {
      background: #eff6ff;
    }

    .accordion-header-left {
      display: flex;
      align-items: center;
      gap: 12px;
      flex: 1;
    }

    .accordion-icon {
      width: 36px;
      height: 36px;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      flex-shrink: 0;
    }

    .icon-blue { background: #dbeafe; color: #0b6efd; }
    .icon-green { background: #d1fae5; color: #10b981; }
    .icon-purple { background: #e9d5ff; color: #9333ea; }
    .icon-orange { background: #fed7aa; color: #f97316; }
    .icon-red { background: #fee2e2; color: #ef4444; }
    .icon-yellow { background: #fef3c7; color: #f59e0b; }

    .accordion-title {
      flex: 1;
    }

    .accordion-label {
      font-weight: 600;
      font-size: 14px;
      color: #0f172a;
      margin-bottom: 2px;
    }

    .accordion-desc {
      font-size: 11px;
      color: #64748b;
    }

    .accordion-arrow {
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #94a3b8;
      transition: transform 0.3s ease;
      font-size: 12px;
    }

    .accordion-section.active .accordion-arrow {
      transform: rotate(180deg);
      color: #0b6efd;
    }

    .accordion-body {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .accordion-section.active .accordion-body {
      max-height: 1000px;
    }

    /* Immediately collapse all accordion bodies when closing */
    .toolbar-panel.closing .accordion-body {
      max-height: 0 !important;
      transition: none !important;
    }

    .accordion-content {
      padding: 16px;
      background: white;
    }

    /* Search section specific styles */
    .search-input-wrapper {
      position: relative;
      margin-bottom: 12px;
    }

    .search-input {
      width: 100%;
      padding: 10px 36px 10px 36px;
      border: 2px solid #e6eef8;
      border-radius: 8px;
      font-size: 14px;
      outline: none;
      transition: all 0.2s;
    }

    .search-input:focus {
      border-color: #0b6efd;
      box-shadow: 0 0 0 3px rgba(11, 110, 253, 0.1);
    }

    .search-input-icon {
      position: absolute;
      left: 12px;
      top: 50%;
      transform: translateY(-50%);
      color: #94a3b8;
      pointer-events: none;
    }

    .search-clear-btn {
      position: absolute;
      right: 10px;
      top: 50%;
      transform: translateY(-50%);
      background: none;
      border: none;
      color: #94a3b8;
      cursor: pointer;
      font-size: 20px;
      padding: 4px;
      display: none;
      transition: color 0.2s;
    }

    .search-clear-btn:hover {
      color: #ef4444;
    }

    .search-controls {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 8px;
      margin-bottom: 12px;
    }

    .search-btn {
      padding: 8px;
      border: 2px solid #e6eef8;
      background: white;
      border-radius: 6px;
      cursor: pointer;
      font-size: 12px;
      font-weight: 600;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 4px;
      color: #475569;
    }

    .search-btn:hover {
      border-color: #0b6efd;
      color: #0b6efd;
      background: #f0f9ff;
    }

    .search-btn.active {
      background: #0b6efd;
      border-color: #0b6efd;
      color: white;
    }

    .search-match-info {
      font-size: 12px;
      color: #64748b;
      text-align: center;
      padding: 8px;
      background: #f8fafc;
      border-radius: 6px;
      border: 1px solid #e2e8f0;
    }

    /* Action items in accordion */
    .action-item {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s ease;
      border: none;
      background: transparent;
      width: 100%;
      text-align: left;
      margin-bottom: 6px;
    }

    .action-item:last-child {
      margin-bottom: 0;
    }

    .action-item:hover {
      background: #f8fafc;
      transform: translateX(4px);
    }

    .action-item-icon {
      width: 32px;
      height: 32px;
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      flex-shrink: 0;
    }

    .action-item-content {
      flex: 1;
    }

    .action-item-label {
      font-weight: 600;
      font-size: 13px;
      color: #0f172a;
      margin-bottom: 2px;
    }

    .action-item-desc {
      font-size: 11px;
      color: #64748b;
    }

    /* Search highlights */
    .search-highlight {
      background-color: #fef08a !important;
      padding: 2px 4px;
      border-radius: 3px;
      font-weight: 600;
    }

    .search-highlight-current {
      background-color: #f97316 !important;
      color: white !important;
      padding: 2px 4px;
      border-radius: 3px;
      font-weight: 600;
    }

    .search-no-match {
      opacity: 0.3;
      pointer-events: none;
    }

    /* Problem styles */
    .problem {
      border: 2px solid #e2e8f0;
      border-radius: 10px;
      margin-bottom: 12px;
      background: #ffffff;
      box-shadow: 0 3px 8px rgba(0, 0, 0, 0.05);
    }

    .problem-header {
      padding: 12px;
      font-weight: 700;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: #f0f4ff;
      border-radius: 8px;
      position: relative;
    }

    .problem-header::before {
      content: '‚ñº';
      position: absolute;
      left: 12px;
      transition: transform 0.3s ease;
      font-size: 12px;
      color: #0b6efd;
    }

    .problem-header.collapsed::before {
      transform: rotate(-90deg);
    }

    .problem-header > span {
      margin-left: 20px;
    }

    .problem-header:hover {
      background: #dbeafe;
    }

    .problem-body {
      padding: 0 12px;
      max-height: 50000px;
      overflow: visible;
      transition: max-height 0.4s ease, padding 0.4s ease;
    }

    .problem-body.collapsed {
      max-height: 0;
      padding: 0 12px;
      overflow: hidden;
    }

    label {
      display: block;
      font-weight: 600;
      margin-bottom: 6px;
    }

    .step {
      border: 2px solid #e6eef8;
      padding: 10px;
      border-radius: 8px;
      margin-bottom: 10px;
      transition: all 0.3s ease;
      background: #f8fafc;
    }

    /* Autosave Indicator */
    #autosaveIndicator {
      position: fixed;
      bottom: 30px;
      left: 30px;
      background: linear-gradient(135deg, #10b981 0%, #059669 100%);
      color: white;
      padding: 10px 16px;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 14px;
      font-weight: 600;
      opacity: 0;
      transform: translateY(20px);
      transition: all 0.3s ease;
      pointer-events: none;
      z-index: 9999;
    }

    #autosaveIndicator.show {
      opacity: 1;
      transform: translateY(0);
      pointer-events: auto;
    }

    #autosaveIndicator.saving {
      background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
      box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
    }

    /* Loading overlay */
    #loadingOverlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(15, 23, 42, 0.95);
      z-index: 10000;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #fff;
    }

    .spinner {
      width: 60px;
      height: 60px;
      border: 4px solid rgba(59, 130, 246, 0.3);
      border-top-color: #3b82f6;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 20px;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }

    .loading-text {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 8px;
    }

    #loadingStatus {
      margin-top: 16px;
      padding: 12px 20px;
      background: rgba(30, 41, 59, 0.8);
      border-radius: 8px;
      font-family: monospace;
      font-size: 13px;
      color: #cbd5e1;
      max-height: 200px;
      overflow: auto;
      width: 90%;
    }

    /* Mobile responsiveness */
    @media (max-width: 768px) {
      body {
        padding: 12px;
        padding-bottom: 120px;
      }

      .toolbar-container {
        bottom: 20px;
        right: 20px;
      }

      .toolbar-toggle {
        width: 56px;
        height: 56px;
      }

      .toolbar-panel {
        right: 0;
        left: 20px;
        width: auto;
        max-width: calc(100vw - 40px);
      }

      #autosaveIndicator {
        bottom: 90px;
        left: 20px;
        right: 20px;
        font-size: 12px;
      }
    }
  </style>
</head>
<body>
  <!-- Loading Overlay -->
  <div id="loadingOverlay">
    <div class="spinner"></div>
    <div class="loading-text">Initializing Problem Creator...</div>
    <div id="loadingStatus"><div>‚è≥ Starting up...</div></div>
  </div>

  <!-- Header -->
  <header>
    <h1>üìù Problem Set Creator</h1>
  </header>

  <!-- Main Panel -->
  <div class="panel">
    <div style="margin-bottom:16px;">
      <button id="addProblemBtn" class="btn">‚ûï Create Problem</button>
    </div>

    <div id="problemsContainer"></div>

    <!-- Problem Set Description -->
    <div style="margin-top:16px; margin-bottom:16px;">
      <label>Problem Set Description</label>
      <input id="problemSetDescription" type="text" 
             style="background:#f5eac3;width:100%; padding:8px; border:1px solid #0ea5e9; border-radius:6px; font-size:14px;"
             placeholder="Enter a description for this problem set...">
    </div>

    <!-- Problem Set UUID -->
    <div style="margin-top:20px;">
      <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
        <label>Problem Set UUID</label>
        <button id="copyUuidBtn" class="btn ghost" style="font-size:12px; padding:4px 8px;">üìã Copy UUID</button>
      </div>
      <div id="problemSetUuid" style="background:#f0f9ff; border:1px solid #0ea5e9; padding:8px; border-radius:6px; font-family:monospace; font-size:13px; color:#0369a1; margin-bottom:12px;">
        No problem set loaded
      </div>
      <label>Exported JSON (Base64 compressed)</label>
      <pre id="exportedJson" style="background:#0b1220; color:#cfeaff; padding:8px; border-radius:8px; max-height:260px; overflow:auto; font-family:monospace; font-size:13px;">[]</pre>
    </div>
  </div>

  <!-- Expandable Accordion Toolbar -->
  <div class="toolbar-backdrop" id="toolbarBackdrop"></div>
  <div class="toolbar-container">
    <!-- Expanded Panel -->
    <div class="toolbar-panel" id="toolbarPanel">
      <div class="toolbar-header">
        <h2 class="toolbar-title">‚ö° Quick Actions</h2>
        <div class="toolbar-subtitle">Search, manage, and control your problem set</div>
      </div>

      <div class="toolbar-content">
        <!-- Search Accordion - Active by default -->
        <div class="accordion-section active" id="searchAccordion">
          <div class="accordion-header" onclick="toggleAccordion('searchAccordion')">
            <div class="accordion-header-left">
              <div class="accordion-icon icon-blue">üîç</div>
              <div class="accordion-title">
                <div class="accordion-label">Search</div>
                <div class="accordion-desc">Find problems and steps</div>
              </div>
            </div>
            <div class="accordion-arrow">‚ñº</div>
          </div>
          <div class="accordion-body">
            <div class="accordion-content">
              <div class="search-input-wrapper">
                <span class="search-input-icon">üîç</span>
                <input 
                  type="text" 
                  id="searchInput" 
                  class="search-input"
                  placeholder="Search problems..."
                />
                <button class="search-clear-btn" id="clearSearchBtn">√ó</button>
              </div>
              <div class="search-controls">
                <button class="search-btn" id="regexBtn">
                  <span style="font-family: monospace;">.*</span>
                  <span>Regex</span>
                </button>
                <button class="search-btn" id="prevBtn">
                  <span>‚Üê</span>
                  <span>Prev</span>
                </button>
                <button class="search-btn" id="nextBtn">
                  <span>‚Üí</span>
                  <span>Next</span>
                </button>
              </div>
              <div class="search-match-info" id="matchInfo" style="display: none;">
                0 matches
              </div>
            </div>
          </div>
        </div>

        <!-- Problem Management Accordion - Collapsed by default -->
        <div class="accordion-section" id="problemAccordion">
          <div class="accordion-header" onclick="toggleAccordion('problemAccordion')">
            <div class="accordion-header-left">
              <div class="accordion-icon icon-green">üìã</div>
              <div class="accordion-title">
                <div class="accordion-label">Problem Management</div>
                <div class="accordion-desc">Import, export, and save</div>
              </div>
            </div>
            <div class="accordion-arrow">‚ñº</div>
          </div>
          <div class="accordion-body">
            <div class="accordion-content">
              <button class="action-item" onclick="toolbarActions.importProblem()">
                <div class="action-item-icon icon-blue">üì•</div>
                <div class="action-item-content">
                  <div class="action-item-label">Import Problem Set</div>
                  <div class="action-item-desc">Load from file or paste JSON</div>
                </div>
              </button>
              <button class="action-item" onclick="toolbarActions.exportProblems()">
                <div class="action-item-icon icon-green">üì§</div>
                <div class="action-item-content">
                  <div class="action-item-label">Export to Students</div>
                  <div class="action-item-desc">Share problem set</div>
                </div>
              </button>
              <button class="action-item" onclick="toolbarActions.downloadJSON()">
                <div class="action-item-icon icon-purple">üíæ</div>
                <div class="action-item-content">
                  <div class="action-item-label">Download JSON</div>
                  <div class="action-item-desc">Save as file</div>
                </div>
              </button>
            </div>
          </div>
        </div>

        <!-- View Controls Accordion - Collapsed by default -->
        <div class="accordion-section" id="viewAccordion">
          <div class="accordion-header" onclick="toggleAccordion('viewAccordion')">
            <div class="accordion-header-left">
              <div class="accordion-icon icon-orange">üëÅÔ∏è</div>
              <div class="accordion-title">
                <div class="accordion-label">View Controls</div>
                <div class="accordion-desc">Expand or collapse problems</div>
              </div>
            </div>
            <div class="accordion-arrow">‚ñº</div>
          </div>
          <div class="accordion-body">
            <div class="accordion-content">
              <button class="action-item" onclick="toolbarActions.expandAll()">
                <div class="action-item-icon icon-green">‚¨áÔ∏è</div>
                <div class="action-item-content">
                  <div class="action-item-label">Expand All</div>
                  <div class="action-item-desc">Show all problems</div>
                </div>
              </button>
              <button class="action-item" onclick="toolbarActions.collapseAll()">
                <div class="action-item-icon icon-orange">‚¨ÜÔ∏è</div>
                <div class="action-item-content">
                  <div class="action-item-label">Collapse All</div>
                  <div class="action-item-desc">Hide all problems</div>
                </div>
              </button>
            </div>
          </div>
        </div>

        <!-- Data Management Accordion - Collapsed by default -->
        <div class="accordion-section" id="dataAccordion">
          <div class="accordion-header" onclick="toggleAccordion('dataAccordion')">
            <div class="accordion-header-left">
              <div class="accordion-icon icon-red">üóÇÔ∏è</div>
              <div class="accordion-title">
                <div class="accordion-label">Data Management</div>
                <div class="accordion-desc">Manage saved data</div>
              </div>
            </div>
            <div class="accordion-arrow">‚ñº</div>
          </div>
          <div class="accordion-body">
            <div class="accordion-content">
              <button class="action-item" onclick="toolbarActions.clearAutosave()">
                <div class="action-item-icon icon-red">üóëÔ∏è</div>
                <div class="action-item-content">
                  <div class="action-item-label">Clear Autosave</div>
                  <div class="action-item-desc">Delete locally saved data</div>
                </div>
              </button>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Toggle Button -->
    <button class="toolbar-toggle" id="toolbarToggle">
      <div class="toolbar-toggle-icon"></div>
      <div class="toolbar-toggle-icon"></div>
      <div class="toolbar-toggle-icon"></div>
    </button>
  </div>

  <!-- Autosave Indicator -->
  <div id="autosaveIndicator">
    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path>
      <polyline points="17 21 17 13 7 13 7 21"></polyline>
      <polyline points="7 3 7 8 15 8"></polyline>
    </svg>
    <span>Saved</span>
  </div>

  <!-- Include jQuery and MathQuill -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathquill/0.10.1/mathquill.min.js"></script>

  <!-- PyScript Configuration -->
  <py-config>
    packages = ["sympy", "lark", "brotli"]
  </py-config>

  <!-- Toolbar JavaScript -->
  <script>
    // Toolbar Toggle
    (function() {
      const toolbarToggle = document.getElementById('toolbarToggle');
      const toolbarPanel = document.getElementById('toolbarPanel');
      const toolbarBackdrop = document.getElementById('toolbarBackdrop');

      window.toggleToolbar = function() {
        const isActive = toolbarToggle.classList.contains('active');
        
        if (isActive) {
          // Closing - add closing class for animation
          toolbarPanel.classList.add('closing');
          toolbarToggle.classList.remove('active');
          toolbarBackdrop.classList.remove('active');
          
          // Wait for closing animation to complete (0.15s delay + 0.3s animation = 0.45s)
          setTimeout(() => {
            toolbarPanel.classList.remove('active');
            toolbarPanel.classList.remove('closing');
          }, 500);
        } else {
          // Opening
          toolbarToggle.classList.add('active');
          toolbarPanel.classList.add('active');
          toolbarBackdrop.classList.add('active');
        }
      };

      toolbarToggle.addEventListener('click', window.toggleToolbar);
      toolbarBackdrop.addEventListener('click', window.toggleToolbar);

      // Close on escape
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && toolbarToggle.classList.contains('active')) {
          window.toggleToolbar();
        }
      });
    })();

    // Accordion Toggle
    window.toggleAccordion = function(accordionId) {
      const accordion = document.getElementById(accordionId);
      if (accordion) {
        accordion.classList.toggle('active');
      }
    };

    // Search Functionality with Quill Support (Non-Destructive)
// Search Functionality with Quill Support (Non-Destructive, Fixed Container Selection)
window.searchManager = (function() {
    let isRegexMode = false;
    let searchMatches = [];
    let currentMatchIndex = -1;

    const searchInput = document.getElementById('searchInput');
    const clearBtn = document.getElementById('clearSearchBtn');
    const regexBtn = document.getElementById('regexBtn');
    const prevBtn = document.getElementById('prevBtn');
    const nextBtn = document.getElementById('nextBtn');
    const matchInfo = document.getElementById('matchInfo');

    function updateMatchInfo() {
        if (searchMatches.length === 0) {
            matchInfo.style.display = 'none';
            return;
        }

        matchInfo.style.display = 'block';
        matchInfo.textContent = `Match ${currentMatchIndex + 1} of ${searchMatches.length}`;
    }

    function highlightCurrentMatch() {
        // Remove all previous visual highlights
        document.querySelectorAll('.search-highlight-border').forEach(el => {
            el.classList.remove('search-highlight-border', 'search-highlight-border-current');
        });

        if (currentMatchIndex >= 0 && currentMatchIndex < searchMatches.length) {
            const match = searchMatches[currentMatchIndex];
            
            // Add visual border to current match container
            if (match.container) {
                match.container.classList.add('search-highlight-border', 'search-highlight-border-current');
            }
            
            // Expand problem if collapsed
            if (match.card) {
                const body = match.card.querySelector('.problem-body');
                const header = match.card.querySelector('.problem-header');
                
                if (body && body.classList.contains('collapsed')) {
                    body.classList.remove('collapsed');
                    if (header) header.classList.remove('collapsed');
                }

                match.card.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
            
            // Scroll the specific container into view
            if (match.container) {
                setTimeout(() => {
                    match.container.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }, 300);
            }
        }
    }

    function searchInQuill(editorId, query, searchPattern, matches, problemCard, problemIndex, stepIndex = null) {
        const quill = window.quillEditors && window.quillEditors[editorId];
        if (!quill) return false;

        try {
            const text = quill.getText();
            let hasMatch = false;
            
            // Reset lastIndex for global regex
            if (isRegexMode) {
                searchPattern.lastIndex = 0;
            }
            
            if (isRegexMode) {
                if (searchPattern.test(text)) {
                    hasMatch = true;
                }
            } else {
                if (text.toLowerCase().includes(query.toLowerCase())) {
                    hasMatch = true;
                }
            }
            
            if (hasMatch) {
                // Find the specific Quill container (not a parent)
                const container = document.getElementById(editorId);
                
                let label = `Problem ${problemIndex + 1}`;
                if (stepIndex !== null) {
                    label += `, Step ${stepIndex + 1}`;
                }
                label += ' - Description';
                
                matches.push({
                    type: 'quill',
                    editorId: editorId,
                    card: problemCard,
                    container: container, // This is the specific .quill-container div
                    label: label
                });
            }
            
            return hasMatch;
        } catch (e) {
            console.error('Error searching in Quill editor:', e);
            return false;
        }
    }

    function searchProblems(query) {
        const trimmedQuery = query.trim();
        searchMatches = [];
        currentMatchIndex = -1;

        clearBtn.style.display = trimmedQuery ? 'block' : 'none';
        
        // Remove all previous highlights
        document.querySelectorAll('.search-highlight-border').forEach(el => {
            el.classList.remove('search-highlight-border', 'search-highlight-border-current');
        });

        if (!trimmedQuery) {
            document.querySelectorAll('.problem').forEach(card => {
                card.classList.remove('search-no-match');
                card.style.display = 'block';
            });
            updateMatchInfo();
            return;
        }

        let searchPattern;
        try {
            if (isRegexMode) {
                searchPattern = new RegExp(trimmedQuery, 'gi');
            } else {
                const escaped = trimmedQuery.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                searchPattern = new RegExp(escaped, 'gi');
            }
        } catch (e) {
            console.error('Invalid regex:', e);
            return;
        }

        document.querySelectorAll('.problem').forEach((card, problemIndex) => {
            let hasMatch = false;
            
            // Search in problem title
            const titleEl = card.querySelector('.probTitle');
            if (titleEl && titleEl.value) {
                if (isRegexMode ? searchPattern.test(titleEl.value) : titleEl.value.toLowerCase().includes(trimmedQuery.toLowerCase())) {
                    hasMatch = true;
                    searchMatches.push({
                        type: 'input',
                        card: card,
                        container: titleEl, // Highlight the input itself
                        label: `Problem ${problemIndex + 1} - Title`
                    });
                }
                searchPattern.lastIndex = 0;
            }
            
            // Search in problem description (Quill)
            const probDescEditor = card.querySelector('.prob-desc-editor');
            if (probDescEditor) {
                const editorId = probDescEditor.id;
                if (editorId && searchInQuill(editorId, trimmedQuery, searchPattern, searchMatches, card, problemIndex)) {
                    hasMatch = true;
                }
            }
            
            // Search in steps
            card.querySelectorAll('.step').forEach((step, stepIndex) => {
                // Search in step description (Quill)
                const stepDescEditor = step.querySelector('.step-desc-editor');
                if (stepDescEditor) {
                    const editorId = stepDescEditor.id;
                    if (editorId && searchInQuill(editorId, trimmedQuery, searchPattern, searchMatches, card, problemIndex, stepIndex)) {
                        hasMatch = true;
                    }
                }
                
                // Search in MathQuill fields (expression, expected, user)
                const mathContainers = step.querySelectorAll('.math-input[data-mq="1"]');
                mathContainers.forEach((mf, mathIndex) => {
                    const latex = mf.textContent || '';
                    if (isRegexMode ? searchPattern.test(latex) : latex.toLowerCase().includes(trimmedQuery.toLowerCase())) {
                        hasMatch = true;
                        
                        // Determine which field this is
                        let fieldName = 'Math';
                        if (mf.classList.contains('step-expr')) {
                            fieldName = 'Expression';
                        } else if (mf.classList.contains('step-expected')) {
                            fieldName = 'Expected';
                        } else if (mf.classList.contains('step-user')) {
                            fieldName = 'User Answer';
                        }
                        
                        searchMatches.push({
                            type: 'math',
                            card: card,
                            container: mf, // Highlight the specific math field
                            label: `Problem ${problemIndex + 1}, Step ${stepIndex + 1} - ${fieldName}`
                        });
                    }
                    searchPattern.lastIndex = 0;
                });
            });
            
            // Show/hide problem based on match
            if (hasMatch) {
                card.classList.remove('search-no-match');
                card.style.display = 'block';
            } else {
                card.classList.add('search-no-match');
                card.style.display = 'none';
            }
        });

        updateMatchInfo();
        if (searchMatches.length > 0) {
            currentMatchIndex = 0;
            highlightCurrentMatch();
        }
    }

    function clearSearch() {
        searchInput.value = '';
        document.querySelectorAll('.search-highlight-border').forEach(el => {
            el.classList.remove('search-highlight-border', 'search-highlight-border-current');
        });
        searchProblems('');
    }

    function toggleRegex() {
        isRegexMode = !isRegexMode;
        regexBtn.classList.toggle('active');
        searchProblems(searchInput.value);
    }

    function nextMatch() {
        if (searchMatches.length === 0) return;
        currentMatchIndex = (currentMatchIndex + 1) % searchMatches.length;
        highlightCurrentMatch();
        updateMatchInfo();
    }

    function prevMatch() {
        if (searchMatches.length === 0) return;
        currentMatchIndex = (currentMatchIndex - 1 + searchMatches.length) % searchMatches.length;
        highlightCurrentMatch();
        updateMatchInfo();
    }

    // Event listeners
    if (searchInput) {
        searchInput.addEventListener('input', (e) => searchProblems(e.target.value));
        searchInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                if (e.shiftKey) {
                    prevMatch();
                } else {
                    nextMatch();
                }
            }
        });
    }

    if (clearBtn) clearBtn.addEventListener('click', clearSearch);
    if (regexBtn) regexBtn.addEventListener('click', toggleRegex);
    if (prevBtn) prevBtn.addEventListener('click', prevMatch);
    if (nextBtn) nextBtn.addEventListener('click', nextMatch);

    return {
        search: searchProblems,
        clear: clearSearch,
        toggleRegex: toggleRegex,
        next: nextMatch,
        prev: prevMatch
    };
})();

    // Toolbar Actions
    window.toolbarActions = {
      importProblem: function() {
        if (window.problem_creator && window.problem_creator.data_manager) {
          window.problem_creator.data_manager.import_problem();
        }
        window.toggleToolbar();
      },
      exportProblems: function() {
        if (window.problem_creator && window.problem_creator.data_manager) {
          window.problem_creator.data_manager.export_json();
        }
        window.toggleToolbar();
      },
      downloadJSON: function() {
        if (window.problem_creator && window.problem_creator.data_manager) {
          window.problem_creator.data_manager.download_json();
        }
        window.toggleToolbar();
      },
      collapseAll: function() {
        document.querySelectorAll('.problem').forEach(card => {
          const body = card.querySelector('.problem-body');
          const header = card.querySelector('.problem-header');
          if (body && header) {
            body.classList.add('collapsed');
            header.classList.add('collapsed');
          }
        });
      },
      expandAll: function() {
        document.querySelectorAll('.problem').forEach(card => {
          const body = card.querySelector('.problem-body');
          const header = card.querySelector('.problem-header');
          if (body && header) {
            body.classList.remove('collapsed');
            header.classList.remove('collapsed');
          }
        });
      },
      clearAutosave: function() {
        if (window.problem_creator && window.problem_creator.data_manager) {
          window.problem_creator.data_manager.clear_autosave();
        }
        window.toggleToolbar();
      }
    };

    // Autosave notification
    function showAutosaveIndicator(duration = 2000) {
      const indicator = document.getElementById('autosaveIndicator');
      if (!indicator) return;
      
      indicator.classList.remove('show', 'saving');
      void indicator.offsetWidth;
      
      indicator.classList.add('show', 'saving');
      
      setTimeout(() => {
        indicator.classList.remove('saving');
      }, 300);
      
      setTimeout(() => {
        indicator.classList.remove('show');
      }, duration);
    }

    window.showAutosaveIndicator = showAutosaveIndicator;
  </script>

  <!-- Python Script -->
<script type="py">
from pyscript import document, window
from pyodide.ffi import create_proxy
import json, base64, brotli, html, re
import sympy as sp
from lark import Lark, Transformer, v_args
import uuid

# ============================================================================
# CORE CLASSES
# ============================================================================

class MathParser:
    """Handles LaTeX parsing, structural comparison, and error popups"""

    GRAMMAR = r"""
start: matrix_ops
   | expr

?expr: sum

?sum: sum "+" product   -> add
  | sum "-" product   -> sub
  | product

?product: product ("*" | "\\cdot" | "\\times" | "\\ast") power   -> mul  # Changed: power instead of implicit
      | product "/" power                                        -> div   # Changed: power instead of implicit
      | scalar matrix                                            -> scalar_matrix_mul
      | scalar matrix_env                                        -> scalar_matrix_mul
      | implicit

?implicit: implicit power        -> implicit_mul
       | power

?power: "-" power                -> neg
    | atom_degree              -> atom_to_degree
    | atom "^" power           -> power
    | atom

?atom: NUMBER                    -> number
   | derivative_function
   | partial_derivative_function
   | trig_function
   | log_function
   | limit
   | fraction
   | matrix
   | matrix_env
   | abs_function
   | "(" expr ")"              -> paren_expr
   | "{" expr "}"              -> braces_expr
   | PI                        -> pi_symbol
   | INFTY                     -> infty_symbol
   | SYMBOL                    -> symbol
   | row_op

scalar: NUMBER | SYMBOL

trig_function: TRIG_NAME "(" expr ")"    -> trig_func

log_function: LOG_NAME "(" expr ")"      -> log_func

limit: LIM "_" "{" SYMBOL arrow expr "}" expr -> limit_expr

derivative_function: "__derivative" "(" SYMBOL "," expr ")" -> derivative_func

partial_derivative_function: "__partial_derivative" "(" SYMBOL "," expr ")" -> partial_derivative_func

fraction: "\\frac" "{" expr "}" "{" expr "}" -> frac

abs_function: "\\left" "|" expr "\\right" "|"     -> abs_func

atom_degree: atom "^" degree_expr

degree_expr: "{" CIRC "}"

matrix: "[" matrix_rows "]" -> matrix_rows
matrix_rows: row ("," row)* -> matrix_rows
row: "[" elements "]" -> row
elements: expr ("," expr)* -> elements

matrix_env: "\\begin" "{" /(bmatrix|pmatrix|matrix)/ "}" matrix_env_body "\\end" "{" /(bmatrix|pmatrix|matrix)/ "}" -> matrix_env

matrix_env_body: matrix_env_row ( "\\\\" matrix_env_row )*
matrix_env_row: expr ( "&" expr )*

matrix_ops: matrix ("|" row_op)+ -> matrix_apply_ops

row_op: "R_" INT arrow row_expr                 -> row_replace
    | "R_" INT swaparrow "R_" INT            -> row_swap

arrow: TO | LEFTARROW | RIGHTARROW | ARROWRIGHT | ARROWLEFT
swaparrow: LEFTRIGHTARROW | SWAPLR

row_expr: "R_" INT op expr "R_" INT   -> row_combine
        | "R_" INT                     -> row_reference
       | expr "R_" INT               -> row_scale
       

op: "+" | "-"

TRIG_NAME.2: /\\sin|\\cos|\\tan|\\cot|\\sec|\\csc|\\arcsin|\\arccos|\\arctan/
LOG_NAME.2: /\\log|\\ln|\\exp/
LIM.2: "\\lim"
TO.2: "\\to"
LEFTARROW.2: "\\leftarrow"
RIGHTARROW.2: "\\rightarrow"
LEFTRIGHTARROW.2: "\\leftrightarrow"
ARROWRIGHT.2: "->"
ARROWLEFT.2: "<-"
SWAPLR.2: "<->"
NUMBER: /\d+(\.\d*)?|\.\d+/
INT: /\d+/
PI.2: "\\pi"
INFTY.2: "\\infty"
SYMBOL: /\\?(?!(?:sin|cos|tan|cot|sec|csc|arcsin|arccos|arctan|log|ln|exp|frac|left|right|begin|end|pi|infty|lim|to|leftarrow|rightarrow|leftrightarrow|lvert|rvert)(?![a-zA-Z0-9]))[a-zA-Z][a-zA-Z0-9]*/
CIRC: "\\circ"

%import common.WS_INLINE
%ignore WS_INLINE
"""
    def expression_has_matrix_operations(self, latex_str):
        """
        Quick check if a LaTeX expression contains matrix row operations
        without fully parsing it
        """
        if not latex_str:
            return False

        # Check for row operation indicators
        indicators = [
            "|R_",           # Pipe followed by R_
            "R_",            # Row reference
            "\\to",          # Arrow
            "\\leftarrow",   # Left arrow
            "\\leftrightarrow"  # Swap arrow
        ]

        return any(ind in latex_str for ind in indicators)
    
    def structure_to_json_serializable(self, structure):
        """
        Convert extracted structure (which may contain SymPy objects) 
        to fully JSON-serializable format
        """
        if not isinstance(structure, dict):
            return structure

        result = {}

        # Convert operators
        if "operators" in structure:
            result["operators"] = dict(structure["operators"])

        # Convert operands (may contain SymPy objects)
        if "operands" in structure:
            result["operands"] = {
                str(key): value 
                for key, value in structure["operands"].items()
            }

        # ‚úÖ Convert matrix_ops
        if "matrix_ops" in structure:
            result["matrix_ops"] = []
            for op in structure["matrix_ops"]:
                serialized_op = {
                    "type": op.get("type", "unknown"),
                    "operations": self.sympy_to_json_serializable(op.get("operations", [])),
                    "original_shape": op.get("original_shape", (0, 0))
                }
                result["matrix_ops"].append(serialized_op)

        # Copy other fields
        if "total_ops" in structure:
            result["total_ops"] = structure["total_ops"]
        if "total_operands" in structure:
            result["total_operands"] = structure["total_operands"]

        return result
    
    def sympy_to_json_serializable(self, obj):
        """Convert SymPy objects to JSON-serializable format"""
        import sympy as sp

        if obj is None:
            return None

        # ‚úÖ Handle tuples FIRST (convert to lists and process recursively)
        if isinstance(obj, tuple):
            return [self.sympy_to_json_serializable(item) for item in obj]

        # ‚úÖ Handle SymPy expressions EARLY (before checking Basic/Matrix)
        # This catches Mul, Add, Pow, Rational, etc.
        if isinstance(obj, sp.Expr) and not isinstance(obj, sp.MatrixBase):
            # Try to simplify to a number first
            try:
                simplified = sp.simplify(obj)
                if simplified.is_Integer:
                    return int(simplified)
                elif simplified.is_Rational:
                    return float(simplified)
                elif simplified.is_Float:
                    return float(simplified)
            except:
                pass
            # Fall back to string representation
            return str(obj)

        # Handle specific SymPy number types
        if isinstance(obj, (sp.core.numbers.One, sp.core.numbers.Zero, 
                           sp.core.numbers.NegativeOne)):
            return int(obj)

        if isinstance(obj, sp.Integer):
            return int(obj)

        if isinstance(obj, sp.Rational):
            return float(obj)

        if isinstance(obj, sp.Float):
            return float(obj)

        # ‚úÖ Handle SymPy matrices with metadata
        if isinstance(obj, sp.MatrixBase):
            matrix_data = [[self.sympy_to_json_serializable(cell) for cell in row] 
                    for row in obj.tolist()]

            # Check if matrix has operation metadata
            if hasattr(obj, '_matrix_op_metadata'):
                metadata = obj._matrix_op_metadata
                window.console.log(f"‚úÖ Serializing matrix with {len(metadata['operations'])} operation(s)")

                # ‚úÖ CRITICAL: Recursively serialize all metadata content
                return {
                    "_type": "matrix_with_ops",
                    "data": matrix_data,
                    "metadata": {
                        "operations": self.sympy_to_json_serializable(metadata["operations"]),
                        "original_shape": metadata["original_shape"]
                    }
                }

            return matrix_data

        # Handle any other Basic (catch-all for SymPy objects)
        if isinstance(obj, sp.Basic):
            return str(obj)

        # Handle lists recursively
        if isinstance(obj, list):
            return [self.sympy_to_json_serializable(item) for item in obj]

        # Handle dicts recursively
        if isinstance(obj, dict):
            return {key: self.sympy_to_json_serializable(value) 
                    for key, value in obj.items()}

        # Return as-is for primitive types (str, int, float, bool)
        return obj
    
    def __init__(self):
        from lark import Lark
        self.update_status("‚è≥ Building parser...")
        self.parser = Lark(self.GRAMMAR, parser="earley", start="start")
        self.transformer = self._create_transformer()
        self.update_status("‚úì Parser ready")

    def update_status(self, msg):
        container = document.querySelector("#loadingStatus")
        if container:
            div = document.createElement("div")
            div.appendChild(document.createTextNode(msg))
            container.appendChild(div)
    
    def _preprocess_row_operations(self, latex_str):
        """
        Safe preprocessing: only apply row-operation regexes to the operation part.
        Normalizes matrix numbers separately so matrix content is not mangled.
        """
        import re

        # 0. Quick generic cleanups that are safe everywhere
        s = latex_str.replace(r'\ ', ' ')
        s = s.replace(r'\left(', '(').replace(r'\right)', ')')
        s = s.replace(r'\left[', '[').replace(r'\right]', ']')
        s = s.replace(r'\left\{', '{').replace(r'\right\}', '}')
        s = s.replace(r'\left|', '|').replace(r'\right|', '|')
        s = s.replace(r'\cdot', '*')

        # Split into matrix part and operations part.
        # Prefer explicit '|' split. If no pipe, attempt to split at arrow (\to or ->).
        if '|' in s:
            matrix_part, ops_part = s.split('|', 1)
        else:
            # attempt to split at first arrow occurrence
            m = re.search(r'(\\to|\\rightarrow|->|<-)','%s' % s)
            if m:
                # split so matrix_part includes everything before arrow, ops_part includes arrow+rest
                idx = m.start()
                matrix_part = s[:idx]
                ops_part = s[idx:]
            else:
                # nothing to do: treat entire string as matrix_part (no row op)
                matrix_part, ops_part = s, ''

        # -------------------------
        # Normalize matrix_part (do NOT run row-op rewrites here)
        # -------------------------
        # 1) collapse repeated spaces
        matrix_part = re.sub(r'\s+', ' ', matrix_part).strip()

        # 2) Remove stray spaces between minus and number/fraction inside matrix
        #    Examples: [0, - 1, - \frac{1}{2}] -> [0, -1, -\frac{1}{2}]
        matrix_part = re.sub(r'-\s+\\frac', r'-\\frac', matrix_part)          # - \frac -> -\frac
        matrix_part = re.sub(r'-\s+(\d)', r'-\1', matrix_part)                 # - 1 -> -1
        matrix_part = re.sub(r'(\{)\s+', r'\1', matrix_part)                  # remove space after { 
        matrix_part = re.sub(r'\s+(\})', r'\1', matrix_part)                  # remove space before }
        matrix_part = re.sub(r'\[\s+', '[', matrix_part)
        matrix_part = re.sub(r'\s+\]', ']', matrix_part)

        # 3) (Optional) convert simple LaTeX fractions in matrix to explicit form so parser sees them consistently
        #    e.g. replace \frac{1}{2} with (1/2) ‚Äî only inside matrix part
        #    If you prefer leaving \frac for parser, skip this.
        matrix_part = re.sub(r'\\frac\{([^{}]+)\}\{([^{}]+)\}', r'(\1/\2)', matrix_part)

        # -------------------------
        # Now operate on ops_part only (row-operation specific rewrites)
        # -------------------------
        ops = ops_part  # local alias for clarity

        if ops:
            # 1) Ensure there's a space after arrows so tokenizer can separate parts
            ops = re.sub(r'\\to(?=\S)', r'\\to ', ops)
            ops = re.sub(r'\\rightarrow(?=\S)', r'\\rightarrow ', ops)
            ops = re.sub(r'->(?=\S)', r'-> ', ops)
            ops = re.sub(r'<-(?=\S)', r'<- ', ops)

            # 2) Fix fractions with row reference in denominator: \frac{1}{2R_3} -> (1/2)R_3
            ops = re.sub(r'\\frac\{([^{}]+)\}\{\(?(\d+)\)?R_(\d+)\}', r'(\1/\2)R_\3', ops)

            # 3) Fix fractions before row reference: \frac{1}{2}R_ -> (1/2)R_
            ops = re.sub(r'\\frac\{([^{}]+)\}\{\(?([^{}]+?)\)?\}R_', r'(\1/\2)R_', ops)

            # 4) Negative fractions -\frac{...}R_ -> (-1/2)R_
            ops = re.sub(r'-\\frac\{([^{}]+)\}\{\(?([^{}]+?)\)?\}R_', r'(-\1/\2)R_', ops)

            # 5) Fix fractions in combines: R_2+\frac{1}{2}R_3 -> R_2+(1/2)R_3
            ops = re.sub(r'([+\-])\\frac\{([^{}]+)\}\{\(?([^{}]+?)\)?\}R_', r'\1(\2/\3)R_', ops)

            # 6) Remove outer wrapping parentheses from row scale expressions
            ops = re.sub(r'\((-?\([^)]+\)R_\d+)\)', r'\1', ops)
            ops = re.sub(
                r'(R_\d+\s*(?:\\to|\\rightarrow|->)\s*)\(([^()]+R_\d+)\)(?=\s*(?:\||$))',
                r'\1\2',
                ops
            )
            ops = re.sub(r'\((R_\d+)\)', r'\1', ops)

            # 7) Remove single-number parentheses before R_: (2)R_1 -> 2R_1; (-2)R_1 -> -2R_1
            ops = re.sub(r'\((\d+)\)R_', r'\1R_', ops)
            ops = re.sub(r'\((-\d+)\)R_', r'\1R_', ops)

            # 7.5 Insert implicit coefficient 1 in row combinations (ONLY in ops_part)
            # Handles: R_2-R_1 -> R_2-1R_1 ; R_2+R_1 -> R_2+1R_1
            ops = re.sub(r'(R_\d+)\s*([+\-])\s*R_', r'\1\g<2>1R_', ops)

            # 7c. Force spaces around + and - inside ops_part so lexer never fuses +5 into a single token
            ops = re.sub(r'([+\-])', r' \1 ', ops)

            # 7d. Canonicalize multiple +/- combos: "--"->"+", "+-"|"-+"->"-"
            ops = re.sub(r'\+\s*\+', ' + ', ops)
            ops = re.sub(r'-\s*-', ' + ', ops)
            ops = re.sub(r'\+\s*-|-\s*\+', ' - ', ops)

            # 8) Clean up multiple spaces in ops
            ops = re.sub(r'\s+', ' ', ops).strip()

        # -------------------------
        # Recombine matrix_part and ops_part (if ops existed)
        # -------------------------
        if ops:
            # Ensure single pipe between matrix and ops
            out = matrix_part.strip() + '|' + ops
        else:
            out = matrix_part.strip()

        # Final cleanup (a little extra safety)
        out = re.sub(r'\|{2,}', '|', out)
        out = re.sub(r'\s+', ' ', out).strip()
        out = re.sub(r'\|\s*$', '', out)  # remove trailing pipe
        # --- Step 7: Final sanity rewrite for self-row combos ---
        # Convert R_n+nR_n ‚Üí R_n-(-n)R_n
            # --- Step 7: Final rewrite for all "+" row operations ---
        # Convert any R_n1 + nR_n2 ‚Üí R_n1 - (-n)R_n2
        out = re.sub(
            r'(R_(\d+))\s*\+\s*([0-9]+)R_(\d+)',
            lambda m: f"{m.group(1)} - (-{m.group(3)})R_{m.group(4)}",
            out
        )

        # Convert any R_n1 + R_n2 ‚Üí R_n1 - (-1)R_n2
        out = re.sub(
            r'(R_(\d+))\s*\+\s*R_(\d+)',
            lambda m: f"{m.group(1)} - (-1)R_{m.group(3)}",
            out
        )

        return out


    
    def _preprocess_derivatives(self, latex_str):
        """
        Rewrites \frac{d}{dx}(...) and \frac{\partial}{\partial x}(...)
        patterns into unique function calls before parsing.
        """
        import re

        # 1. Handle total derivatives: \frac{d}{dx}(...)
        total_derivative_pattern = re.compile(r"\\frac\{d\}\{d([a-zA-Z]+)\}\(([^)]+)\)")
        total_replacement = r"__derivative(\1, \2)"
        processed_str = total_derivative_pattern.sub(total_replacement, latex_str)

        # 2. Handle partial derivatives: \frac{\partial}{\partial x}(...)
        partial_derivative_pattern = re.compile(r"\\frac\{\\partial\}\{\\partial\s*([a-zA-Z]+)\}\(([^)]+)\)")
        partial_replacement = r"__partial_derivative(\1, \2)"
        final_str = partial_derivative_pattern.sub(partial_replacement, processed_str)

        return final_str

    # -----------------------------------------------------
    # ‚úÖ Parse LaTeX to Sympy with popup error display
        # ... rest of method unchanged            
        # window.console.log(f"üîç Parse tree: {tree.pretty()}")
    # -----------------------------------------------------
    def parse_latex(self, latex):
        """Parse LaTeX to SymPy expression with error popup display"""
        import re
        from lark.exceptions import UnexpectedToken, UnexpectedCharacters, UnexpectedEOF

        window.console.log(f"üîç [DEBUG 1] Original LaTeX: {latex}")

        cleaned = self.clean_latex(latex)
        window.console.log(f"üîç [DEBUG 2] After clean_latex: {cleaned}")

        clean = self._preprocess_derivatives(cleaned)
        window.console.log(f"üîç [DEBUG 3] After preprocess_derivatives: {clean}")

        # Preprocess row operations
        clean = self._preprocess_row_operations(clean)
        window.console.log(f"üîç [DEBUG 4] After preprocess_row_operations: {clean}")
        window.console.log(f"Cleaned LaTeX: {clean}")

        try:
            window.console.log(f"üîç [DEBUG 5] About to call parser.parse()...")
            tree = self.parser.parse(clean)
            window.console.log(f"üîç [DEBUG 6] Parse successful, tree type: {type(tree)}")

            window.console.log(f"üîç [DEBUG 7] About to call transformer.transform()...")
            result = self.transformer.transform(tree)
            window.console.log(f"üîç Transformed result: {result}")
            return result

        except (UnexpectedToken, UnexpectedCharacters, UnexpectedEOF) as e:
            pos = getattr(e, "pos_in_stream", None)
            line = getattr(e, "line", "?")
            col = getattr(e, "column", "?")
            # Remove "Expected ‚Ä¶" section from Lark message
            raw_msg = str(e)
            simplified_msg = re.sub(r"Expected one of:.*", "", raw_msg, flags=re.DOTALL).strip()
            # Build context with caret (FIXED: use 'clean' instead of 't')
            try:
                span = 35
                start = max(0, (pos or 0) - span)
                end = min(len(clean), (pos or 0) + span)  # FIXED: was 't'
                snippet = clean[start:end]  # FIXED: was 't'
                caret_pos = (pos or 0) - start
                caret_line = " " * caret_pos + "‚Üë"
                context = f"{snippet}\n{caret_line}"
            except Exception:
                context = clean  # FIXED: was 't'
            msg = (
                f"‚ùå Parse error in LaTeX:\n\n"
                f"Line: {line}, Column: {col}\n"
                f"Type: {type(e).__name__}\n"
                f"Message: {simplified_msg}\n\n"
                f"Context:\n{context}"
            )
            self._show_error_popup(msg)
            window.console.error(msg)
            return None

        except Exception as e:
            window.console.error(f"‚ùå [DEBUG ERROR] Exception type: {type(e).__name__}")
            window.console.error(f"‚ùå [DEBUG ERROR] Exception message: {str(e)}")
            import traceback
            tb_str = traceback.format_exc()
            window.console.error(f"‚ùå [DEBUG ERROR] Traceback:\n{tb_str}")

            msg = f"‚ùå General parse error: {e}"
            window.console.error(msg)
            self._show_error_popup(msg)
            return None

    # -----------------------------------------------------
    # ‚úÖ Popup with top-right close button
    # -----------------------------------------------------
    def _show_error_popup(self, message):
        """Display error popup with close button - optimized for mobile"""
        safe_msg = message.replace("`", "'").replace("\\", "\\\\").replace("\n", "\\n")
        js_code = f"""
            (function(){{
                let existing = document.querySelector('#parseErrorPopup');
                if(existing) existing.remove();

                let popup = document.createElement('div');
                popup.id = 'parseErrorPopup';

                // Detect if mobile/small screen
                let isMobile = window.innerWidth <= 768;

                if(isMobile) {{
                    // Mobile styles - fullscreen-like
                    popup.style.cssText = `
                        position:fixed;
                        top:0;
                        left:0;
                        right:0;
                        bottom:0;
                        background:#f8fafc;
                        color:#0f172a;
                        font-family:monospace;
                        padding:60px 16px 16px 16px;
                        border:none;
                        border-radius:0;
                        box-shadow:none;
                        white-space:pre-wrap;
                        z-index:9999;
                        overflow:auto;
                        -webkit-overflow-scrolling:touch;
                    `;
                }} else {{
                    // Desktop styles - centered dialog
                    popup.style.cssText = `
                        position:fixed;
                        top:50%;
                        left:50%;
                        transform:translate(-50%, -50%);
                        background:#f8fafc;
                        color:#0f172a;
                        font-family:monospace;
                        padding:24px 24px 16px 24px;
                        border:2px solid #ef4444;
                        border-radius:12px;
                        box-shadow:0 12px 40px rgba(0,0,0,0.2);
                        white-space:pre;
                        z-index:9999;
                        max-width:650px;
                        max-height:70vh;
                        overflow:auto;
                    `;
                }}

                let btn = document.createElement('button');
                btn.textContent = '‚úñ';
                btn.title = 'Close';

                if(isMobile) {{
                    btn.style.cssText = `
                        position:fixed;
                        top:12px;
                        right:12px;
                        width:44px;
                        height:44px;
                        border:none;
                        background:#ef4444;
                        color:#fff;
                        font-size:24px;
                        font-weight:bold;
                        cursor:pointer;
                        line-height:1;
                        border-radius:8px;
                        box-shadow:0 4px 12px rgba(239,68,68,0.4);
                        z-index:10000;
                    `;
                }} else {{
                    btn.style.cssText = `
                        position:absolute;
                        top:8px;
                        right:10px;
                        border:none;
                        background:transparent;
                        color:#ef4444;
                        font-size:18px;
                        font-weight:bold;
                        cursor:pointer;
                        line-height:1;
                    `;
                }}
                btn.onclick = () => popup.remove();

                let content = document.createElement('div');
                content.textContent = `{safe_msg}`;
                content.style.paddingTop = '8px';

                popup.appendChild(btn);
                popup.appendChild(content);
                document.body.appendChild(popup);
            }})();
        """
        window.eval(js_code)
    
    # -----------------------------------------------------
    # ‚úÖ Clean LaTeX
    # -----------------------------------------------------
    def clean_latex(self, tex):
        """Normalize LaTeX string for parsing"""
        import re
        if not tex:
            return ""
        t = str(tex)

        # Remove \left and \right but keep the parentheses
        t = t.replace("\\left(", "(")
        t = t.replace("\\right)", ")")
        t = t.replace("\\left[", "[")
        t = t.replace("\\right]", "]")
        t = t.replace("\\left\\{", "{")
        t = t.replace("\\right\\}", "}")
        t = t.replace("\\left|", "|")
        t = t.replace("\\right|", "|")

        # Replace mathrm{d} with d
        t = t.replace("\\mathrm{d}", "d")

        # Remove spacing macros
        t = re.sub(r"\\(?:,|;|:|!|quad|qquad| )", "", t)

        # Protect matrix row separators
        t = re.sub(r"\\\\\s*", "\\\\", t)

        # Ensure & separators have no surrounding whitespace
        t = re.sub(r"\s*&\s*", "&", t)

        # Remove whitespace
        t = re.sub(r"\s+", "", t)

        # ‚≠ê CRITICAL FIX v3: Add * between digit and letter (including after minus sign)
        # Match: <digit><letter> but NOT consume any preceding minus
        # Examples:
        #   4x -> 4*x
        #   2x -> 2*x
        # This pattern uses a positive lookbehind to ensure we have a digit before the letter
        t = re.sub(r'(\d)([a-zA-Z])', r'\1*\2', t)

        return t.strip()


    # -----------------------------------------------------
    # ‚úÖ Transformer creation
    # -----------------------------------------------------
    def _create_transformer(self):
      """Create the Lark transformer with improved rules"""
      from lark import Transformer, v_args
      import sympy as sp

      def canonical_scalar(x):
        """Convert/normalize a value to a canonical SymPy scalar (Integer/Rational/Float simplified)."""
        if not isinstance(x, sp.Basic):
            try:
                x = sp.sympify(x)
            except Exception:
                # keep as-is fallback
                return x
        # Prefer exact rationals for floats represented as strings
        if isinstance(x, sp.Float):
            try:
                x = sp.Rational(str(x))
            except Exception:
                pass
        # Simplify and evaluate any Mul/Add wrappers (handles Mul(-1,n) -> -n)
        x = sp.simplify(x)
        try:
            x = x.doit()
        except Exception:
            pass
        return sp.simplify(x)




      @v_args(inline=True)
      class Latex2Sympy(Transformer):
          def paren_expr(self, expr):
              return expr

          def braces_expr(self, expr):
              return expr

          def number(self, tok):
              s = str(tok)
              return sp.Integer(s) if '.' not in s else sp.Float(s)

          def symbol(self, tok):
              s = str(tok).strip()
              return sp.Symbol(s[1:] if s.startswith("\\") else s)

          def pi_symbol(self, _):
              return sp.pi

          def infty_symbol(self, _):
              return sp.oo

          def infinity(self, tok):
              s = str(tok)
              return -sp.oo if s.startswith('-') else sp.oo

          def abs_func(self, expr):
              return sp.Abs(expr)

          def neg(self, v):
              return sp.Mul(-1, v, evaluate=False)

          def add(self, a, b):
              return sp.Add(a, b, evaluate=False)

          def sub(self, a, b):
              return sp.Add(a, sp.Mul(-1, b, evaluate=False), evaluate=False)

          def mul(self, a, b):
            if isinstance(a, (sp.MatrixBase, sp.MatrixExpr)) or isinstance(b, (sp.MatrixBase, sp.MatrixExpr)):
                a_ = sp.UnevaluatedExpr(a) if isinstance(a, (sp.MatrixBase, sp.MatrixExpr)) else a
                b_ = sp.UnevaluatedExpr(b) if isinstance(b, (sp.MatrixBase, sp.MatrixExpr)) else b
                return sp.Mul(a_, b_, evaluate=False)
            # ‚úÖ Change: Use evaluate=False consistently
            return sp.Mul(a, b, evaluate=False)  # Changed from evaluate=True

          def div(self, a, b):
              return sp.Mul(a, sp.Pow(b, -1, evaluate=False), evaluate=False)

          def frac(self, numerator, denominator):
              return sp.Mul(numerator, sp.Pow(denominator, -1, evaluate=False), evaluate=False)

          def trig_func(self, func_name, expr):
              func_str = str(func_name).strip().replace("\\", "")
              func_map = {
                  "sin": sp.sin,
                  "cos": sp.cos,
                  "tan": sp.tan,
                  "cot": sp.cot,
                  "sec": sp.sec,
                  "csc": sp.csc,
                  "arcsin": sp.asin,
                  "arccos": sp.acos,
                  "arctan": sp.atan,
              }
              func = func_map.get(func_str)
              if func:
                  return func(expr)
              return sp.Function(func_str)(expr)

          def log_func(self, func_name, expr):
              func_str = str(func_name).strip().replace("\\", "")
              if func_str == "ln":
                  return sp.ln(expr)
              elif func_str == "log":
                  return sp.log(expr, 10)
              elif func_str == "exp":
                  return sp.exp(expr)
              return sp.Function(func_str)(expr)

          def limit_expr(self, var, value, expr):
            return sp.Limit(expr, sp.Symbol(str(var)), value)

          def implicit_mul(self, a, b):
              if isinstance(a, sp.Matrix) or isinstance(b, sp.Matrix):
                  return sp.Mul(a, b, evaluate=False)
              return sp.Mul(a, b, evaluate=False)

          def power(self, a, b):
              """
              Handle right-associative power like 10^100^0 correctly.
              Lark gives us nested trees due to right recursion.
              """
              import sympy as sp

              # If right child is another power, handle it recursively.
              # Example: a=10, b=Pow(100, 0) -> Pow(10, (100**0))
              if isinstance(b, sp.Pow):
                  return sp.Pow(a, b, evaluate=False)

              return sp.Pow(a, b, evaluate=False)
            
          # --- NEW METHOD FOR DEGREES ---
          def atom_to_degree(self, tree):
            """
            Handles expressions like 90^\circ.
            Converts degrees to radians by multiplying by pi/180.
            """
            atom = tree.children[0]
            return sp.pi * atom / 180

          def elements(self, *items):
              return list(items)

          def row(self, elements):
              return list(elements) if isinstance(elements, (list, tuple)) else [elements]

          def matrix_rows(self, *rows):
            row_list = [list(r) if isinstance(r, (list, tuple)) else [r]    for r in rows]
            return sp.Matrix(row_list)

          def matrix_env(self, *args):
              rows = []
              for a in args:
                  if a is None:
                      continue
                  if isinstance(a, list) and a and all(isinstance(x, (list, tuple)) for x in a):
                      rows.extend([list(r) for r in a])
                  elif isinstance(a, (list, tuple)):
                      rows.append(list(a))
                  else:
                      rows.append([a])
              return sp.Matrix(rows)

          def scalar_matrix_mul(self, scalar, matrix):
              return sp.Mul(scalar, matrix, evaluate=False)

          def row_reference(self, i):
              return ("ref", int(i))

          def row_scale(self, factor, i):
              return ("scale", int(i), factor)

          def row_replace(self, target, arrow, expr):
            return ("replace", int(target), expr)

          def row_swap(self, i, swap_arrow, j):
            return ("swap", int(i), int(j))

          def row_combine(self, i, op, factor, j):
            op_str = str(op).strip()
            return ("combine", int(i), op_str, factor, int(j))

          def matrix_apply_ops(self, matrix, *ops):
            import sympy as sp
            # Ensure we have a writable SymPy Matrix copy
            m = sp.Matrix(matrix) if not isinstance(matrix, sp.Matrix) else matrix.copy()

            # Store original matrix and operations as metadata
            original_matrix = m.copy()
            operations_list = []

            # Canonicalize input matrix elements up-front (avoids '- 1' split issues)
            m = m.applyfunc(canonical_scalar)

            for op in ops:
                # ‚úÖ Record the operation before applying it
                operations_list.append({
                    "type": op[0],
                    "details": list(op[1:]) if len(op) > 1 else []
                })

                if op[0] == "replace":
                    _, target, expr = op
                    tgt = int(target) - 1  # 0-based

                    if expr[0] == "ref":
                        _, src = expr
                        # copy row to avoid aliasing
                        m[tgt, :] = m[int(src)-1, :].copy()

                    elif expr[0] == "scale":
                        _, src, factor = expr
                        src_row = [canonical_scalar(v) for v in list(m[int(src)-1, :].copy())]
                        factor_sym = canonical_scalar(factor)
                        new_elems = [ canonical_scalar(factor_sym * v) for v in src_row ]
                        m[tgt, :] = sp.Matrix([ new_elems ]).reshape(1, m.cols)

                    elif expr[0] == "combine":
                        _, src, op_str, factor, other = expr
                        src_idx = int(src) - 1
                        other_idx = int(other) - 1

                        # CRITICAL: copy both source rows so we compute from originals
                        src_row = [ canonical_scalar(v) for v in list(m[src_idx, :].copy()) ]
                        other_row = [ canonical_scalar(v) for v in list(m[other_idx, :].copy()) ]

                        factor_sym = canonical_scalar(factor)

                        new_elems = []
                        for a, b in zip(src_row, other_row):
                            if op_str == "+":
                                val = canonical_scalar(a + factor_sym * b)
                            else:
                                val = canonical_scalar(a - factor_sym * b)
                            new_elems.append(val)

                        m[tgt, :] = sp.Matrix([ new_elems ]).reshape(1, m.cols)

                elif op[0] == "swap":
                    _, i, j = op
                    i0, j0 = int(i)-1, int(j)-1
                    temp = m[i0, :].copy()
                    m[i0, :] = m[j0, :].copy()
                    m[j0, :] = temp

            # final pass to ensure everything canonicalized
            result = m.applyfunc(canonical_scalar)

            # ‚úÖ Store metadata on the result matrix
            # This allows extract_structure to detect the operations
            result._matrix_op_metadata = {
                "operations": operations_list,
                "original_shape": (original_matrix.rows, original_matrix.cols)
            }

            window.console.log(f"‚úÖ Matrix operations stored: {len(operations_list)} operation(s)")

            return result

          # --- METHODS FOR PREPROCESSED DERIVATIVES ---
          def derivative_func(self, var, expr):
              """Handles the preprocessed __derivative(var, expr) call."""
              return sp.Derivative(expr, sp.Symbol(str(var)))

          def partial_derivative_func(self, var, expr):
              """Handles the preprocessed __partial_derivative(var, expr) call."""
              return sp.Derivative(expr, sp.Symbol(str(var)))

          def start(self, e):
              return e

      return Latex2Sympy()
    
    def validate_limit(self, limit_expr):
      """
      Validate if a limit problem is suitable for students.
      Returns (is_valid, error_message)

      Invalid cases:
      1. Different left and right limit values (discontinuity)
      2. Oscillating limits (e.g., sin(1/x) as x->0)
      3. Limits that evaluate to infinity
      """
      import sympy as sp

      if not isinstance(limit_expr, sp.Limit):
          return (True, None)  # Not a limit, skip validation

      try:
          # Get the limit components
          expr = limit_expr.args[0]
          var = limit_expr.args[1]
          point = limit_expr.args[2]

          # Evaluate the limit
          limit_value = limit_expr.doit()

          # Check 1: Limit evaluates to infinity
          if limit_value.has(sp.oo) or limit_value == sp.oo or limit_value == -sp.oo:
              return (False, f"Limit evaluates to infinity: {limit_value}")

          # Check 2: Limit does not exist (returns unevaluated or NaN)
          if isinstance(limit_value, sp.Limit) or limit_value is sp.nan:
              return (False, "Limit does not exist or cannot be determined")

          # Check 3: Different left and right limits (if approaching a finite point)
          if point != sp.oo and point != -sp.oo:
              try:
                  left_limit = sp.limit(expr, var, point, '-')
                  right_limit = sp.limit(expr, var, point, '+')

                  # Simplify both limits
                  left_simplified = sp.simplify(left_limit)
                  right_simplified = sp.simplify(right_limit)

                  # Check if they're different
                  if not sp.simplify(left_simplified - right_simplified) == 0:
                      return (False, f"Left and right limits differ: left={left_simplified}, right={right_simplified}")
              except:
                  pass

          # Check 4: Oscillating behavior (limit doesn't exist due to oscillation)
          # This is tricky - we check if the limit is AccumBounds or contains zoo
          if hasattr(limit_value, 'is_finite') and not limit_value.is_finite:
              if limit_value != sp.oo and limit_value != -sp.oo:
                  return (False, "Limit oscillates or is undefined")

          # Check for AccumBounds (accumulated bounds, indicates oscillation)
          if 'AccumBounds' in str(type(limit_value)):
              return (False, "Limit oscillates between multiple values")

          # Check for zoo (complex infinity, often from oscillation)
          if limit_value == sp.zoo:
              return (False, "Limit is complex infinity (oscillation or undefined)")

          return (True, None)

      except Exception as e:
          window.console.error(f"Error validating limit: {e}")
          return (False, f"Error evaluating limit: {str(e)}")
    
    # -----------------------------------------------------
    # ‚úÖ Extract structure, normalize, and compare
    # -----------------------------------------------------
    def extract_structure(self, expr):
        """Extract structural fingerprint of expression INCLUDING matrix operations"""
        import sympy as sp, traceback
        operators, operands, matrix_ops = {}, {}, []

        def process(node, parent_op=None):
            nonlocal matrix_ops

            if node is None:
                return
            if isinstance(node, (tuple, list)) and all(isinstance(i, sp.Integer) for i in node):
                return

            # ‚úÖ NEW: Detect matrix operations by checking for our custom marker attribute
            if isinstance(node, sp.MatrixBase):
                # Check if this matrix has row operation metadata
                if hasattr(node, '_matrix_op_metadata'):
                    metadata = node._matrix_op_metadata
                    matrix_ops.append({
                        "type": "matrix_with_row_ops",
                        "operations": metadata["operations"],
                        "original_shape": metadata["original_shape"]
                    })
                    window.console.log(f"‚úÖ Detected matrix with row operations: {len(metadata['operations'])} ops")

                for el in node:
                    process(el, parent_op)
                return

            if isinstance(node, sp.MatrixExpr) and not isinstance(node, sp.MatrixBase):
                operands[str(node)] = operands.get(str(node), 0) + 1
                return

            # Check if this is a Mul(-1, x) pattern (negation)
            if isinstance(node, sp.Mul) and len(node.args) == 2:
                a, b = node.args
                if a == sp.Integer(-1) and isinstance(b, (sp.Symbol, sp.Number)):
                    # Let Sympy simplify instead of manual handling
                    simplified = sp.simplify(node)
                    str_val = str(simplified)
                    operands[str_val] = operands.get(str_val, 0) + 1
                    window.console.log(f"‚úÖ Simplified Mul(-1, {b}) -> {str_val}")
                    return

            if hasattr(node, "args") and len(node.args) > 0:
                op_name = type(node).__name__
                if op_name == "Tuple":
                    for c in node.args:
                        process(c, parent_op)
                    return
                if not (op_name == "Mul" and (parent_op == "Mul" or len(node.args) == 1)):
                    operators[op_name] = operators.get(op_name, 0) + 1
                for c in node.args:
                    process(c, op_name)
                return
            val = str(node).strip().replace(" ", "")
            if val == "-1":
                return
            operands[val] = operands.get(val, 0) + 1

        try:
            process(expr)
        except Exception as e:
            window.console.log(f"extract_structure error: {e}")
            window.console.log(traceback.format_exc())

        return {
            "operators": operators,
            "operands": operands,
            "matrix_ops": matrix_ops,  # ‚úÖ NEW: Include matrix operations
            "total_ops": sum(operators.values()),
            "total_operands": sum(operands.values())
        }

    def normalize_expr(self, expr):
        """Normalize and simplify expressions - with better sanity check"""
        import sympy as sp

        if expr is None:
            return None

        try:
            window.console.log(f"üîß NORMALIZE INPUT: {expr}")
            window.console.log(f"üîß NORMALIZE INPUT (srepr): {sp.srepr(expr)}")

            # Store original for comparison
            original_expr = expr

            if hasattr(expr, "doit"):
                window.console.log(f"DEBUG: Expression has doit, calling it...") 
                expr = expr.doit()
                window.console.log(f"DEBUG: After doit: {expr}")
                window.console.log(f"DEBUG: After doit (srepr): {sp.srepr(expr)}")

            if isinstance(expr, list):
                expr = sp.Matrix(expr)
            if isinstance(expr, sp.Matrix):
                expr = expr.applyfunc(sp.simplify)
            else:
                if isinstance(expr, sp.Mul) and not expr.is_Number:
                    args = expr.args
                    has_matrix = any(isinstance(a, sp.Matrix) for a in args)
                    has_scalar = any(not isinstance(a, sp.Matrix) for a in args)
                    if has_matrix and has_scalar:
                        return sp.Mul(*args, evaluate=True)

                # Store expression after doit but before simplify
                after_doit = expr
                window.console.log(f"üîß Before simplify: {after_doit}")

                # ‚úÖ LIGHT normalization
                expr = sp.simplify(expr)
                window.console.log(f"üîß NORMALIZE OUTPUT: {expr}")
                window.console.log(f"üîß NORMALIZE OUTPUT (srepr): {sp.srepr(expr)}")

                # ‚úÖ IMPROVED SANITY CHECK: Test multiple values
                try:
                    free_syms = list(original_expr.free_symbols)
                    if free_syms:
                        # Test with multiple values including 2.5, 3.7, -1.5
                        test_values = [2.5, 3.7, -1.5, 10.0]

                        for test_x in test_values:
                            test_subs = {sym: test_x for sym in free_syms}

                            # Evaluate both
                            try:
                                original_numeric = complex(original_expr.subs(test_subs))
                                normalized_numeric = complex(expr.subs(test_subs))
                                after_doit_numeric = complex(after_doit.subs(test_subs))

                                diff_orig_norm = abs(original_numeric - normalized_numeric)
                                diff_doit_norm = abs(after_doit_numeric - normalized_numeric)

                                window.console.log(f"Test @ x={test_x}:")
                                window.console.log(f"  Original: {original_numeric}")
                                window.console.log(f"  After doit: {after_doit_numeric}")
                                window.console.log(f"  After simplify: {normalized_numeric}")
                                window.console.log(f"  Diff (orig vs norm): {diff_orig_norm}")
                                window.console.log(f"  Diff (doit vs norm): {diff_doit_norm}")

                                if diff_orig_norm > 1e-6:
                                    window.console.error(f"‚ö†Ô∏è NORMALIZATION BROKE EXPRESSION at x={test_x}!")
                                    window.console.error(f"   Difference: {diff_orig_norm}")
                                    # Return the expression after doit, not after simplify
                                    window.console.error(f"   Returning after-doit version instead")
                                    return after_doit

                            except (ZeroDivisionError, OverflowError) as e:
                                window.console.warn(f"  Skipping x={test_x} due to: {e}")
                                continue

                        window.console.log(f"‚úì Sanity check passed all test values")
                except Exception as sanity_err:
                    window.console.warn(f"‚ö†Ô∏è Sanity check failed (non-fatal): {sanity_err}")

        except Exception as e:
            window.console.error(f"ERROR inside normalize: {e}")
            import traceback
            window.console.error(traceback.format_exc())
            return expr

        return expr

    def final_eq(self, a, b):
        """Check equality for scalar or matrix expressions with multiple strategies"""
        import sympy as sp
        try:
            # Handle matrix comparisons
            if isinstance(a, sp.MatrixBase) and isinstance(b, sp.MatrixBase):
                if a.shape != b.shape:
                    return False
                for i in range(a.rows):
                    for j in range(a.cols):
                        if not sp.simplify(a[i, j] - b[i, j]) == 0:
                            return False
                return True
            if isinstance(a, sp.MatrixBase) and isinstance(b, list):
                return self.final_eq(a, sp.Matrix(b))
            if isinstance(b, sp.MatrixBase) and isinstance(a, list):
                return self.final_eq(sp.Matrix(a), b)

            # ‚úÖ STRATEGY: Multiple passes with increasing aggressiveness
            # This handles expressions built with evaluate=False

            # Strategy 1: Direct comparison (fastest, handles simple cases)
            try:
                if a == b:
                    window.console.log("‚úì Strategy 1: Direct comparison succeeded")
                    return True
            except:
                pass

            # Strategy 2: Simplify difference (handles most cases)
            try:
                diff = sp.simplify(a - b)
                if diff == 0:
                    window.console.log("‚úì Strategy 2: Simplify difference succeeded")
                    return True
            except:
                pass

            # Strategy 3: Expand then simplify (handles unevaluated Mul/Add with evaluate=False)
            try:
                a_expanded = sp.expand(a)
                b_expanded = sp.expand(b)
                diff = sp.simplify(a_expanded - b_expanded)
                if diff == 0:
                    window.console.log("‚úì Strategy 3: Expand then simplify succeeded")
                    return True
            except:
                pass

            # Strategy 4: Full normalization pipeline (handles complex cases)
            try:
                # Apply multiple simplification passes
                a_norm = sp.simplify(sp.expand(a))
                b_norm = sp.simplify(sp.expand(b))

                # Try difference first
                diff = sp.simplify(a_norm - b_norm)
                if diff == 0:
                    window.console.log("‚úì Strategy 4a: Normalized difference succeeded")
                    return True

                # Try direct comparison
                if a_norm == b_norm:
                    window.console.log("‚úì Strategy 4b: Normalized direct comparison succeeded")
                    return True
            except:
                pass

            # Strategy 5: PowerSimp + Collect (handles nested powers and like terms)
            try:
                a_processed = sp.simplify(sp.powsimp(sp.expand(a), force=True))
                b_processed = sp.simplify(sp.powsimp(sp.expand(b), force=True))

                diff = sp.simplify(a_processed - b_processed)
                if diff == 0:
                    window.console.log("‚úì Strategy 5: PowerSimp succeeded")
                    return True
            except:
                pass

            # Strategy 6: SymPy's equals method (most robust but slowest)
            try:
                result = a.equals(b)
                if result:
                    window.console.log("‚úì Strategy 6: equals() method succeeded")
                return result
            except:
                pass

            window.console.log("‚úó All comparison strategies failed")
            return False

        except Exception as e:
            window.console.error(f"final_eq error: {e}")
            # Last resort: try equals method
            try:
                return a.equals(b)
            except:
                return False

class Step:
    """Represents a single step in a problem (animated feedback + structure checking + matrix ops support)"""
    
    def __init__(self, container, step_index, math_parser, parent_problem, step_type="step-by-step"):  # ‚úÖ ADDED step_type
        self.container = container
        self.step_index = step_index
        self.math_parser = math_parser
        self.parent_problem = parent_problem
        self.step_type = step_type  # ‚úÖ ADDED this line
        self.dom_element = None
        self.description_editor_id = None
        self.expr_mf = None
        self.expected_mf = None
        self.user_mf = None
        self.feedback_el = None
        self.parse_preview_el = None
        self.loaded_expected_structure = None
        
        # ‚úÖ ADDED: Type-specific containers
        self.options = []
        self.options_container = None
        self.tf_container = None
        self.fill_blank_container = None
        self.blanks = []
        self.explanation_editor_id = None
        
        self._create_ui()
    
    def _create_ui(self):
        """Create the UI for this step"""
        wrapper = document.createElement("div")
        wrapper.className = "step"
        wrapper.innerHTML = f"""
          <div style="display:flex; justify-content:space-between; align-items:center;">
            <strong>Step {self.step_index}</strong>
            <div style="display:flex; gap:8px; align-items:center;">
              <select class="stepTypeSelect" style="padding:4px 8px; font-size:12px; border:1px solid #dbe9ff; border-radius:6px;">
                <option value="step-by-step">Expression & Answer</option>
                <option value="multiple-choice-single">Multiple Choice (Single)</option>
                <option value="multiple-choice-multiple">Multiple Choice (Multiple)</option>
                <option value="true-false">True/False</option>
                <option value="fill-blank">Fill in the Blank</option>
              </select>
              <button class="btn ghost duplicateStep" style="color:#3b82f6;">üìã Duplicate</button>
              <button class="btn ghost removeStep">Remove</button>
              </div>
          </div>
          <label style="margin-top:8px;">Description</label>
          <div class="quill-container step-desc-editor"></div>

          <!-- Dynamic content container based on step type -->
          <div class="stepTypeContent" style="margin-top:12px;"></div>
        """
        self.container.appendChild(wrapper)
        self.dom_element = wrapper

        # Store references
        self.type_select_el = wrapper.querySelector(".stepTypeSelect")
        self.type_content_el = wrapper.querySelector(".stepTypeContent")

        # Set initial type
        if self.type_select_el:
            self.type_select_el.value = self.step_type

        # Setup Quill editor
        self.description_editor_id = f"step-desc-{uuid.uuid4().hex[:8]}"
        desc_container = wrapper.querySelector(".step-desc-editor")
        desc_container.setAttribute("id", self.description_editor_id)

        window.setTimeout(create_proxy(lambda: self._init_quill_editor()), 100)

        # ‚úÖ Wire events FIRST (only for header elements)
        self._wire_events()

        # ‚úÖ Then render type-specific UI (which wires its own buttons)
        self._render_type_specific_ui()

    def _wire_events(self):
      """Wire up event handlers with comprehensive safety checks"""
      # Capture self explicitly for closures
      step_ref = self

      # Duplicate step button
      duplicate_btn = self.dom_element.querySelector(".duplicateStep")
      if duplicate_btn:
          def handle_duplicate(e):
              step_ref._duplicate_step(e)
          duplicate_btn.addEventListener("click", create_proxy(handle_duplicate))

      # Remove step button (should always exist)
      remove_btn = self.dom_element.querySelector(".removeStep")
      if remove_btn:
          def handle_remove(e):
              step_ref._remove_step(e)
          remove_btn.addEventListener("click", create_proxy(handle_remove))
      else:
          window.console.warn(f"Step {self.step_index}: Remove button not found")

      # Type selector (only exists in new multi-type system)
      type_select = self.dom_element.querySelector(".stepTypeSelect")
      if type_select:
          def handle_type_change(e):
              step_ref._on_type_change(e)
          type_select.addEventListener("change", create_proxy(handle_type_change))
          window.console.log(f"Step {self.step_index}: Type selector wired")

      # Step-by-step buttons (only exist when that UI is rendered)
      generate_btn = self.dom_element.querySelector(".generateAnswer")
      if generate_btn:
          def handle_generate(e):
              step_ref._generate_answer(e)
          generate_btn.addEventListener("click", create_proxy(handle_generate))

      check_exp_btn = self.dom_element.querySelector(".checkExpected")
      if check_exp_btn:
          def handle_check_expected(e):
              step_ref._check_expected(e)
          check_exp_btn.addEventListener("click", create_proxy(handle_check_expected))

      check_user_btn = self.dom_element.querySelector(".checkUser")
      if check_user_btn:
          def handle_check_user(e):
              step_ref._check_user_answer(e)
          check_user_btn.addEventListener("click", create_proxy(handle_check_user))

      check_parse_btn = self.dom_element.querySelector(".checkParse")
      if check_parse_btn:
          def handle_check_parse(e):
              step_ref._preview_parse(e)
          check_parse_btn.addEventListener("click", create_proxy(handle_check_parse))

      analyze_btn = self.dom_element.querySelector(".analyzeStructure")
      if analyze_btn:
          def handle_analyze(e):
              step_ref._analyze_structure(e)
          analyze_btn.addEventListener("click", create_proxy(handle_analyze))

    def _duplicate_step(self, e):
        """Duplicate this step with all its content"""
        if self.parent_problem:
            # Serialize current step data before duplicating
            step_data = self._serialize_step_data()
            self.parent_problem.duplicate_step(self, step_data)
        if hasattr(window, 'problem_creator'):
            window.problem_creator.data_manager.save_to_storage()
                              
    def _serialize_step_data(self):
        """Serialize all data from this step"""
        data = {
            'step_type': self.step_type,
            'description_delta': None,
        }
        
        # Serialize description editor content using the correct method
        if self.description_editor_id:
            js_code = f"""
            (function() {{{{
                const quill = window.quillEditors && window.quillEditors['{self.description_editor_id}'];
                if (quill) {{{{
                    return JSON.stringify(quill.getContents());
                }}}}
                return null;
            }}}})();
            """
            try:
                result = window.eval(js_code)
                if result:
                    data['description_delta'] = result
                    window.console.log(f"‚úì Serialized description for step {self.step_index}")
            except Exception as e:
                window.console.error(f"Error serializing description: {e}")
        
        # Serialize type-specific content
        if self.step_type == "step-by-step":
            # Get MathQuill field content
            if self.expr_mf:
                data['expression'] = self.expr_mf.latex()
            if self.expected_mf:
                data['expected_answer'] = self.expected_mf.latex()
            if self.loaded_expected_structure:
                data['expected_structure'] = self.loaded_expected_structure
                
        elif self.step_type in ["multiple-choice-single", "multiple-choice-multiple"]:
            # Get options with their Quill content
            data['options'] = []
            
            # Find which option is marked as correct answer - try multiple selectors
            correct_answer_select = None
            
            # Try different ways to find the correct answer dropdown
            selectors_to_try = [
                '.correctAnswerSelect',
                'select[id*="correct"]',
                'select[id*="answer"]',
                '.mc-correct-select',
            ]
            
            for selector in selectors_to_try:
                correct_answer_select = self.dom_element.querySelector(selector)
                if correct_answer_select:
                    data['correct_answer'] = correct_answer_select.value
                    window.console.log(f"‚úì Correct answer captured from {selector}: {correct_answer_select.value}")
                    break
            
            if not correct_answer_select:
                # Last resort: find any select that's not the step type select
                all_selects = self.dom_element.querySelectorAll('select')
                for sel in all_selects:
                    if 'stepTypeSelect' not in sel.className:
                        data['correct_answer'] = sel.value
                        window.console.log(f"‚úì Correct answer captured (fallback): {sel.value}")
                        break
            
            for i, opt in enumerate(self.options):
                opt_data = {
                    'is_correct': opt['checkbox'].checked if opt.get('checkbox') else False,
                    'content_delta': None
                }
                
                # Get Quill content for this option
                if opt.get('editor_id'):
                    js_code = f"""
                    (function() {{{{
                        const quill = window.quillEditors && window.quillEditors['{opt['editor_id']}'];
                        if (quill) {{{{
                            return JSON.stringify(quill.getContents());
                        }}}}
                        return null;
                    }}}})();
                    """
                    try:
                        result = window.eval(js_code)
                        if result:
                            opt_data['content_delta'] = result
                            window.console.log(f"‚úì Serialized option {chr(65 + i)} content")
                    except Exception as e:
                        window.console.error(f"Error serializing option {i}: {e}")
                
                data['options'].append(opt_data)
                
        elif self.step_type == "true-false":
            # Get selected answer
            true_radio = self.dom_element.querySelector('input[value="true"]')
            false_radio = self.dom_element.querySelector('input[value="false"]')
            if true_radio and true_radio.checked:
                data['tf_answer'] = 'true'
            elif false_radio and false_radio.checked:
                data['tf_answer'] = 'false'
                
        elif self.step_type == "fill-blank":
            # Get blanks
            data['blanks'] = []
            for blank in self.blanks:
                blank_data = {
                    'answer': blank['input_el'].value if blank.get('input_el') else ''
                }
                data['blanks'].append(blank_data)
        
        # Get explanation editor content
        if self.explanation_editor_id:
            js_code = f"""
            (function() {{{{
                const quill = window.quillEditors && window.quillEditors['{self.explanation_editor_id}'];
                if (quill) {{{{
                    return JSON.stringify(quill.getContents());
                }}}}
                return null;
            }}}})();
            """
            try:
                result = window.eval(js_code)
                if result:
                    data['explanation_delta'] = result
                    window.console.log(f"‚úì Serialized explanation for step {self.step_index}")
            except Exception as e:
                window.console.error(f"Error serializing explanation: {e}")
        
        window.console.log(f"üì¶ Serialized step data: {data}")
        return data
                              
    def _on_type_change(self, e):
        """Handle step type change"""
        new_type = self.type_select_el.value

        if self.step_type != new_type:
            if not window.confirm("Changing step type will clear existing content. Continue?"):
                self.type_select_el.value = self.step_type
                return

        self.step_type = new_type
        self._render_type_specific_ui()

        if hasattr(window, 'problem_creator'):
            window.problem_creator.data_manager.save_to_storage()

    def _render_type_specific_ui(self):
        """Render UI based on step type"""
        self.type_content_el.innerHTML = ""

        if self.step_type == "step-by-step":
            self._render_step_by_step_ui()
        elif self.step_type == "multiple-choice-single":
            self._render_mc_single_ui()
        elif self.step_type == "multiple-choice-multiple":
            self._render_mc_multiple_ui()
        elif self.step_type == "true-false":
            self._render_true_false_ui()
        elif self.step_type == "fill-blank":
            self._render_fill_blank_ui()
    
    def _render_step_by_step_ui(self):
        """Render traditional expression/expected/user UI"""
        self.type_content_el.innerHTML = """
    <div style="margin-top:8px; display:flex; flex-direction:column; gap:10px;">
      <div style="width:100%;">
        <label>Expression</label>
        <div class="math-input step-expr" style="transition:box-shadow 0.4s, border-color 0.4s;"></div>
      </div>
      <div style="width:100%;">
        <label>Expected Answer</label>
        <div class="math-input step-expected" style="transition:box-shadow 0.4s, border-color 0.4s;"></div>
      </div>
      <div style="width:100%; position:relative;">
        <label>User Answer (Simulation)</label>
        <div class="math-input step-user" style="transition:box-shadow 0.4s, border-color 0.4s;"></div>
        <div class="user-feedback" 
             style="position:absolute; top:6px; right:8px; font-weight:600; font-size:13px; color:#64748b;">
        </div>
      </div>
    </div>

    <div style="margin-top:6px; display:flex; gap:6px; flex-wrap:wrap;">
      <button class="btn ghost generateAnswer" style="font-size:12px;">Generate Answer</button>
      <button class="btn ghost checkExpected" style="font-size:12px;">Check Expected</button>
      <button class="btn ghost checkUser" style="font-size:12px;">Check User Answer</button>
      <button class="btn ghost checkParse" style="font-size:12px;">Preview Parse</button>
      <button class="btn ghost analyzeStructure" style="font-size:12px;">üîç Analyze Structure</button>
    </div>

    <div style="margin-top:8px;">
      <div class="small parsePreview" style="margin-top:6px; white-space:pre-wrap;"></div>
    </div>
        """

        self.parse_preview_el = self.type_content_el.querySelector(".parsePreview")
        self.feedback_el = self.type_content_el.querySelector(".user-feedback")

        # Initialize math fields
        self._init_math_fields()

        # ‚úÖ Wire buttons AFTER HTML is rendered
        self._wire_step_by_step_buttons()

    def _wire_step_by_step_buttons(self):
        """Wire up buttons for step-by-step type"""
        generate_btn = self.type_content_el.querySelector(".generateAnswer")
        if generate_btn:
            generate_btn.addEventListener("click", create_proxy(self._generate_answer))

        check_exp_btn = self.type_content_el.querySelector(".checkExpected")
        if check_exp_btn:
            check_exp_btn.addEventListener("click", create_proxy(self._check_expected))

        check_user_btn = self.type_content_el.querySelector(".checkUser")
        if check_user_btn:
            check_user_btn.addEventListener("click", create_proxy(self._check_user_answer))

        check_parse_btn = self.type_content_el.querySelector(".checkParse")
        if check_parse_btn:
            check_parse_btn.addEventListener("click", create_proxy(self._preview_parse))

        analyze_btn = self.type_content_el.querySelector(".analyzeStructure")
        if analyze_btn:
            analyze_btn.addEventListener("click", create_proxy(self._analyze_structure))
    
    def _init_quill_editor(self):
        """Initialize Quill editor for step description"""
        if not hasattr(window, 'quillBlotsInitialized'):
            init_quill_blots()
            window.quillBlotsInitialized = True
        create_quill_editor(self.description_editor_id, "Describe this step...")
    
    def _init_math_fields(self):
        ensure_mq()
        self.expr_mf = create_math_field(self.dom_element.querySelector(".step-expr"))
        self.expected_mf = create_math_field(self.dom_element.querySelector(".step-expected"))
        self.user_mf = create_math_field(self.dom_element.querySelector(".step-user"))
    
    # ========================================
    # Multiple Choice (Single) UI - WITH QUILL EDITORS
    # ========================================

    def _render_mc_single_ui(self):
        """Render multiple choice (single answer) UI with Quill editors"""
        self.type_content_el.innerHTML = """
          <!-- ‚úÖ NEW: Require Correct Answer Checkbox -->
          <div style="margin-top:8px; margin-bottom:12px;">
            <label style="display:flex; align-items:center; gap:8px; font-size:14px; cursor:pointer;">
              <input type="checkbox" class="requireCorrectCheckbox" 
                     style="width:16px; height:16px; cursor:pointer;">
              <span style="font-weight:600;">Require correct answer before proceeding to next step</span>
            </label>
          </div>

          <div class="optionsContainer" style="margin-top:10px;"></div>
          <button class="btn ghost addOption" style="font-size:12px; margin-top:8px;">‚ûï Add Option</button>

          <div style="margin-top:12px;">
            <label>Correct Answer</label>
            <select class="correctAnswerSelect" style="width:100%; padding:6px; border:2px solid #e6eef8; border-radius:6px; margin-top:4px;">
              <option value="">-- Select Correct Answer --</option>
            </select>
          </div>
        """

        self.options = []
        self.options_container = self.type_content_el.querySelector(".optionsContainer")

        # Wire add option button
        add_btn = self.type_content_el.querySelector(".addOption")
        if add_btn:
            add_btn.addEventListener("click", create_proxy(lambda e: self._add_mc_option()))

        # ‚úÖ Wire require correct checkbox to trigger autosave
        require_checkbox = self.type_content_el.querySelector(".requireCorrectCheckbox")
        if require_checkbox:
            def on_require_change(e):
                if hasattr(window, 'problem_creator'):
                    window.problem_creator.data_manager.save_to_storage()
                    window.console.log(f"‚úì Require correct changed to: {e.target.checked}")
            require_checkbox.addEventListener("change", create_proxy(on_require_change))

        # Wire correct answer dropdown to trigger autosave
        select = self.type_content_el.querySelector(".correctAnswerSelect")
        if select:
            def on_correct_answer_change(e):
                if hasattr(window, 'problem_creator'):
                    window.problem_creator.data_manager.save_to_storage()
                    window.console.log(f"‚úì Correct answer changed to: {e.target.value}")
            select.addEventListener("change", create_proxy(on_correct_answer_change))

        # Add initial options
        for label in ['A', 'B']:
            self._add_mc_option(label)

    def _add_mc_option(self, label=None):
        """Add MC option with full Quill editor"""
        if label is None:
            used_labels = [opt['label'] for opt in self.options]
            all_labels = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']
            for lbl in all_labels:
                if lbl not in used_labels:
                    label = lbl
                    break

        if label is None:
            window.alert("Maximum 8 options allowed")
            return

        option_div = document.createElement("div")
        option_div.className = "mc-option"
        option_div.setAttribute("data-label", label)
        option_div.style.cssText = "margin-bottom:12px; padding:12px; border:2px solid #e6eef8; border-radius:8px; background:#f8fafc;"

        # Create unique editor ID
        editor_id = f"mc-option-{self.step_index}-{label}-{uuid.uuid4().hex[:6]}"

        option_div.innerHTML = f"""
          <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
            <strong style="font-size:15px; color:#0369a1;">Option {label}</strong>
            <button class="btn ghost removeOption" style="padding:4px 8px; font-size:11px;">üóëÔ∏è Remove</button>
          </div>
          <div class="quill-container option-editor" id="{editor_id}" 
               style="min-height:80px; background:white; border:2px solid #e6eef8; border-radius:6px;"></div>
        """

        self.options_container.appendChild(option_div)

        # Wire remove button
        remove_btn = option_div.querySelector(".removeOption")
        if remove_btn:
            def make_remove_handler(lbl):
                return lambda e: self._remove_mc_option(lbl)
            remove_btn.addEventListener("click", create_proxy(make_remove_handler(label)))

        # Store option data
        option_data = {
            'label': label,
            'dom': option_div,
            'editor_id': editor_id
        }
        self.options.append(option_data)

        # Initialize Quill editor for this option
        window.setTimeout(create_proxy(lambda: self._init_option_quill_editor(editor_id)), 150)

        self._update_correct_answer_dropdown()

    def _init_option_quill_editor(self, editor_id):
        """Initialize Quill editor for a specific option"""
        if not hasattr(window, 'quillBlotsInitialized'):
            init_quill_blots()
            window.quillBlotsInitialized = True

        create_quill_editor(editor_id, "Enter option content (text, math, images)...")
        window.console.log(f"‚úì Initialized Quill editor for option: {editor_id}")

    def _remove_mc_option(self, label):
        """Remove MC option and relabel remaining options"""
        # Find and remove the option
        option_to_remove = None
        for opt in self.options:
            if opt['label'] == label:
                option_to_remove = opt
                break

        if option_to_remove:
            # ‚úÖ STEP 1: Get current correct answer(s) before removal
            old_correct_answer = None
            old_correct_answers = []

            if self.step_type == "multiple-choice-single":
                select = self.type_content_el.querySelector(".correctAnswerSelect")
                if select:
                    old_correct_answer = select.value
            elif self.step_type == "multiple-choice-multiple":
                checkboxes = self.type_content_el.querySelectorAll(".correctAnswerCheckbox:checked")
                for cb in checkboxes:
                    old_correct_answers.append(cb.value)

            # ‚úÖ STEP 2: Remove from options list
            self.options.remove(option_to_remove)

            # ‚úÖ STEP 3: Remove Quill instance
            editor_id = option_to_remove['editor_id']
            js_code = f"""
            (function() {{
                if (window.quillEditors && window.quillEditors['{editor_id}']) {{
                    delete window.quillEditors['{editor_id}'];
                }}
            }})();
            """
            window.eval(js_code)

            # ‚úÖ STEP 4: Remove DOM element
            option_to_remove['dom'].remove()

            # ‚úÖ STEP 5: Relabel remaining options and create mapping
            label_mapping = {}  # old_label -> new_label
            all_labels = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']

            for i, opt in enumerate(self.options):
                old_label = opt['label']
                new_label = all_labels[i]
                label_mapping[old_label] = new_label

                if old_label != new_label:
                    # Update the option's label
                    opt['label'] = new_label

                    # Update the DOM
                    label_el = opt['dom'].querySelector("strong")
                    if label_el:
                        label_el.textContent = f"Option {new_label}"

                    # Update data-label attribute
                    opt['dom'].setAttribute("data-label", new_label)

            window.console.log(f"‚úì Relabeled options: {label_mapping}")

            # ‚úÖ STEP 6: Update correct answer(s) based on mapping
            new_correct_answer = None
            new_correct_answers = []

            if self.step_type == "multiple-choice-single":
                # Update single choice correct answer
                if old_correct_answer:
                    if old_correct_answer == label:
                        # Removed option was the correct answer - clear it
                        new_correct_answer = ""
                        window.console.log(f"‚ö†Ô∏è Correct answer '{label}' was removed, cleared")
                    elif old_correct_answer in label_mapping:
                        # Correct answer needs to be relabeled
                        new_correct_answer = label_mapping[old_correct_answer]
                        window.console.log(f"‚úì Updated correct answer: {old_correct_answer} ‚Üí {new_correct_answer}")
                    else:
                        new_correct_answer = old_correct_answer

            elif self.step_type == "multiple-choice-multiple":
                # Update multiple choice correct answers
                for old_label in old_correct_answers:
                    if old_label == label:
                        # Removed option was a correct answer - skip it
                        window.console.log(f"‚ö†Ô∏è Correct answer '{label}' was removed")
                    elif old_label in label_mapping:
                        # Correct answer needs to be relabeled
                        new_label = label_mapping[old_label]
                        new_correct_answers.append(new_label)
                        window.console.log(f"‚úì Updated correct answer: {old_label} ‚Üí {new_label}")
                    else:
                        new_correct_answers.append(old_label)

            # ‚úÖ STEP 7: Update the UI with new correct answer(s)
            if self.step_type == "multiple-choice-single":
                self._update_correct_answer_dropdown()
                # Set the correct answer after dropdown is updated
                if new_correct_answer:
                    select = self.type_content_el.querySelector(".correctAnswerSelect")
                    if select:
                        select.value = new_correct_answer
            else:
                self._update_correct_answer_checkboxes()
                # Set the correct answers after checkboxes are updated
                if new_correct_answers:
                    checkboxes = self.type_content_el.querySelectorAll(".correctAnswerCheckbox")
                    for cb in checkboxes:
                        if cb.value in new_correct_answers:
                            cb.checked = True

            # Trigger autosave
            if hasattr(window, 'problem_creator'):
                window.problem_creator.data_manager.save_to_storage()

            window.console.log(f"‚úÖ Option removed and relabeled successfully")

    def _update_correct_answer_dropdown(self):
        """Update dropdown with current options"""
        select = self.type_content_el.querySelector(".correctAnswerSelect")
        if not select:
            return

        # Store current value before rebuilding
        current = select.value

        # Rebuild dropdown
        select.innerHTML = '<option value="">-- Select Correct Answer --</option>'

        for opt in self.options:
            option_el = document.createElement("option")
            option_el.value = opt['label']
            option_el.textContent = f"Option {opt['label']}"
            select.appendChild(option_el)

        # Only restore if current value still exists in options
        if current in [opt['label'] for opt in self.options]:
            select.value = current

        # ‚úÖ NEW: Re-wire event listener after rebuilding (in case it was lost)
        # Remove old listener first to avoid duplicates
        select_clone = select.cloneNode(True)
        select.parentNode.replaceChild(select_clone, select)

        def on_correct_answer_change(e):
            if hasattr(window, 'problem_creator'):
                window.problem_creator.data_manager.save_to_storage()
                window.console.log(f"‚úì Correct answer changed to: {e.target.value}")

        select_clone.addEventListener("change", create_proxy(on_correct_answer_change))

        # Restore value on the cloned element
        if current in [opt['label'] for opt in self.options]:
            select_clone.value = current

    # ========================================
    # Multiple Choice (Multiple) UI - WITH QUILL EDITORS
    # ========================================

    def _render_mc_multiple_ui(self):
        """Render MC multiple answers UI with Quill editors"""
        self.type_content_el.innerHTML = """
          <!-- ‚úÖ NEW: Require Correct Answer Checkbox -->
          <div style="margin-top:8px; margin-bottom:12px;">
            <label style="display:flex; align-items:center; gap:8px; font-size:14px; cursor:pointer;">
              <input type="checkbox" class="requireCorrectCheckbox" 
                     style="width:16px; height:16px; cursor:pointer;">
              <span style="font-weight:600;">Require correct answer before proceeding to next step</span>
            </label>
          </div>

          <div class="optionsContainer" style="margin-top:10px;"></div>
          <button class="btn ghost addOption" style="font-size:12px; margin-top:8px;">‚ûï Add Option</button>

          <div style="margin-top:12px;">
            <label>Correct Answers (check all that apply)</label>
            <div class="correctAnswersCheckboxes" style="margin-top:6px; padding:10px; border:2px solid #e6eef8; border-radius:6px; background:#f8fafc;">
              <em style="color:#64748b; font-size:12px;">Add options first</em>
            </div>
          </div>
        """

        self.options = []
        self.options_container = self.type_content_el.querySelector(".optionsContainer")

        add_btn = self.type_content_el.querySelector(".addOption")
        if add_btn:
            add_btn.addEventListener("click", create_proxy(lambda e: self._add_mc_option_multi()))

        # ‚úÖ NEW: Wire require correct checkbox to trigger autosave
        require_checkbox = self.type_content_el.querySelector(".requireCorrectCheckbox")
        if require_checkbox:
            def on_require_change(e):
                if hasattr(window, 'problem_creator'):
                    window.problem_creator.data_manager.save_to_storage()
                    window.console.log(f"‚úì Require correct changed to: {e.target.checked}")
            require_checkbox.addEventListener("change", create_proxy(on_require_change))

        # Note: Checkboxes are created dynamically in _update_correct_answer_checkboxes
        # Event listeners will be added there

        for label in ['A', 'B']:
            self._add_mc_option_multi(label)

    def _add_mc_option_multi(self, label=None):
        """Add option for multiple-answer MC (uses same Quill-based method)"""
        self._add_mc_option(label)
        self._update_correct_answer_checkboxes()

    def _update_correct_answer_checkboxes(self):
        """Update checkboxes with current options"""
        container = self.type_content_el.querySelector(".correctAnswersCheckboxes")
        if not container:
            return

        # Store currently checked labels before rebuilding
        checked_labels = []
        existing = container.querySelectorAll('input:checked')
        for cb in existing:
            checked_labels.append(cb.value)

        # Rebuild checkboxes
        container.innerHTML = ""

        if len(self.options) == 0:
            container.innerHTML = '<em style="color:#64748b; font-size:12px;">Add options first</em>'
            return

        for opt in self.options:
            label_div = document.createElement("label")
            label_div.style.cssText = "display:flex; align-items:center; gap:8px; margin-bottom:6px; cursor:pointer; font-size:13px; padding:6px; border-radius:4px; transition:background 0.15s;"
            label_div.onmouseover = create_proxy(lambda e: e.currentTarget.style.setProperty('background', '#e0f2fe'))
            label_div.onmouseout = create_proxy(lambda e: e.currentTarget.style.setProperty('background', 'transparent'))

            cb = document.createElement("input")
            cb.type = "checkbox"
            cb.value = opt['label']
            cb.className = "correctAnswerCheckbox"
            cb.style.cssText = "width:18px; height:18px; cursor:pointer;"

            # Only check if this label was previously checked
            if opt['label'] in checked_labels:
                cb.checked = True

            # ‚úÖ NEW: Add event listener to trigger autosave when checkbox changes
            def on_checkbox_change(e):
                if hasattr(window, 'problem_creator'):
                    window.problem_creator.data_manager.save_to_storage()
                    # Get all checked values
                    checked = []
                    checkboxes = container.querySelectorAll(".correctAnswerCheckbox:checked")
                    for checkbox in checkboxes:
                        checked.append(checkbox.value)
                    window.console.log(f"‚úì Correct answers updated: {checked}")

            cb.addEventListener("change", create_proxy(on_checkbox_change))

            span = document.createElement("span")
            span.textContent = f"Option {opt['label']}"
            span.style.fontWeight = "600"

            label_div.appendChild(cb)
            label_div.appendChild(span)
            container.appendChild(label_div)

    # ========================================
    # True/False UI
    # ========================================

    def _render_true_false_ui(self):
        """Render true/false UI"""
        unique_id = uuid.uuid4().hex[:8]

        self.type_content_el.innerHTML = f"""
          <!-- ‚úÖ NEW: Require Correct Answer Checkbox -->
          <div style="margin-top:8px; margin-bottom:12px;">
            <label style="display:flex; align-items:center; gap:8px; font-size:14px; cursor:pointer;">
              <input type="checkbox" class="requireCorrectCheckbox" 
                     style="width:16px; height:16px; cursor:pointer;">
              <span style="font-weight:600;">Require correct answer before proceeding to next step</span>
            </label>
          </div>

          <div style="margin-top:12px;">
            <label>Correct Answer</label>
            <div style="margin-top:6px; display:flex; gap:12px;">
              <label style="display:flex; align-items:center; gap:6px; cursor:pointer;">
                <input type="radio" name="tfAnswer_{unique_id}" value="true" class="tfTrue">
                <span style="font-weight:600; color:#16a34a;">True</span>
              </label>
              <label style="display:flex; align-items:center; gap:6px; cursor:pointer;">
                <input type="radio" name="tfAnswer_{unique_id}" value="false" class="tfFalse">
                <span style="font-weight:600; color:#dc2626;">False</span>
              </label>
            </div>
          </div>
        """

        self.tf_container = self.type_content_el

        # ‚úÖ Wire require correct checkbox to trigger autosave
        require_checkbox = self.type_content_el.querySelector(".requireCorrectCheckbox")
        if require_checkbox:
            def on_require_change(e):
                if hasattr(window, 'problem_creator'):
                    window.problem_creator.data_manager.save_to_storage()
                    window.console.log(f"‚úì Require correct changed to: {e.target.checked}")
            require_checkbox.addEventListener("change", create_proxy(on_require_change))

        # Add event listeners to radio buttons to trigger autosave
        tf_true = self.type_content_el.querySelector(".tfTrue")
        tf_false = self.type_content_el.querySelector(".tfFalse")

        def on_tf_change(e):
            if hasattr(window, 'problem_creator'):
                window.problem_creator.data_manager.save_to_storage()
                answer = "True" if e.target.value == "true" else "False"
                window.console.log(f"‚úì True/False answer changed to: {answer}")

        if tf_true:
            tf_true.addEventListener("change", create_proxy(on_tf_change))
        if tf_false:
            tf_false.addEventListener("change", create_proxy(on_tf_change))
    # ========================================
    # Fill-in-the-Blank UI
    # ========================================

    def _render_fill_blank_ui(self):
        """Render fill-blank UI - text answers only"""
        self.type_content_el.innerHTML = """
          <!-- ‚úÖ NEW: Require Correct Answer Checkbox -->
          <div style="margin-top:8px; margin-bottom:12px;">
            <label style="display:flex; align-items:center; gap:8px; font-size:14px; cursor:pointer;">
              <input type="checkbox" class="requireCorrectCheckbox"
                     style="width:16px; height:16px; cursor:pointer;">
              <span style="font-weight:600;">Require correct answer before proceeding to next step</span>
            </label>
          </div>

          <div style="margin-top:12px;">
            <label>Correct Answers (Text)</label>
            <div class="answersContainer" style="margin-top:6px;"></div>
            <button class="btn ghost addAnswer" style="margin-top:6px; font-size:12px;">‚ûï Add Alternative</button>
          </div>
        """

        self.fill_blank_container = self.type_content_el
        self.blanks = []

        # ‚úÖ Wire require correct checkbox to trigger autosave
        require_checkbox = self.type_content_el.querySelector(".requireCorrectCheckbox")
        if require_checkbox:
            def on_require_change(e):
                if hasattr(window, 'problem_creator'):
                    window.problem_creator.data_manager.save_to_storage()
                    window.console.log(f"‚úì Require correct changed to: {e.target.checked}")
            require_checkbox.addEventListener("change", create_proxy(on_require_change))

        add_btn = self.type_content_el.querySelector(".addAnswer")
        if add_btn:
            add_btn.addEventListener("click", create_proxy(lambda e: self._add_fill_blank_answer()))

        self._add_fill_blank_answer()

    def _add_fill_blank_answer(self):
        """Add text answer field"""
        answer_div = document.createElement("div")
        answer_div.style.cssText = "margin-bottom:6px; padding:8px; border:2px solid #e6eef8; border-radius:6px; background:white;"

        answer_div.innerHTML = """
          <div style="display:flex; justify-content:space-between; margin-bottom:4px;">
            <label style="font-size:12px; font-weight:600;">Text Answer</label>
            <button class="btn ghost removeAnswer" style="padding:2px 6px; font-size:10px;">Remove</button>
          </div>
          <input type="text" class="fbAnswerText" placeholder="Enter answer..."
                 style="width:100%; padding:6px; border:2px solid #e6eef8; border-radius:4px;">
        """

        container = self.type_content_el.querySelector(".answersContainer")
        if container:
            container.appendChild(answer_div)

        text_input = answer_div.querySelector(".fbAnswerText")

        # ‚úÖ Add event listener to text input for autosave
        if text_input:
            def on_text_change(e):
                if hasattr(window, 'problem_creator'):
                    window.problem_creator.data_manager.save_to_storage()
            text_input.addEventListener("input", create_proxy(on_text_change))

        self.blanks.append({
            'type': 'text',
            'dom': answer_div,
            'text_input': text_input
        })

        remove_btn = answer_div.querySelector(".removeAnswer")
        if remove_btn:
            # Use closure to capture answer_div
            def make_remove_handler(div):
                def handler(e):
                    self._remove_fill_blank_answer(div)
                    # ‚úÖ Trigger autosave after removing
                    if hasattr(window, 'problem_creator'):
                        window.problem_creator.data_manager.save_to_storage()
                return handler
            remove_btn.addEventListener("click", create_proxy(make_remove_handler(answer_div)))

    def _remove_fill_blank_answer(self, answer_div):
        """Remove answer"""
        self.blanks = [b for b in self.blanks if b['dom'] != answer_div]
        answer_div.remove()
    # ---------------------------------------------------------
    # üîÜ Visual Feedback Helpers
    # ---------------------------------------------------------

    def _animate_glow(self, element, color):
        """Temporary glowing border animation for visual feedback"""
        element.style.boxShadow = f"0 0 12px {color}"
        element.style.borderColor = color
        window.setTimeout(create_proxy(lambda: (
            element.style.setProperty("box-shadow", "0 0 0 transparent"),
            element.style.setProperty("border-color", "#e6eef8")
        )), 1200)

    def _show_feedback(self, state, text=None):
        """Show inline badge feedback"""
        if state == "correct":
            self.feedback_el.style.color = "#16a34a"
            self.feedback_el.textContent = text or "‚úÖ Correct"
            self._animate_glow(self.dom_element.querySelector(".step-user"), "#16a34a")
        elif state == "wrong":
            self.feedback_el.style.color = "#dc2626"
            self.feedback_el.textContent = text or "‚ùå Wrong"
            self._animate_glow(self.dom_element.querySelector(".step-user"), "#dc2626")
        elif state == "warn":
            self.feedback_el.style.color = "#ca8a04"
            self.feedback_el.textContent = text or "‚ö†Ô∏è Check"
            self._animate_glow(self.dom_element.querySelector(".step-user"), "#ca8a04")
        else:
            self.feedback_el.textContent = ""
            self.feedback_el.style.color = "#64748b"

    # ---------------------------------------------------------
    # üîç NEW: Structure Analysis
    # ---------------------------------------------------------
    
    def _analyze_structure(self, e):
        """Analyze and display the structure of the expected answer"""
        self.parse_preview_el.innerText = ""
        
        if not self.expected_mf:
            self.parse_preview_el.innerText = "‚ö†Ô∏è Expected answer field not ready"
            return
        
        latex = self.expected_mf.latex().strip()
        if not latex:
            self.parse_preview_el.innerText = "‚ö†Ô∏è Enter an expected answer first"
            self._animate_glow(self.dom_element.querySelector(".step-expected"), "#ca8a04")
            return
        
        try:
            window.console.log("=" * 60)
            window.console.log("üîç ANALYZING STRUCTURE")
            window.console.log(f"LaTeX: {latex}")
            
            # Parse the expression
            parsed = self.math_parser.parse_latex(latex)
            
            if parsed is None:
                self.parse_preview_el.innerText = "‚ùå Could not parse expected answer"
                self._animate_glow(self.dom_element.querySelector(".step-expected"), "#dc2626")
                return
            
            window.console.log(f"Parsed type: {type(parsed)}")
            window.console.log(f"Parsed value: {parsed}")
            
            # Extract structure
            raw_structure = self.math_parser.extract_structure(parsed)
            
            window.console.log("Raw extracted structure:")
            window.console.log(f"  Operators: {raw_structure.get('operators', {})}")
            window.console.log(f"  Operands: {raw_structure.get('operands', {})}")
            window.console.log(f"  Matrix ops: {raw_structure.get('matrix_ops', [])}")
            
            # ‚úÖ Convert to JSON-serializable format
            serializable_structure = self.math_parser.structure_to_json_serializable(raw_structure)
            
            window.console.log("Serializable structure:")
            window.console.log(json.dumps(serializable_structure, indent=2))
            
            # ‚úÖ Store it so it will be saved
            self.loaded_expected_structure = serializable_structure
            
            # Display in UI
            html_parts = [
                "<strong>üìä Structure Analysis:</strong><br><br>",
                f"<strong>Operators:</strong> {serializable_structure.get('operators', {})}<br>",
                f"<strong>Operands:</strong> {serializable_structure.get('operands', {})}<br>"
            ]
            
            # ‚úÖ Show matrix operations if present
            matrix_ops = serializable_structure.get('matrix_ops', [])
            if matrix_ops:
                html_parts.append(f"<br><strong>üî¢ Matrix Operations:</strong> {len(matrix_ops)} detected<br>")
                for i, op in enumerate(matrix_ops):
                    operations = op.get("operations", [])
                    num_ops = len(operations)
                    html_parts.append(f"&nbsp;&nbsp;‚Ä¢ Operation {i+1}: {op.get('type', 'unknown')}<br>")
                    html_parts.append(f"&nbsp;&nbsp;&nbsp;&nbsp;- {num_ops} row operation(s)<br>")
                    
                    # Show details of each operation
                    for j, row_op in enumerate(operations):
                        op_type = row_op.get("type", "unknown")
                        details = row_op.get("details", [])
                        html_parts.append(f"&nbsp;&nbsp;&nbsp;&nbsp;- Step {j+1}: {op_type} {details}<br>")
                
                self._animate_glow(self.dom_element.querySelector(".step-expected"), "#10b981")
            else:
                html_parts.append("<br><strong>Matrix Operations:</strong> None<br>")
            
            html_parts.append(f"<br><strong>Total:</strong> {serializable_structure.get('total_ops', 0)} operators, ")
            html_parts.append(f"{serializable_structure.get('total_operands', 0)} operands")
            
            self.parse_preview_el.innerHTML = "".join(html_parts)
            self.parse_preview_el.style.color = "#0369a1"
            self.parse_preview_el.style.background = "#f0f9ff"
            self.parse_preview_el.style.padding = "12px"
            self.parse_preview_el.style.borderRadius = "6px"
            self.parse_preview_el.style.border = "2px solid #0ea5e9"
            
            window.console.log("=" * 60)
            window.alert("‚úÖ Structure analyzed! Check the preview panel and console for details.")
        
        except Exception as e:
            window.console.error(f"Analysis error: {e}")
            import traceback
            window.console.error(traceback.format_exc())
            self.parse_preview_el.innerText = f"‚ùå Analysis failed: {e}"
            self._animate_glow(self.dom_element.querySelector(".step-expected"), "#dc2626")

    # ---------------------------------------------------------
    # üßÆ Core Step Logic
    # ---------------------------------------------------------

    def _remove_step(self, e):
        self.dom_element.remove()
        # Remove from parent problem's steps array
        if self.parent_problem:
            self.parent_problem.remove_step(self)
        if hasattr(window, 'problem_creator'):
            window.problem_creator.data_manager.save_to_storage()
        
    def _generate_answer(self, e):
        self.parse_preview_el.innerText = ""
        tex = self.expr_mf.latex().strip() if self.expr_mf else ""
        if not tex:
            self.parse_preview_el.innerText = "‚ö†Ô∏è Please enter an expression first."
            self._animate_glow(self.dom_element.querySelector(".step-expr"), "#ca8a04")
            return

        try:
            parsed = self.math_parser.parse_latex(tex)
            if parsed:
                # Validate limit problems before generating answer
                is_valid, error_msg = self.math_parser.validate_limit(parsed)

                if not is_valid:
                    self.parse_preview_el.innerText = (
                        f"‚ö†Ô∏è Invalid Limit Problem\n\n"
                        f"{error_msg}\n\n"
                        f"Limit problems must have:\n"
                        f"‚Ä¢ Finite, well-defined values\n"
                        f"‚Ä¢ Equal left and right limits\n"
                        f"‚Ä¢ No oscillation\n\n"
                        f"Please revise the expression."
                    )
                    self.parse_preview_el.style.whiteSpace = "pre-wrap"
                    self.parse_preview_el.style.color = "#dc2626"
                    self._animate_glow(self.dom_element.querySelector(".step-expr"), "#dc2626")
                    return

                # If valid or not a limit, proceed with normalization
                result = self.math_parser.normalize_expr(parsed)

                if isinstance(result, sp.Matrix):
                    # Convert matrix to bracket notation
                    matrix_list = self._make_json_serializable(result.tolist())

                    # Build LaTeX in bracket format: [[1,2],[3,4]]
                    rows_latex = []
                    for row in matrix_list:
                        row_str = ','.join([str(val) for val in row])
                        rows_latex.append(f"[{row_str}]")
                    matrix_latex = '[' + ','.join(rows_latex) + ']'

                    # Use \left[ \right] for better display in MathQuill
                    display_latex = '\\left[' + ','.join([f"\\left[{','.join([str(v) for v in row])}\\right]" for row in matrix_list]) + '\\right]'

                    self.expected_mf.latex(display_latex)

                    # For preview, show as JSON
                    pretty = json.dumps(matrix_list, indent=2)
                    self.parse_preview_el.innerText = f"‚úÖ Matrix Result:\n{pretty}"
                    self.parse_preview_el.style.color = "#16a34a"
                    self._animate_glow(self.dom_element.querySelector(".step-expected"), "#16a34a")
                    
                    # ‚úÖ Extract and store structure for matrices
                    try:
                        structure = self.math_parser.extract_structure(result)
                        self.loaded_expected_structure = self.math_parser.structure_to_json_serializable(structure)
                        window.console.log(f"‚úÖ Generated structure for matrix: {self.loaded_expected_structure}")
                    except Exception as e:
                        window.console.error(f"Failed to extract matrix structure: {e}")
                else:
                    latex_result = sp.latex(result)
                    self.expected_mf.latex(latex_result)
                    self.parse_preview_el.innerText = f"‚úÖ Simplified Result:\n{result}"
                    self.parse_preview_el.style.color = "#16a34a"
                    self._animate_glow(self.dom_element.querySelector(".step-expected"), "#16a34a")
                    
                    # ‚úÖ Extract and store structure
                    try:
                        structure = self.math_parser.extract_structure(result)
                        self.loaded_expected_structure = self.math_parser.structure_to_json_serializable(structure)
                        window.console.log(f"‚úÖ Generated structure: {self.loaded_expected_structure}")
                    except Exception as e:
                        window.console.error(f"Failed to extract structure: {e}")
        except Exception as ex:
            self.parse_preview_el.innerText = f"‚ùå Error generating: {ex}"
            self.parse_preview_el.style.color = "#dc2626"
            self._animate_glow(self.dom_element.querySelector(".step-expr"), "#dc2626")

        if hasattr(window, 'problem_creator'):
            window.problem_creator.data_manager.save_to_storage()

    def _make_json_serializable(self, obj):
        """Convert SymPy objects to JSON-serializable format"""
        import sympy as sp

        if obj is None:
            return None

        # Handle SymPy numbers
        if isinstance(obj, (sp.core.numbers.One, sp.core.numbers.Zero, 
                           sp.core.numbers.NegativeOne)):
            return int(obj)

        if isinstance(obj, sp.Integer):
            return int(obj)

        if isinstance(obj, sp.Rational):
            return float(obj)

        if isinstance(obj, sp.Float):
            return float(obj)

        # Handle SymPy matrices
        if isinstance(obj, sp.MatrixBase):
            return [[self._make_json_serializable(cell) for cell in row] 
                    for row in obj.tolist()]

        # Handle expressions - convert to string
        if isinstance(obj, sp.Basic):
            return str(obj)

        # Handle lists/tuples recursively
        if isinstance(obj, (list, tuple)):
            return [self._make_json_serializable(item) for item in obj]

        # Handle dicts recursively
        if isinstance(obj, dict):
            return {key: self._make_json_serializable(value) 
                    for key, value in obj.items()}

        # Return as-is for primitive types
        return obj

    def _convert_asciimath_to_latex_js(self, text):
        """Convert ASCII math to LaTeX using asciimath2tex library"""
        import re
        from js import window

        if not text or not isinstance(text, str):
            return text

        # Extract matrices in list-in-list format [[a,b],[c,d]]
        matrix_pattern = r'\[\[(?:[^\[\]]|\[[^\]]*\])*\]'
        matrices = []
        protected_text = text

        offset = 0
        for match in re.finditer(matrix_pattern, text):
            matrix_str = match.group(0)
            placeholder = f"__MATRIX_{len(matrices)}__"
            matrices.append(matrix_str)
            start = match.start() + offset
            end = match.end() + offset
            protected_text = protected_text[:start] + placeholder + protected_text[end:]
            offset += len(placeholder) - len(matrix_str)

        # Convert non-matrix parts using asciimath2tex
        safe_input = protected_text.replace('\\', '\\\\').replace('`', '\\`').replace('$', '\\$')

        js_code = """
        (function() {
            const input = `""" + safe_input + """`;
            if (typeof window.asciimath2tex !== 'undefined') {
                try {
                    return window.asciimath2tex(input);
                } catch(e) {
                    console.error('asciimath2tex failed:', e);
                    return input;
                }
            }
            return input;
        })()
        """

        try:
            latex_result = str(window.eval(js_code))
        except Exception as e:
            window.console.error(f"Conversion failed: {e}")
            latex_result = protected_text

        # Process each matrix - convert elements individually
        latex_matrices = []
        for matrix_str in matrices:
            inner = matrix_str[1:-1]
            row_pattern = r'\[[^\]]*\]'
            rows = re.findall(row_pattern, inner)

            converted_rows = []
            for row in rows:
                row_content = row[1:-1]
                elements = row_content.split(',')

                converted_elements = []
                for elem in elements:
                    elem = elem.strip()
                    safe_elem = elem.replace('\\', '\\\\').replace('`', '\\`').replace('$', '\\$')

                    elem_js_code = """
                    (function() {
                        const input = `""" + safe_elem + """`;
                        if (typeof window.asciimath2tex !== 'undefined') {
                            try {
                                return window.asciimath2tex(input);
                            } catch(e) {
                                return input;
                            }
                        }
                        return input;
                    })()
                    """

                    try:
                        converted_elem = str(window.eval(elem_js_code))
                        converted_elements.append(converted_elem)
                    except:
                        converted_elements.append(elem)

                converted_row = '[' + ','.join(converted_elements) + ']'
                converted_rows.append(converted_row)

            latex_matrix = '[' + ','.join(converted_rows) + ']'
            latex_matrices.append(latex_matrix)

        # Restore matrices with converted contents
        for i, latex_matrix in enumerate(latex_matrices):
            placeholder = f"__MATRIX_{i}__"
            latex_result = latex_result.replace(placeholder, latex_matrix)

        return latex_result
            
    def _check_expected(self, e):
        """Compare Expression vs Expected Answer, including structure with matrix ops"""
        self.parse_preview_el.innerText = ""
        try:
            expr_tex = self.expr_mf.latex().strip() if self.expr_mf else ""
            exp_tex  = self.expected_mf.latex().strip() if self.expected_mf else ""
            if not expr_tex:
                self.parse_preview_el.innerText = "‚ö†Ô∏è Enter expression first."
                self._animate_glow(self.dom_element.querySelector(".step-expr"), "#ca8a04")
                return

            window.console.log("=" * 60)
            window.console.log("üîç DEBUG: _check_expected called")
            window.console.log(f"Expression LaTeX: {expr_tex}")
            window.console.log(f"Expected LaTeX: {exp_tex}")

            expr_val = self.math_parser.parse_latex(expr_tex)
            exp_val  = self.math_parser.parse_latex(exp_tex)

            window.console.log(f"Expression parsed: {expr_val}")
            window.console.log(f"Expression type: {type(expr_val)}")
            if expr_val:
                window.console.log(f"Expression srepr: {sp.srepr(expr_val)}")

            window.console.log(f"Expected parsed: {exp_val}")
            window.console.log(f"Expected type: {type(exp_val)}")
            if exp_val:
                window.console.log(f"Expected srepr: {sp.srepr(exp_val)}")

            if expr_val is None or exp_val is None:
                self.parse_preview_el.innerText = "‚ùå Could not parse one or both sides."
                return

            # Validate limits
            is_expr_valid, expr_error_msg = self.math_parser.validate_limit(expr_val)
            if not is_expr_valid:
                self.parse_preview_el.innerText = f"‚ö†Ô∏è Invalid Limit in Expression\n\n{expr_error_msg}"
                self.parse_preview_el.style.color = "#dc2626"
                self._animate_glow(self.dom_element.querySelector(".step-expr"), "#dc2626")
                return

            is_exp_valid, exp_error_msg = self.math_parser.validate_limit(exp_val)
            if not is_exp_valid:
                self.parse_preview_el.innerText = f"‚ö†Ô∏è Invalid Limit in Expected Answer\n\n{exp_error_msg}"
                self.parse_preview_el.style.color = "#dc2626"
                self._animate_glow(self.dom_element.querySelector(".step-expected"), "#dc2626")
                return

            # ‚úÖ CRITICAL: Extract structures from RAW parsed expressions
            window.console.log("üìä Extracting structures from raw parsed expressions...")
            expr_struct = self.math_parser.extract_structure(expr_val)
            exp_struct  = self.math_parser.extract_structure(exp_val)
            window.console.log(f"Expression structure: {expr_struct}")
            window.console.log(f"Expected structure: {exp_struct}")

            # ‚úÖ Normalize ONLY for value comparison
            window.console.log("üîß Normalizing expressions...")
            expr_norm = self.math_parser.normalize_expr(expr_val)
            exp_norm  = self.math_parser.normalize_expr(exp_val)

            window.console.log(f"Expression normalized: {expr_norm}")
            window.console.log(f"Expression normalized type: {type(expr_norm)}")
            window.console.log(f"Expression normalized srepr: {sp.srepr(expr_norm)}")

            window.console.log(f"Expected normalized: {exp_norm}")
            window.console.log(f"Expected normalized type: {type(exp_norm)}")
            window.console.log(f"Expected normalized srepr: {sp.srepr(exp_norm)}")

            # Convert structures to serializable format for comparison
            expr_struct_json = self.math_parser.structure_to_json_serializable(expr_struct)
            exp_struct_json = self.math_parser.structure_to_json_serializable(exp_struct)

            # ‚úÖ Use aggressive final_eq for value comparison
            window.console.log("‚öñÔ∏è Comparing values...")
            are_equal = self.math_parser.final_eq(expr_norm, exp_norm)
            window.console.log(f"Comparison result: {are_equal}")

            if are_equal:
                msg = "‚úÖ Expressions match!\n"
                self._animate_glow(self.dom_element.querySelector(".step-expr"), "#16a34a")
                self._animate_glow(self.dom_element.querySelector(".step-expected"), "#16a34a")

                # ‚úÖ Compare structures including matrix_ops
                if expr_struct_json == exp_struct_json:
                    msg += "‚úÖ Structures also match perfectly!"
                else:
                    msg += "‚ö†Ô∏è Structure differs:\n\n"

                    # Check specific differences
                    if expr_struct_json.get("operators") != exp_struct_json.get("operators"):
                        msg += f"Operators differ:\n  Expr: {expr_struct_json.get('operators')}\n  Exp: {exp_struct_json.get('operators')}\n\n"

                    if expr_struct_json.get("operands") != exp_struct_json.get("operands"):
                        msg += f"Operands differ:\n  Expr: {expr_struct_json.get('operands')}\n  Exp: {exp_struct_json.get('operands')}\n\n"

                    # ‚úÖ Check matrix operations
                    if expr_struct_json.get("matrix_ops") != exp_struct_json.get("matrix_ops"):
                        expr_ops = expr_struct_json.get("matrix_ops", [])
                        exp_ops = exp_struct_json.get("matrix_ops", [])
                        msg += f"Matrix operations differ:\n  Expr has {len(expr_ops)} op(s)\n  Exp has {len(exp_ops)} op(s)\n"

                    self._animate_glow(self.dom_element.querySelector(".step-expected"), "#ca8a04")

                self.parse_preview_el.style.color = "#16a34a"
            else:
                msg = f"‚ùå Not equal.\nLeft: {expr_norm}\nRight: {exp_norm}"

                # Additional debug info
                window.console.log("‚ùå Expressions not equal, testing difference:")
                try:
                    diff = sp.simplify(expr_norm - exp_norm)
                    window.console.log(f"Difference (simplified): {diff}")

                    diff_expanded = sp.expand(expr_norm - exp_norm)
                    window.console.log(f"Difference (expanded): {diff_expanded}")
                except Exception as diff_err:
                    window.console.error(f"Error computing difference: {diff_err}")

                self._animate_glow(self.dom_element.querySelector(".step-expr"), "#dc2626")
                self._animate_glow(self.dom_element.querySelector(".step-expected"), "#dc2626")
                self.parse_preview_el.style.color = "#dc2626"

            self.parse_preview_el.innerText = msg
            self.parse_preview_el.style.whiteSpace = "pre-wrap"
            window.console.log("=" * 60)

        except Exception as ex:
            window.console.error(f"‚ùå Exception in _check_expected: {ex}")
            import traceback
            window.console.error(traceback.format_exc())
            self.parse_preview_el.innerText = f"‚ùå Error checking: {ex}"
            self.parse_preview_el.style.color = "#dc2626"
            self._animate_glow(self.dom_element.querySelector(".step-expr"), "#dc2626")

    def _check_user_answer(self, e):
        """Compare User Answer vs Expected Answer (value + structure with matrix ops)"""
        self.parse_preview_el.innerText = ""
        try:
            user_tex = self.user_mf.latex().strip() if self.user_mf else ""
            exp_tex  = self.expected_mf.latex().strip() if self.expected_mf else ""
            if not user_tex:
                self._show_feedback("warn", "‚ö†Ô∏è Empty")
                return

            user_val = self.math_parser.parse_latex(user_tex)
            exp_val  = self.math_parser.parse_latex(exp_tex)

            if user_val is None or exp_val is None:
                self._show_feedback("warn", "‚ö†Ô∏è Parse Error")
                return

            # Validate limits
            is_user_valid, user_error_msg = self.math_parser.validate_limit(user_val)
            if not is_user_valid:
                self._show_feedback("warn", "‚ö†Ô∏è Invalid Limit")
                self._animate_glow(self.dom_element.querySelector(".step-user"), "#dc2626")
                self.parse_preview_el.innerText = f"‚ö†Ô∏è Invalid limit in user answer:\n{user_error_msg}"
                return

            is_exp_valid, exp_error_msg = self.math_parser.validate_limit(exp_val)
            if not is_exp_valid:
                self._show_feedback("warn", "‚ö†Ô∏è Invalid Limit")
                self._animate_glow(self.dom_element.querySelector(".step-expected"), "#dc2626")
                self.parse_preview_el.innerText = f"‚ö†Ô∏è Invalid limit in expected answer:\n{exp_error_msg}"
                return

            # ‚úÖ CRITICAL: Extract structures from RAW parsed expressions
            # This preserves structural differences
            user_struct = self.math_parser.extract_structure(user_val)
            exp_struct  = self.math_parser.extract_structure(exp_val)

            # ‚úÖ Normalize ONLY for value comparison (separate concern)
            user_norm = self.math_parser.normalize_expr(user_val)
            exp_norm  = self.math_parser.normalize_expr(exp_val)

            # Convert structures to serializable format
            user_struct_json = self.math_parser.structure_to_json_serializable(user_struct)
            exp_struct_json = self.math_parser.structure_to_json_serializable(exp_struct)

            # ‚úÖ Use aggressive final_eq for value comparison
            if self.math_parser.final_eq(user_norm, exp_norm):
                self._show_feedback("correct")
                self._animate_glow(self.dom_element.querySelector(".step-expected"), "#16a34a")
                msg = "‚úÖ User answer is correct!\n"

                # ‚úÖ Compare structures including matrix_ops
                if user_struct_json == exp_struct_json:
                    msg += "‚úÖ Structure also matches!"
                else:
                    msg += "‚ö†Ô∏è Structure differs:\n\n"

                    # Show specific differences
                    if user_struct_json.get("operators") != exp_struct_json.get("operators"):
                        msg += f"Operators: User={user_struct_json.get('operators')}\n         Exp={exp_struct_json.get('operators')}\n"

                    if user_struct_json.get("operands") != exp_struct_json.get("operands"):
                        msg += f"Operands: User={user_struct_json.get('operands')}\n        Exp={exp_struct_json.get('operands')}\n"

                    # ‚úÖ Check matrix operations
                    user_ops = user_struct_json.get("matrix_ops", [])
                    exp_ops = exp_struct_json.get("matrix_ops", [])
                    if user_ops != exp_ops:
                        msg += f"Matrix ops: User has {len(user_ops)}, Exp has {len(exp_ops)}\n"

                    self._animate_glow(self.dom_element.querySelector(".step-user"), "#ca8a04")

                self.parse_preview_el.innerText = msg
            else:
                self._show_feedback("wrong")
                self._animate_glow(self.dom_element.querySelector(".step-expected"), "#dc2626")
                msg = f"‚ùå User answer not correct.\nUser: {user_norm}\nExpected: {exp_norm}"
                self.parse_preview_el.innerText = msg

        except Exception as ex:
            self._show_feedback("warn", "‚ö†Ô∏è Error")
            self.parse_preview_el.innerText = f"‚ùå Error comparing: {ex}"
            
    def _preview_parse(self, e):
        self.parse_preview_el.innerText = ""
        try:
            tex = self.expr_mf.latex().strip() if self.expr_mf else ""
            if not tex:
                self.parse_preview_el.innerText = "‚ö†Ô∏è Enter expression to preview."
                return
            
            parsed = self.math_parser.parse_latex(tex)
            
            if parsed:
                # Validate limit
                is_valid, error_msg = self.math_parser.validate_limit(parsed)
                
                if not is_valid:
                    self.parse_preview_el.innerText = (
                        f"‚ö†Ô∏è INVALID LIMIT:\n{error_msg}\n\n"
                        f"Parsed expression:\n{parsed}\n\n"
                        f"SymPy repr:\n{sp.srepr(parsed)}"
                    )
                else:
                    self.parse_preview_el.innerText = f"Parsed expression:\n{parsed}\n\nSymPy repr:\n{sp.srepr(parsed)}"
            else:
                self.parse_preview_el.innerText = "‚ùå Could not parse expression"
                
        except Exception as ex:
            self.parse_preview_el.innerText = f"‚ùå Parse error: {ex}"

    # ---------------------------------------------------------
    # üîÑ Autosave Support with Matrix Operations
    # ---------------------------------------------------------

    def get_data(self):
        """Get step data based on type"""
        base_data = {
            "step_type": self.step_type,
            "description": serialize_quill_content(self.description_editor_id)
        }

        if self.step_type == "step-by-step":
            expected_l = self.expected_mf.latex().strip() if self.expected_mf else ""
            expected_structure = None

            if hasattr(self, 'loaded_expected_structure') and self.loaded_expected_structure:
                expected_structure = self.loaded_expected_structure
            elif expected_l:
                try:
                    parsed = self.math_parser.parse_latex(expected_l)
                    if parsed:
                        expected_structure = self.math_parser.extract_structure(parsed)
                except:
                    pass

            base_data.update({
                "expression": self.expr_mf.latex().strip() if self.expr_mf else "",
                "expected": expected_l,
                "expected_structure": expected_structure,
                "user_answer": self.user_mf.latex().strip() if self.user_mf else ""
            })

        elif self.step_type == "multiple-choice-single":
            options = []
            for opt in self.options:
                content_blocks = serialize_quill_content(opt['editor_id'])
                options.append({
                    "label": opt['label'],
                    "content": content_blocks,
                    "content_type": "rich"
                })

            select = self.type_content_el.querySelector(".correctAnswerSelect")
            correct_answer = select.value if select else ""

            # ‚úÖ NEW: Get requireCorrect checkbox value
            require_checkbox = self.type_content_el.querySelector(".requireCorrectCheckbox")
            require_correct = require_checkbox.checked if require_checkbox else False

            base_data.update({
                "options": options,
                "correct_answer": correct_answer,
                "requireCorrect": require_correct  # ‚úÖ NEW
            })

        elif self.step_type == "multiple-choice-multiple":
            options = []
            for opt in self.options:
                content_blocks = serialize_quill_content(opt['editor_id'])
                options.append({
                    "label": opt['label'],
                    "content": content_blocks,
                    "content_type": "rich"
                })

            correct_answers = []
            checkboxes = self.type_content_el.querySelectorAll(".correctAnswerCheckbox:checked")
            for cb in checkboxes:
                correct_answers.append(cb.value)

            # ‚úÖ NEW: Get requireCorrect checkbox value
            require_checkbox = self.type_content_el.querySelector(".requireCorrectCheckbox")
            require_correct = require_checkbox.checked if require_checkbox else False

            base_data.update({
                "options": options,
                "correct_answers": correct_answers,
                "requireCorrect": require_correct  # ‚úÖ NEW
            })

        elif self.step_type == "true-false":
            tf_true = self.type_content_el.querySelector(".tfTrue")
            tf_false = self.type_content_el.querySelector(".tfFalse")

            correct_answer = None
            if tf_true and tf_true.checked:
                correct_answer = True
            elif tf_false and tf_false.checked:
                correct_answer = False

            # ‚úÖ NEW: Get requireCorrect checkbox value
            require_checkbox = self.type_content_el.querySelector(".requireCorrectCheckbox")
            require_correct = require_checkbox.checked if require_checkbox else False

            base_data["correct_answer"] = correct_answer
            base_data["requireCorrect"] = require_correct  # ‚úÖ NEW

        elif self.step_type == "fill-blank":
            # Fill-in-the-blank is now text-only
            correct_answers = []
            window.console.log(f"üìù Collecting fill-blank answers for step {self.step_index}")
            window.console.log(f"üìù self.blanks length: {len(self.blanks)}")

            for i, blank in enumerate(self.blanks):
                value = blank['text_input'].value.strip()
                window.console.log(f"üìù Blank {i}: value = '{value}'")
                if value:
                    correct_answers.append({"value": value, "display": value})
                    window.console.log(f"‚úÖ Added answer: '{value}'")

            window.console.log(f"üìù Total correct_answers collected: {len(correct_answers)}")

            # ‚úÖ Get requireCorrect checkbox value
            require_checkbox = self.type_content_el.querySelector(".requireCorrectCheckbox")
            require_correct = require_checkbox.checked if require_checkbox else False

            base_data.update({
                "blank_config": {
                    "content_type": "text",
                    "position": "end"
                },
                "correct_answers": correct_answers,
                "requireCorrect": require_correct
            })

            window.console.log(f"üì¶ Fill-blank data to save: blank_config={base_data.get('blank_config')}, correct_answers={correct_answers}, requireCorrect={require_correct}")

        return base_data
        
    def load_data(self, data):
        """Load step data based on type"""
        window.console.log(f"üì• Step.load_data called for Step {self.step_index}")
        window.console.log(f"üìä Data keys: {list(data.keys()) if isinstance(data, dict) else 'Not a dict'}")

        step_type = data.get("step_type", "step-by-step")
        window.console.log(f"üîñ Step type from data: {step_type}, current type: {self.step_type}")

        # ‚úÖ CRITICAL FIX: Update step type and render UI BEFORE loading data
        if self.step_type != step_type:
            window.console.log(f"‚ö†Ô∏è Type mismatch! Changing from {self.step_type} to {step_type}")
            self.step_type = step_type
            if self.type_select_el:
                self.type_select_el.value = step_type
            self._render_type_specific_ui()
            window.console.log(f"‚úì Step {self.step_index}: UI re-rendered for type '{step_type}'")
        else:
            window.console.log(f"‚úì Step {self.step_index}: Type matches, no re-render needed")

        # Load description
        if data.get("description"):
            window.console.log(f"üìù Loading description for Step {self.step_index}")
            restore_quill_content(self.description_editor_id, data["description"])
            window.console.log(f"‚úì Description loaded")

        # ‚úÖ NEW: Restore requireCorrect checkbox for applicable types
        if step_type in ["multiple-choice-single", "multiple-choice-multiple", "true-false", "fill-blank"]:
            if "requireCorrect" in data:
                # Wait a bit for UI to be ready
                def restore_checkbox():
                    require_checkbox = self.type_content_el.querySelector(".requireCorrectCheckbox")
                    if require_checkbox:
                        require_checkbox.checked = data["requireCorrect"]
                        window.console.log(f"‚úì Require correct restored: {data['requireCorrect']}")
                    else:
                        window.console.warn(f"‚ö†Ô∏è requireCorrect checkbox not found for step {self.step_index}")

                window.setTimeout(create_proxy(restore_checkbox), 150)

        # Type-specific loading
        if step_type == "step-by-step":
            window.console.log(f"üîß Loading step-by-step data for Step {self.step_index}")
            if hasattr(self, 'expr_mf') and self.expr_mf:
                if data.get("expression"):
                    self._load_math_field(self.expr_mf, data["expression"], "expression")
                    window.console.log(f"‚úì Expression loaded")
                if data.get("expected"):
                    self._load_math_field(self.expected_mf, data["expected"], "expected")
                    window.console.log(f"‚úì Expected loaded")
                if data.get("user_answer"):
                    self._load_math_field(self.user_mf, data["user_answer"], "user_answer")
                    window.console.log(f"‚úì User answer loaded")

        elif step_type in ["multiple-choice-single", "multiple-choice-multiple"]:
            window.console.log(f"üîß Loading multiple-choice data for Step {self.step_index}")
            # Load options with Quill content
            options_data = data.get("options", [])
            window.console.log(f"üìã Found {len(options_data)} options to load")

            # Clear default options
            if self.options_container:
                self.options_container.innerHTML = ""
                window.console.log(f"‚úì Cleared options container")
            else:
                window.console.error(f"‚ùå options_container not available!")

            self.options = []

            # Store reference to self for closures
            step_ref = self

            # Create a loading queue for sequential Quill initialization
            def load_options_sequentially(index):
                if index >= len(options_data):
                    window.console.log(f"‚úÖ All {len(options_data)} options loaded for Step {step_ref.step_index}")
                    # All options loaded, now set correct answer(s)
                    window.setTimeout(create_proxy(lambda: step_ref._set_correct_answers_after_load(data)), 300)
                    return

                opt_data = options_data[index]
                label = opt_data.get("label", "A")
                window.console.log(f"üìå Loading option {label} (index {index})")
                # ‚úÖ NEW: For multiple-choice-multiple, update checkboxes BEFORE setting correct answers
                if step_type == "multiple-choice-multiple":
                    step_ref._update_correct_answer_checkboxes()
                    window.console.log(f"‚úì Checkboxes container updated with {len(step_ref.options)} options")

                # Add option (this creates the Quill editor)
                if step_type == "multiple-choice-single":
                    step_ref._add_mc_option(label)
                else:
                    step_ref._add_mc_option_multi(label)

                # Find the option we just added
                added_opt = None
                for opt in step_ref.options:
                    if opt['label'] == label:
                        added_opt = opt
                        break

                if added_opt:
                    window.console.log(f"‚úì Option {label} created, editor_id: {added_opt['editor_id']}")

                    # Wait for Quill to initialize, then load content
                    def wait_and_load_content(attempt=0):
                        max_attempts = 20

                        # Check if Quill editor is ready
                        js_check = f"""
                        (function() {{
                            return window.quillEditors && window.quillEditors['{added_opt['editor_id']}'] ? true : false;
                        }})();
                        """
                        is_ready = window.eval(js_check)

                        if is_ready:
                            # Quill is ready - load content
                            content = opt_data.get("content", [])
                            window.console.log(f"‚úì Quill ready for option {label}, loading {len(content)} content blocks")
                            if content:
                                restore_quill_content(added_opt['editor_id'], content)
                                window.console.log(f"‚úì Loaded content for option {label}")

                            # Move to next option
                            window.setTimeout(
                                create_proxy(lambda idx=index+1: load_options_sequentially(idx)),
                                200
                            )
                        elif attempt < max_attempts:
                            # Not ready yet, try again
                            window.setTimeout(
                                create_proxy(lambda: wait_and_load_content(attempt + 1)),
                                100
                            )
                        else:
                            # Give up and move to next
                            window.console.warn(f"‚ö†Ô∏è Timeout loading option {label}")
                            window.setTimeout(
                                create_proxy(lambda idx=index+1: load_options_sequentially(idx)),
                                200
                            )

                    # Start waiting for this option's Quill editor
                    window.setTimeout(create_proxy(lambda: wait_and_load_content(0)), 200)
                else:
                    window.console.error(f"‚ùå Option {label} not found after adding!")
                    # Option not found, skip to next
                    window.setTimeout(
                        create_proxy(lambda idx=index+1: load_options_sequentially(idx)),
                        200
                    )

            # Start loading options sequentially
            if len(options_data) > 0:
                window.console.log(f"üöÄ Starting sequential option loading")
                window.setTimeout(create_proxy(lambda: load_options_sequentially(0)), 300)
            else:
                window.console.log(f"‚ÑπÔ∏è No options to load")

        elif step_type == "true-false":
            window.console.log(f"üîß Loading true-false data for Step {self.step_index}")
            correct_answer = data.get("correct_answer")
            window.console.log(f"üìã Correct answer: {correct_answer}")

            # Wait for UI to render
            def set_tf_answer():
                if correct_answer is True:
                    tf_true = self.type_content_el.querySelector(".tfTrue")
                    if tf_true:
                        tf_true.checked = True
                        window.console.log(f"‚úì Set True as correct")
                elif correct_answer is False:
                    tf_false = self.type_content_el.querySelector(".tfFalse")
                    if tf_false:
                        tf_false.checked = True
                        window.console.log(f"‚úì Set False as correct")

            window.setTimeout(create_proxy(set_tf_answer), 200)

        elif step_type == "fill-blank":
            window.console.log(f"üîß Loading fill-blank data for Step {self.step_index}")

            # Wait for UI to render
            def load_fill_blank_data():
                # Load answers (text-only)
                correct_answers = data.get("correct_answers", [])
                window.console.log(f"üìã Found {len(correct_answers)} correct answers (text)")

                # Clear default answer
                container = self.type_content_el.querySelector(".answersContainer")
                if container:
                    container.innerHTML = ""
                self.blanks = []

                # Add answer fields (text-only)
                for ans_data in correct_answers:
                    self._add_fill_blank_answer()

                    if len(self.blanks) > 0:
                        blank = self.blanks[-1]
                        value = ans_data.get("value", "")
                        blank['text_input'].value = value
                        window.console.log(f"‚úì Loaded text answer: {value}")

            window.setTimeout(create_proxy(load_fill_blank_data), 300)

        window.console.log(f"‚úÖ Step.load_data completed for Step {self.step_index}")

    def _set_correct_answers_after_load(self, data):
        """Set correct answer(s) after all options are loaded"""
        step_type = data.get("step_type")

        if step_type == "multiple-choice-single":
            correct_answer = data.get("correct_answer", "")
            select = self.type_content_el.querySelector(".correctAnswerSelect")
            if select:
                select.value = correct_answer
                window.console.log(f"‚úì Set correct answer: {correct_answer}")
            else:
                window.console.error(f"‚ùå Correct answer select not found!")

        elif step_type == "multiple-choice-multiple":
            correct_answers = data.get("correct_answers", [])

            # ‚úÖ NEW: Wait a bit longer for checkboxes to be fully rendered
            def set_checkboxes():
                container = self.type_content_el.querySelector(".correctAnswersCheckboxes")
                if not container:
                    window.console.error(f"‚ùå Correct answers checkbox container not found!")
                    return

                checkboxes = container.querySelectorAll(".correctAnswerCheckbox")
                if checkboxes and len(checkboxes) > 0:
                    # ‚úÖ CRITICAL: Temporarily disable autosave while setting checkboxes
                    # to avoid triggering multiple autosaves
                    data_manager = window.problem_creator.data_manager if hasattr(window, 'problem_creator') else None
                    was_restoring = data_manager.is_restoring if data_manager else False

                    if data_manager and not was_restoring:
                        data_manager.is_restoring = True  # Temporarily disable autosave

                    # Set all checkboxes
                    for cb in checkboxes:
                        if cb.value in correct_answers:
                            cb.checked = True

                    # Re-enable autosave
                    if data_manager and not was_restoring:
                        data_manager.is_restoring = False

                    window.console.log(f"‚úì Set correct answers: {correct_answers}")
                else:
                    window.console.error(f"‚ùå Correct answer checkboxes not found! Container exists but no checkboxes.")

            # Wait for checkboxes to be created
            window.setTimeout(create_proxy(set_checkboxes), 400)
            
    def _load_math_field(self, math_field, content, field_name):
      """Load content into a MathQuill field"""
      if not content:
          return

      content_str = str(content).strip()

      # Check if it's asciimath (enclosed in backticks)
      if content_str.startswith('`') and content_str.endswith('`'):
          # Extract asciimath content
          asciimath = content_str[1:-1].strip()
          window.console.log(f"üîÑ Loading {field_name} as asciimath via keystrokes: {asciimath}")

          try:
              # Parse asciimath to keystrokes using the global function
              keystrokes = window.parseSmartKeystrokes(asciimath)
              window.console.log(f"‚å®Ô∏è Generated {len(keystrokes)} keystrokes for {field_name}")

              # Send keystrokes to MathQuill
              success = window.sendKeystrokesToMathQuill(math_field, keystrokes)

              if success:
                  window.console.log(f"‚úÖ Loaded {field_name} via keystrokes")
              else:
                  window.console.error(f"‚ùå Failed to load {field_name} via keystrokes")
                  # Fallback: try converting to LaTeX
                  try:
                      latex = self._convert_asciimath_to_latex_js(asciimath)
                      if not (latex.startswith('`') and latex.endswith('`')):
                          math_field.latex(latex)
                          window.console.log(f"‚úì Loaded {field_name} via LaTeX fallback")
                  except:
                      window.console.error(f"‚ùå All methods failed for {field_name}")
          except Exception as e:
              window.console.error(f"‚ùå Error loading {field_name} via keystrokes: {e}")
              import traceback
              window.console.error(traceback.format_exc())

              # Fallback: try LaTeX conversion
              try:
                  latex = self._convert_asciimath_to_latex_js(asciimath)
                  if not (latex.startswith('`') and latex.endswith('`')):
                      math_field.latex(latex)
                      window.console.log(f"‚úì Loaded {field_name} via LaTeX fallback")
              except:
                  window.console.error(f"‚ùå Complete failure loading {field_name}")
      else:
          # Not asciimath - load as LaTeX directly
          window.console.log(f"üìù Loading {field_name} as LaTeX")
          try:
              # Check if already LaTeX or needs conversion
              if content_str.startswith('$$') and content_str.endswith('$$'):
                  latex = content_str[2:-2]
              else:
                  latex = self._convert_asciimath_to_latex_js(content_str)

              math_field.latex(latex)
              window.console.log(f"‚úÖ Loaded {field_name} as LaTeX")
          except Exception as e:
              window.console.error(f"‚ùå Failed to load {field_name}: {e}")
    def _display_expected_structure(self, structure):
        """Display expected answer structure information with matrix ops"""
        if not structure:
            return

        structure_info = []
        
        # Show operators
        if structure.get("operators"):
            ops = structure["operators"]
            structure_info.append(f"Operators: {', '.join([f'{k}({v})' for k, v in ops.items()])}")
        
        # Show operands
        if structure.get("operands"):
            operands = structure["operands"]
            structure_info.append(f"Operands: {', '.join([f'{k}({v})' for k, v in operands.items()])}")
        
        # ‚úÖ Show matrix operations
        matrix_ops = structure.get("matrix_ops", [])
        if matrix_ops:
            structure_info.append(f"Matrix Operations: {len(matrix_ops)} detected")
            for i, op in enumerate(matrix_ops):
                operations = op.get("operations", [])
                structure_info.append(f"  ‚Ä¢ Op {i+1}: {op.get('type')} ({len(operations)} row operation(s))")

        # Display structure info in the parse preview area
        if hasattr(self, 'parse_preview_el') and self.parse_preview_el:
            self.parse_preview_el.innerText = (
                "üìê Expected Answer Structure:\n" + 
                "\n".join(structure_info) +
                "\n\n‚úÖ This step has a valid structure" +
                (f" with {len(matrix_ops)} matrix operation(s)" if matrix_ops else "")
            )
            self.parse_preview_el.style.color = "#0369a1"
            self.parse_preview_el.style.whiteSpace = "pre-wrap"
            self.parse_preview_el.style.background = "#f0f9ff"
            self.parse_preview_el.style.padding = "8px"
            self.parse_preview_el.style.borderRadius = "4px"
            self.parse_preview_el.style.border = "1px solid #bae6fd"
            
class Problem:
    """Represents a single problem with multiple steps"""
    def remove_step(self, step_to_remove):
        """Remove a step and renumber remaining steps"""
        if step_to_remove in self.steps:
            self.steps.remove(step_to_remove)
            # Renumber remaining steps
            for i, step in enumerate(self.steps, start=1):
                step.step_index = i
                # Update the step header text
                header = step.dom_element.querySelector("strong")
                if header:
                    header.textContent = f"Step {i}"
                              
    def duplicate_step(self, step_to_duplicate, step_data):
        """Duplicate a step in this problem with all its content"""
        try:
            # Find the index of the step to duplicate
            step_index = self.steps.index(step_to_duplicate)
            
            # Create a new step with the same type
            new_step = Step(
                self.steps_container,
                len(self.steps) + 1,
                self.math_parser,
                self,
                step_type=step_to_duplicate.step_type
            )
            
            # Insert after the original step
            self.steps.insert(step_index + 1, new_step)
            
            # Re-number all steps
            for i, step in enumerate(self.steps, 1):
                step.step_index = i
                step_label = step.dom_element.querySelector("strong")
                if step_label:
                    step_label.textContent = f"Step {i}"
            
            # Restore content after a short delay to ensure UI is ready
            def restore_content():
                self._restore_step_content(new_step, step_data)
            
            window.setTimeout(create_proxy(restore_content), 300)
            
            window.console.log(f"‚úì Step duplicated at position {step_index + 1}")
            
        except Exception as e:
            window.console.error(f"Error duplicating step: {e}")
            import traceback
            window.console.error(traceback.format_exc())
    
    def _restore_step_content(self, step, data):
        """Restore content to a duplicated step"""
        try:
            window.console.log(f"üîÑ Restoring content to step {step.step_index}")
            
            # Restore description
            if data.get('description_delta') and step.description_editor_id:
                js_code = f"""
                (function(deltaJson) {{{{
                    const quill = window.quillEditors && window.quillEditors['{step.description_editor_id}'];
                    if (quill) {{{{
                        const delta = JSON.parse(deltaJson);
                        quill.setContents(delta);
                        return true;
                    }}}}
                    return false;
                }}}})
                """
                func = window.eval(js_code)
                result = func(data["description_delta"])
                if result:
                    window.console.log(f"‚úì Restored description content")
                else:
                    window.console.warn(f"‚ö†Ô∏è Failed to restore description")
            
            # Restore type-specific content
            if data['step_type'] == "step-by-step":
                if data.get('expression') and step.expr_mf:
                    step.expr_mf.latex(data['expression'])
                    window.console.log(f"‚úì Restored expression: {data['expression']}")
                if data.get('expected_answer') and step.expected_mf:
                    step.expected_mf.latex(data['expected_answer'])
                    window.console.log(f"‚úì Restored expected answer")
                if data.get('expected_structure'):
                    step.loaded_expected_structure = data['expected_structure']
                    window.console.log(f"‚úì Restored expected structure")
                    
            elif data['step_type'] in ["multiple-choice-single", "multiple-choice-multiple"]:
                # Restore options
                options_data = data.get('options', [])
                window.console.log(f"üìù Restoring {len(options_data)} options")
                
                for i, opt_data in enumerate(options_data):
                    if i < len(step.options):
                        opt = step.options[i]
                        
                        # Restore checkbox state
                        if opt.get('checkbox'):
                            opt['checkbox'].checked = opt_data.get('is_correct', False)
                            window.console.log(f"‚úì Option {chr(65 + i)} checked: {opt_data.get('is_correct', False)}")
                        
                        # Restore Quill content
                        if opt_data.get('content_delta') and opt.get('editor_id'):
                            js_code = f"""
                            (function(deltaJson) {{{{
                                const quill = window.quillEditors && window.quillEditors['{opt['editor_id']}'];
                                if (quill) {{{{
                                    const delta = JSON.parse(deltaJson);
                                    quill.setContents(delta);
                                    return true;
                                }}}}
                                return false;
                            }}}})
                            """
                            func = window.eval(js_code)
                            result = func(opt_data["content_delta"])
                            if result:
                                window.console.log(f"‚úì Restored content for option {chr(65 + i)}")
                            else:
                                window.console.warn(f"‚ö†Ô∏è Failed to restore option {chr(65 + i)} content")
                
                # Restore correct answer selection
                if data.get('correct_answer'):
                    window.console.log(f"üîç Attempting to restore correct answer: {data['correct_answer']}")
                    
                    # Try different ways to find the correct answer dropdown
                    selectors_to_try = [
                        '.correctAnswerSelect',
                        'select[id*="correct"]',
                        'select[id*="answer"]',
                        '.mc-correct-select',
                    ]
                    
                    correct_answer_select = None
                    for selector in selectors_to_try:
                        correct_answer_select = step.dom_element.querySelector(selector)
                        if correct_answer_select:
                            correct_answer_select.value = data['correct_answer']
                            window.console.log(f"‚úì Restored correct answer from {selector}: {data['correct_answer']}")
                            break
                    
                    if not correct_answer_select:
                        # Last resort: find any select that's not the step type select
                        all_selects = step.dom_element.querySelectorAll('select')
                        for sel in all_selects:
                            if 'stepTypeSelect' not in sel.className:
                                sel.value = data['correct_answer']
                                window.console.log(f"‚úì Restored correct answer (fallback): {data['correct_answer']}")
                                break
                        
            elif data['step_type'] == "true-false":
                # Restore true/false selection
                if data.get('tf_answer'):
                    radio = step.dom_element.querySelector(f'input[value="{data["tf_answer"]}"]')
                    if radio:
                        radio.checked = True
                        window.console.log(f"‚úì Restored T/F answer: {data['tf_answer']}")
                        
            elif data['step_type'] == "fill-blank":
                # Restore blanks
                for i, blank_data in enumerate(data.get('blanks', [])):
                    if i < len(step.blanks):
                        blank = step.blanks[i]
                        if blank.get('input_el'):
                            blank['input_el'].value = blank_data.get('answer', '')
                            window.console.log(f"‚úì Restored blank {i + 1}")
            
            # Restore explanation
            if data.get('explanation_delta') and step.explanation_editor_id:
                js_code = f"""
                (function(deltaJson) {{{{
                    const quill = window.quillEditors && window.quillEditors['{step.explanation_editor_id}'];
                    if (quill) {{{{
                        const delta = JSON.parse(deltaJson);
                        quill.setContents(delta);
                        return true;
                    }}}}
                    return false;
                }}}})
                """
                func = window.eval(js_code)
                result = func(data["explanation_delta"])
                if result:
                    window.console.log(f"‚úì Restored explanation content")
            
            window.console.log(f"‚úÖ Content restoration complete for step {step.step_index}")
            
        except Exception as e:
            window.console.error(f"‚ùå Error restoring step content: {e}")
            import traceback
            window.console.error(traceback.format_exc())
    
    def _set_option_data(self, step, index, opt_data):
        """Helper to set option data after delay"""
        if index < len(step.options):
            opt = step.options[index]
            if opt.get('text_el'):
                opt['text_el'].value = opt_data['text']
            if opt.get('checkbox'):
                opt['checkbox'].checked = opt_data['is_correct']
    
    def _set_blank_data(self, step, index, blank_data):
        """Helper to set blank data after delay"""
        if index < len(step.blanks):
            blank = step.blanks[index]
            if blank.get('input_el'):
                blank['input_el'].value = blank_data['answer']
                    
    def __init__(self, container, problem_index, math_parser, skip_initial_steps=False):
        self.container = container
        self.problem_index = problem_index
        self.math_parser = math_parser
        self.dom_element = None
        self.title_el = None
        self.description_editor_id = None
        self.steps_container = None
        self.steps = []
        self.is_initializing = True  # ‚úÖ NEW: Flag to prevent premature autosave
        self.skip_initial_steps = skip_initial_steps  # ‚úÖ NEW: Flag to skip auto-adding initial steps

        # Create UI immediately in __init__
        self._create_ui()
    
    def _create_ui(self):
        """Create the UI for this problem"""
        wrapper = document.createElement("div")
        wrapper.className = "problem"
        wrapper.innerHTML = f"""
          <div class="problem-header">
            <span>Problem {self.problem_index}</span>
            <div class="problem-actions">
              <button class="btn ghost duplicateProblem" style="padding:4px 8px; font-size:12px;">üìã Duplicate</button>
              <button class="btn ghost removeProblem" style="padding:4px 8px; font-size:12px;">üóëÔ∏è Remove</button>
            </div>
          </div>
          <div class="problem-body">
            <label>Problem Title</label>
            <input class="probTitle" style="width:100%; padding:6px; margin-bottom:6px;"/>
            <label>Description</label>
            <div class="quill-container prob-desc-editor"></div>
            <div class="stepsContainer" style="margin-top:10px;"></div>
            <button class="btn addStep">‚ûï Add Step</button>
          </div>
        """
        self.container.appendChild(wrapper)
        self.dom_element = wrapper

        # Store references
        self.title_el = wrapper.querySelector(".probTitle")
        self.steps_container = wrapper.querySelector(".stepsContainer")

        # Setup Quill editor
        self.description_editor_id = f"prob-desc-{uuid.uuid4().hex[:8]}"
        desc_container = wrapper.querySelector(".prob-desc-editor")
        desc_container.setAttribute("id", self.description_editor_id)

        # Wire up events
        self._wire_events()

        # Initialize Quill editor
        window.setTimeout(create_proxy(lambda: self._init_quill_editor()), 100)

        # ‚úÖ NEW: Only add initial steps if not skipping (i.e., not importing)
        if not self.skip_initial_steps:
            # Add initial step with default type instead of showing dialog
            # This ensures there's always at least one step when autosave runs
            window.setTimeout(create_proxy(lambda: self.add_step("step-by-step")), 200)

            def finish_initialization():
                self.add_step("step-by-step")
                self.is_initializing = False  # ‚úÖ Mark as initialized
                # Now trigger autosave
                if hasattr(window, 'problem_creator'):
                    window.problem_creator.data_manager.save_to_storage()

            window.setTimeout(create_proxy(finish_initialization), 300)
        else:
            # ‚úÖ NEW: For imported problems, just mark as initialized
            def finish_initialization():
                self.is_initializing = False
            window.setTimeout(create_proxy(finish_initialization), 300)
    
    def _init_quill_editor(self):
        """Initialize Quill editor for problem description"""
        if not hasattr(window, 'quillBlotsInitialized'):
            init_quill_blots()
            window.quillBlotsInitialized = True
        create_quill_editor(self.description_editor_id, "Describe the problem...")
    
    def _wire_events(self):
      """Wire up event handlers"""    
      # Header toggle
      header = self.dom_element.querySelector(".problem-header")
      body = self.dom_element.querySelector(".problem-body")

      def toggle_body(e):
          # Check if click is on button or inside button
          target = e.target

          # Walk up the DOM to check if we clicked on a button
          current = target
          max_depth = 5
          depth = 0
          while current and depth < max_depth:
              if current.classList and (
                  current.classList.contains("removeProblem") or 
                  current.classList.contains("duplicateProblem") or 
                  current.classList.contains("problem-actions") or
                  current.tagName == "BUTTON"
              ):
                  # Clicked on a button, don't toggle
                  return
              current = current.parentElement
              depth += 1

          # Toggle collapsed class on both header and body
          is_collapsed = body.classList.contains("collapsed")
          if is_collapsed:
              body.classList.remove("collapsed")
              header.classList.remove("collapsed")
          else:
              body.classList.add("collapsed")
              header.classList.add("collapsed")

      if header:
          header.addEventListener("click", create_proxy(toggle_body))

      # Add Step button
      add_step_btn = self.dom_element.querySelector(".addStep")
      if add_step_btn:
          add_step_btn.addEventListener("click", create_proxy(lambda e: self.add_step()))

      # Duplicate problem button - capture self explicitly
      dup_btn = self.dom_element.querySelector(".duplicateProblem")
      if dup_btn:
          problem_ref = self  # Capture self explicitly
          def handle_duplicate(e):
              problem_ref._duplicate_problem(e)
          dup_btn.addEventListener("click", create_proxy(handle_duplicate))

      # Remove problem button - capture self explicitly
      rem_btn = self.dom_element.querySelector(".removeProblem")
      if rem_btn:
          problem_ref = self  # Capture self explicitly
          def handle_remove(e):
              problem_ref._remove_problem(e)
          rem_btn.addEventListener("click", create_proxy(handle_remove))

      # Title change triggers autosave
      if self.title_el:
          def on_title_change(e):
              if hasattr(window, 'problem_creator'):
                  window.problem_creator.data_manager.save_to_storage()
          self.title_el.addEventListener("input", create_proxy(on_title_change))

    def _remove_problem(self, e):
      """Remove this problem"""
      # Stop event propagation to prevent header toggle
      try:
          e.stopPropagation()
      except:
          pass  # PyScript might handle this differently

      try:
          e.preventDefault()
      except:
          pass

      if window.confirm(f"Remove Problem {self.problem_index}?"):
          # Store reference before removal
          dom_element = self.dom_element

          # Remove from problems list first
          if hasattr(window, 'problem_creator'):
              try:
                  window.problem_creator.problems = [
                      p for p in window.problem_creator.problems if p != self
                  ]

                  # Renumber remaining problems
                  for i, prob in enumerate(window.problem_creator.problems, start=1):
                      prob.problem_index = i
                      header_span = prob.dom_element.querySelector(".problem-header span")
                      if header_span:
                          header_span.textContent = f"Problem {i}"

                  # Remove DOM element
                  dom_element.remove()

                  # Trigger save
                  window.problem_creator.data_manager.save_to_storage()

                  window.console.log(f"‚úì Problem removed successfully")
              except Exception as ex:
                  window.console.error(f"Error removing problem: {ex}")
                  import traceback
                  window.console.error(traceback.format_exc())
                                  
    def _duplicate_problem(self, e):
      """Duplicate this problem"""
      # Stop event propagation
      try:
          e.stopPropagation()
      except:
          pass

      try:
          e.preventDefault()
      except:
          pass

      try:
          # Get current problem data
          current_data = self.get_data()

          # Create new problem
          if hasattr(window, 'problem_creator'):
              window.problem_creator.add_problem()
              new_problem = window.problem_creator.problems[-1]

              # Load data into new problem
              new_problem.load_data({
                  "title": current_data.get("title", "") + " (Copy)",
                  "description": current_data.get("description", []),
                  "steps": current_data.get("steps", [])
              })

              # Trigger save
              window.problem_creator.data_manager.save_to_storage()
              window.alert(f"‚úÖ Problem duplicated successfully!")
      except Exception as ex:
          window.console.error(f"Error duplicating problem: {ex}")
          import traceback
          window.console.error(traceback.format_exc())
          window.alert(f"‚ùå Failed to duplicate problem: {ex}")
    
    def add_step(self, step_type=None):
        """Add a new step - if no type specified, show selection dialog"""
        if step_type is None:
            # Show step type selection dialog
            self._show_step_type_dialog()
        else:
            # Create step with specified type
            step_index = len(self.steps) + 1
            step = Step(self.steps_container, step_index, self.math_parser, self, step_type)
            self.steps.append(step)

            if hasattr(window, 'problem_creator'):
                window.problem_creator.data_manager.save_to_storage()

    def _show_step_type_dialog(self):
        """Show dialog to select step type before adding"""
        problem_ref = self  # Capture reference for closure

        js_code = """
        (function() {
            // Remove existing dialog if any
            let existing = document.querySelector('#stepTypeDialog');
            if(existing) existing.remove();

            // Create overlay
            let overlay = document.createElement('div');
            overlay.id = 'stepTypeDialog';
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, 0.6);
                z-index: 10000;
                display: flex;
                align-items: center;
                justify-content: center;
                animation: fadeIn 0.2s ease;
            `;

            // Create dialog
            let dialog = document.createElement('div');
            dialog.style.cssText = `
                background: white;
                border-radius: 16px;
                padding: 32px;
                max-width: 600px;
                width: 90%;
                box-shadow: 0 25px 50px rgba(0, 0, 0, 0.4);
                animation: slideUp 0.3s ease;
            `;

            dialog.innerHTML = `
                <style>
                    @keyframes fadeIn {
                        from { opacity: 0; }
                        to { opacity: 1; }
                    }
                    @keyframes slideUp {
                        from { transform: translateY(30px); opacity: 0; }
                        to { transform: translateY(0); opacity: 1; }
                    }
                    .step-type-card {
                        border: 2px solid #e6eef8;
                        border-radius: 12px;
                        padding: 16px;
                        cursor: pointer;
                        transition: all 0.2s ease;
                        background: white;
                    }
                    .step-type-card:hover {
                        border-color: #0b6efd;
                        background: #f0f9ff;
                        transform: translateY(-2px);
                        box-shadow: 0 4px 12px rgba(11, 110, 253, 0.15);
                    }
                    .step-type-card:active {
                        transform: translateY(0);
                    }
                    .step-type-icon {
                        font-size: 32px;
                        margin-bottom: 8px;
                    }
                    .step-type-title {
                        font-weight: 700;
                        font-size: 16px;
                        color: #0f172a;
                        margin-bottom: 4px;
                    }
                    .step-type-desc {
                        font-size: 13px;
                        color: #64748b;
                        line-height: 1.4;
                    }
                </style>

                <h2 style="margin: 0 0 8px 0; font-size: 24px; color: #0f172a; font-weight: 700;">
                    Choose Step Type
                </h2>
                <p style="margin: 0 0 24px 0; color: #64748b; font-size: 14px;">
                    Select the type of question or content for this step
                </p>

                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 12px; margin-bottom: 20px;">
                    <!-- Expression & Answer -->
                    <div class="step-type-card" data-type="step-by-step">
                        <div class="step-type-icon">üßÆ</div>
                        <div class="step-type-title">Expression & Answer</div>
                        <div class="step-type-desc">
                            Mathematical expression with expected answer and validation
                        </div>
                    </div>

                    <!-- Multiple Choice (Single) -->
                    <div class="step-type-card" data-type="multiple-choice-single">
                        <div class="step-type-icon">‚≠ï</div>
                        <div class="step-type-title">Multiple Choice (Single)</div>
                        <div class="step-type-desc">
                            Choose one correct answer from multiple options
                        </div>
                    </div>

                    <!-- Multiple Choice (Multiple) -->
                    <div class="step-type-card" data-type="multiple-choice-multiple">
                        <div class="step-type-icon">‚òëÔ∏è</div>
                        <div class="step-type-title">Multiple Choice (Multiple)</div>
                        <div class="step-type-desc">
                            Select all correct answers from options
                        </div>
                    </div>

                    <!-- True/False -->
                    <div class="step-type-card" data-type="true-false">
                        <div class="step-type-icon">‚úì‚úó</div>
                        <div class="step-type-title">True/False</div>
                        <div class="step-type-desc">
                            Simple true or false question with explanation
                        </div>
                    </div>

                    <!-- Fill in the Blank -->
                    <div class="step-type-card" data-type="fill-blank">
                        <div class="step-type-icon">üìù</div>
                        <div class="step-type-title">Fill in the Blank</div>
                        <div class="step-type-desc">
                            Text or math answer with multiple acceptable responses
                        </div>
                    </div>
                </div>

                <div style="text-align: center;">
                    <button id="stepTypeCancelBtn" style="
                        padding: 12px 24px;
                        border: 2px solid #e6eef8;
                        background: white;
                        color: #64748b;
                        border-radius: 8px;
                        cursor: pointer;
                        font-size: 14px;
                        font-weight: 600;
                        transition: all 0.2s ease;
                    ">Cancel</button>
                </div>
            `;

            overlay.appendChild(dialog);
            document.body.appendChild(overlay);

            // Wire up card clicks
            const cards = dialog.querySelectorAll('.step-type-card');
            cards.forEach(card => {
                card.addEventListener('click', function() {
                    const stepType = this.getAttribute('data-type');
                    overlay.remove();

                    // Call Python method to create step with selected type
                    if (window.problem_creator && window.problem_creator._step_type_callback) {
                        window.problem_creator._step_type_callback(stepType);
                    }
                });
            });

            // Wire up cancel
            document.getElementById('stepTypeCancelBtn').addEventListener('click', function() {
                overlay.remove();
            });

            // Close on overlay click
            overlay.addEventListener('click', function(e) {
                if (e.target === overlay) {
                    overlay.remove();
                }
            });

            // Close on Escape key
            const escHandler = function(e) {
                if (e.key === 'Escape') {
                    overlay.remove();
                    document.removeEventListener('keydown', escHandler);
                }
            };
            document.addEventListener('keydown', escHandler);
        })();
        """

        # Set up callback for when type is selected
        def on_type_selected(step_type):
            problem_ref.add_step(step_type)

        window.problem_creator._step_type_callback = create_proxy(on_type_selected)

        # Execute the dialog
        window.eval(js_code)

    def get_data(self):
        """Get problem data as dictionary"""
        return {
            "title": self.title_el.value.strip() if self.title_el else "",
            "description": serialize_quill_content(self.description_editor_id),
            "steps": [step.get_data() for step in self.steps]
        }
        
    def load_data(self, data):
        """Load problem data from dictionary with robust sequential step loading"""
        window.console.log(f"üì• Problem.load_data called for Problem {self.problem_index}")
        window.console.log(f"üìä Data keys: {list(data.keys()) if isinstance(data, dict) else 'Not a dict'}")

        # Load title
        if self.title_el and data.get("title"):
            self.title_el.value = data["title"]
            window.console.log(f"‚úì Title loaded: {data['title'][:30]}...")

        # Load description
        if data.get("description"):
            restore_quill_content(self.description_editor_id, data["description"])
            window.console.log(f"‚úì Description loaded")

        # Load steps with proper sequencing
        if self.steps_container:
            self.steps_container.innerHTML = ""
            self.steps = []

            steps_data = data.get("steps", [])

            window.console.log(f"üìã Steps data type: {type(steps_data)}")
            window.console.log(f"üìã Steps count: {len(steps_data) if isinstance(steps_data, list) else 'N/A'}")

            if len(steps_data) == 0:
                window.console.log("‚ö†Ô∏è No steps to load")
                return

            window.console.log(f"üîÑ Starting to load {len(steps_data)} steps for Problem {self.problem_index}")

            # ‚≠ê Store problem reference to avoid closure issues
            problem_ref = self

            # ‚≠ê Sequential step loading with type-aware readiness checking
            def load_next_step(current_index):
                """Load step at current_index, then schedule the next one"""
                window.console.log(f"üìç load_next_step called with index {current_index} for Problem {problem_ref.problem_index}")

                if current_index >= len(steps_data):
                    window.console.log(f"‚úÖ‚úÖ‚úÖ All {len(steps_data)} steps loaded for Problem {problem_ref.problem_index}")
                    return

                step_data = steps_data[current_index]
                step_type = step_data.get("step_type", "step-by-step")

                window.console.log(f"üì¶ Step {current_index} data: step_type={step_type}")

                # ‚úÖ CRITICAL: Create step with the correct type from saved data
                try:
                    step = Step(
                        problem_ref.steps_container, 
                        len(problem_ref.steps) + 1, 
                        problem_ref.math_parser, 
                        problem_ref,
                        step_type  # Pass the step type from loaded data
                    )
                    problem_ref.steps.append(step)
                    window.console.log(f"üìù Created Step {step.step_index} (type: {step_type}) for Problem {problem_ref.problem_index}")
                except Exception as e:
                    window.console.error(f"‚ùå Failed to create step: {e}")
                    import traceback
                    window.console.error(traceback.format_exc())
                    return

                # ‚≠ê Wait for step UI to be ready based on step type, then load data
                def wait_and_load(attempt=0):
                    max_attempts = 40

                    # ‚úÖ CRITICAL: Check readiness based on step type
                    is_ready = False
                    readiness_check = ""

                    if step_type == "step-by-step":
                        # For step-by-step, wait for math fields
                        is_ready = hasattr(step, 'expr_mf') and step.expr_mf is not None
                        readiness_check = "expr_mf"
                    elif step_type in ["multiple-choice-single", "multiple-choice-multiple"]:
                        # For multiple choice, wait for options container
                        is_ready = hasattr(step, 'options_container') and step.options_container is not None
                        readiness_check = "options_container"
                    elif step_type == "true-false":
                        # For true-false, wait for type content element
                        is_ready = hasattr(step, 'type_content_el') and step.type_content_el is not None
                        readiness_check = "type_content_el"
                    elif step_type == "fill-blank":
                        # For fill-blank, wait for type content element
                        is_ready = hasattr(step, 'type_content_el') and step.type_content_el is not None
                        readiness_check = "type_content_el"
                    else:
                        # Unknown type, assume ready
                        is_ready = True
                        readiness_check = "unknown type"

                    if not is_ready:
                        if attempt < max_attempts:
                            delay = 100 + (attempt * 50)
                            window.console.log(f"‚è≥ Problem {problem_ref.problem_index}, Step {step.step_index} ({step_type}) - waiting for {readiness_check} (attempt {attempt + 1}/{max_attempts})")
                            window.setTimeout(
                                create_proxy(lambda: wait_and_load(attempt + 1)),
                                delay
                            )
                        else:
                            window.console.error(f"‚ùå Problem {problem_ref.problem_index}, Step {step.step_index} ({step_type}) - {readiness_check} never initialized!")
                            # Continue to next step anyway
                            next_index = current_index + 1
                            window.console.log(f"‚è≠Ô∏è Moving to next step: {next_index}")
                            window.setTimeout(
                                create_proxy(lambda idx=next_index: load_next_step(idx)),
                                300
                            )
                        return

                    # Fields are ready - load the data
                    window.console.log(f"‚úì Problem {problem_ref.problem_index}, Step {step.step_index} ({step_type}) - {readiness_check} ready, loading data")
                    try:
                        step.load_data(step_data)
                        window.console.log(f"‚úÖ Problem {problem_ref.problem_index}, Step {step.step_index} ({step_type}) - data loaded successfully")
                    except Exception as e:
                        window.console.error(f"‚ùå Problem {problem_ref.problem_index}, Step {step.step_index} ({step_type}) - load error: {e}")
                        import traceback
                        window.console.error(traceback.format_exc())

                    # ‚≠ê CRITICAL: Schedule next step with explicit index capture
                    next_index = current_index + 1
                    window.console.log(f"‚è≠Ô∏è Scheduling next step: index {next_index} for Problem {problem_ref.problem_index}")
                    window.setTimeout(
                        create_proxy(lambda idx=next_index: load_next_step(idx)),
                        250  # Delay between steps
                    )

                # Start waiting for this step's fields with initial delay
                window.setTimeout(
                    create_proxy(lambda: wait_and_load(0)),
                    300
                )

            # ‚≠ê Start the sequential loading with step 0
            window.console.log(f"üöÄ Starting sequential load for Problem {problem_ref.problem_index}")
            window.setTimeout(
                create_proxy(lambda: load_next_step(0)),
                500  # Initial delay before starting
            )
        else:
            window.console.error("‚ùå steps_container not found!")

class DataManager:
    """Handles data persistence, import, and export"""

    STORAGE_KEY = "problem_creator_autosave_v1"

    def _get_math_only_example(self):
        """Return math-only example text"""
        return """###
    Problem Title: Derivative and Simplification
    Problem Description: Find the derivative of the function `f(x) = x^3 - 2x^2 + 5x - 1` and simplify the result in multiple steps. Use the power rule and basic algebraic manipulation.
    #
    Step Description: Find the derivative of the polynomial function
    Step Expression: `d/dx(x^3-2x^2+5x-1)`
    Step Expected: `3x^2-4x+5`
    #
    Step Description: Factor out the common term from the derivative
    Step Expression: `3x^2-4x+5`
    Step Expected: `3x^2-4x+5`
    #
    Step Description: Evaluate the derivative at x = 2
    Step Expression: `3(2)^2-4(2)+5`
    Step Expected: `9`
    ###
    Problem Title: Matrix Row Operations
    Problem Description: Perform the following row operations on the given augmented matrix `[[2,1,3],[4,-1,7]]` to solve the system of equations.
    #
    Step Description: Start with the augmented matrix
    Step Expression: `[[2,1,3],[4,-1,7]]`
    Step Expected: `[[2,1,3],[4,-1,7]]`
    #
    Step Description: Perform R_2 ‚Üí R_2 - 2R_1 to eliminate the first element in row 2
    Step Expression: `[[2,1,3],[4,-1,7]]|R_2->R_2-2R_1`
    Step Expected: `[[2,1,3],[0,-3,1]]`
    #
    Step Description: Scale row 2 by -1/3
    Step Expression: `[[2,1,3],[0,-3,1]]|R_2->(-1/3)R_2`
    Step Expected: `[[2,1,3],[0,1,-1/3]]`
    ###"""

    def _get_assessment_only_example(self):
        """Return assessment-only example text"""
        return """###
    Problem Title: Calculus Concepts - Multiple Choice
    Problem Description: Test your understanding of fundamental calculus concepts with these multiple choice questions.
    #
    Step Description: What is the derivative of a constant?
    Step Type: multiple-choice-single
    Option A: The constant itself
    Option B: Zero
    Option C: One
    Option D: Undefined
    Correct Answer: B
    Must Be Correct: true
    #
    Step Description: Which of the following are valid integration techniques? (Select all that apply)
    Step Type: multiple-choice-multiple
    Option A: Substitution
    Option B: Integration by parts
    Option C: Partial fractions
    Option D: Cross multiplication
    Option E: Long division
    Correct Answer: A, B, C
    Must Be Correct: false
    #
    Step Description: The limit of a function at a point always equals the function's value at that point.
    Step Type: true-false
    Correct Answer: False
    Must Be Correct: true
    Explanation: This statement is false. A limit can exist even when the function is not defined at that point, or when the function value differs from the limit (removable discontinuity).
    #
    Step Description: What is the antiderivative of 2x?
    Step Type: fill-blank
    Answer Type: math
    Correct Answer: `x^2+C`
    Alternative Answer: `x^2`
    Must Be Correct: false
    ###
    Problem Title: Linear Algebra Fundamentals
    Problem Description: Answer questions about matrices, vectors, and linear transformations.
    #
    Step Description: Which property does matrix multiplication satisfy?
    Step Type: multiple-choice-single
    Option A: Commutative property (AB = BA)
    Option B: Associative property ((AB)C = A(BC))
    Option C: Both commutative and associative
    Option D: Neither commutative nor associative
    Correct Answer: B
    Must Be Correct: false
    #
    Step Description: Select all statements that are true about invertible matrices:
    Step Type: multiple-choice-multiple
    Option A: The determinant is non-zero
    Option B: The matrix is square
    Option C: The rows are linearly independent
    Option D: The matrix has rank equal to its dimension
    Option E: The matrix can be rectangular
    Correct Answer: A, B, C, D
    Must Be Correct: true
    #
    Step Description: A matrix with a zero determinant is always invertible.
    Step Type: true-false
    Correct Answer: False
    Must Be Correct: false
    #
    Step Description: What is the determinant of the 2√ó2 identity matrix?
    Step Type: fill-blank
    Answer Type: math
    Correct Answer: `1`
    Must Be Correct: false
    ###"""

    def _get_mixed_example(self):
        """Return mixed example text"""
        return """###
    Problem Title: Quadratic Function Analysis
    Problem Description: Explore the quadratic function `f(x) = x^2 - 4x + 3` through derivatives and critical point analysis.
    #
    Step Description: Find the derivative of the quadratic function
    Step Expression: `d/dx(x^2-4x+3)`
    Step Expected: `2x-4`
    #
    Step Description: What does the derivative represent?
    Step Type: multiple-choice-single
    Option A: The slope of the tangent line at any point
    Option B: The area under the curve
    Option C: The x-intercepts of the function
    Option D: The vertex of the parabola
    Correct Answer: A
    Must Be Correct: false
    #
    Step Description: Set the derivative equal to zero to find critical points
    Step Expression: `2x-4`
    Step Expected: `0`
    #
    Step Description: Solve for x
    Step Expression: `2x-4=0`
    Step Expected: `2`
    #
    Step Description: What is the x-coordinate of the vertex?
    Step Type: fill-blank
    Answer Type: math
    Correct Answer: `2`
    Must Be Correct: true
    #
    Step Description: The vertex of a parabola opening upward represents a minimum point.
    Step Type: true-false
    Correct Answer: True
    Must Be Correct: false
    #
    Step Description: Evaluate the function at x = 2 to find the y-coordinate of the vertex
    Step Expression: `(2)^2-4(2)+3`
    Step Expected: `-1`
    ###
    Problem Title: Systems of Linear Equations with Matrices
    Problem Description: Solve the system of equations using matrix row operations: `2x + y = 5` and `3x - 2y = 4`. We'll use the augmented matrix `[[2,1,5],[3,-2,4]]`.
    #
    Step Description: Write the system as an augmented matrix
    Step Expression: `[[2,1,5],[3,-2,4]]`
    Step Expected: `[[2,1,5],[3,-2,4]]`
    #
    Step Description: What method are we using to solve this system?
    Step Type: multiple-choice-single
    Option A: Substitution
    Option B: Elimination
    Option C: Gaussian elimination (row operations)
    Option D: Graphing
    Correct Answer: C
    Must Be Correct: false
    #
    Step Description: Perform R_2 ‚Üí R_2 - (3/2)R_1
    Step Expression: `[[2,1,5],[3,-2,4]]|R_2->R_2-(3/2)R_1`
    Step Expected: `[[2,1,5],[0,-7/2,-7/2]]`
    #
    Step Description: In reduced row echelon form, what value should appear on the main diagonal?
    Step Type: fill-blank
    Answer Type: text
    Correct Answer: 1
    Alternative Answer: one
    Must Be Correct: false
    #
    Step Description: Scale R_2 by -2/7
    Step Expression: `[[2,1,5],[0,-7/2,-7/2]]|R_2->(-2/7)R_2`
    Step Expected: `[[2,1,5],[0,1,1]]`
    #
    Step Description: A system of linear equations can have exactly two solutions.
    Step Type: true-false
    Correct Answer: False
    Must Be Correct: true
    Explanation: A system can have zero, one, or infinitely many solutions, but never exactly two.
    #
    Step Description: Perform R_1 ‚Üí R_1 - R_2
    Step Expression: `[[2,1,5],[0,1,1]]|R_1->R_1-R_2`
    Step Expected: `[[2,0,4],[0,1,1]]`
    #
    Step Description: What is the value of x?
    Step Type: fill-blank
    Answer Type: math
    Correct Answer: `2`
    Must Be Correct: false
    ###
    Problem Title: Product and Chain Rules Combined
    Problem Description: Apply multiple differentiation rules to find the derivative of `f(x) = x^2 * (2x + 1)^3`.
    #
    Step Description: Which differentiation rules apply to this function? (Select all that apply)
    Step Type: multiple-choice-multiple
    Option A: Product rule
    Option B: Chain rule
    Option C: Quotient rule
    Option D: Power rule
    Option E: Sum rule
    Correct Answer: A, B, D
    Must Be Correct: false
    #
    Step Description: Find the derivative using the product rule
    Step Expression: `d/dx(x^2*(2x+1)^3)`
    Step Expected: `2x*(2x+1)^3+x^2*3*(2x+1)^2*2`
    #
    Step Description: Factor out common terms
    Step Expression: `2x*(2x+1)^3+6x^2*(2x+1)^2`
    Step Expected: `2x*(2x+1)^2*(2x+1+3x)`
    #
    Step Description: Simplify the expression in parentheses
    Step Expression: `2x+1+3x`
    Step Expected: `5x+1`
    #
    Step Description: Write the final simplified derivative
    Step Expression: `2x*(2x+1)^2*(5x+1)`
    Step Expected: `2x*(2x+1)^2*(5x+1)`
    #
    Step Description: The product rule states that (fg)' = f'g + fg'.
    Step Type: true-false
    Correct Answer: True
    Must Be Correct: false
    ###"""
                              
    def __init__(self, problem_creator):
        self.problem_creator = problem_creator
        self.is_restoring = False  # ‚úÖ NEW: Flag to disable autosave during restoration
        self.restore_complete = False  # ‚úÖ NEW: Flag to track if restoration finished

    def save_to_storage(self):
        """Save current state to localStorage"""
        # ‚úÖ CRITICAL: Don't autosave during restoration
        if self.is_restoring:
            window.console.log("‚è∏Ô∏è Autosave skipped (restoration in progress)")
            return

        try:
            desc_input = document.querySelector("#problemSetDescription")
            problem_set_description = desc_input.value.strip() if desc_input else ""

            # ‚úÖ Only save problems that are fully initialized
            problems = [
                problem.get_data() 
                for problem in self.problem_creator.problems 
                if not hasattr(problem, 'is_initializing') or not problem.is_initializing
            ]

            save_data = {
                "problem_set_description": problem_set_description,
                "problems": problems,
            }

            json_str = json.dumps(save_data)
            compressed = brotli.compress(json_str.encode("utf-8"))
            b64 = base64.b64encode(compressed).decode("utf-8")
            window.localStorage.setItem(self.STORAGE_KEY, b64)
            window.console.log(f"üíæ Autosaved {len(problems)} problem(s)")

            # ‚úÖ Show autosave notification
            try:
                window.console.log("üîî [PYTHON] Calling showAutosaveIndicator...")
                if hasattr(window, 'showAutosaveIndicator'):
                    window.showAutosaveIndicator(2000)
                    window.console.log("‚úì [PYTHON] Notification triggered successfully")
                else:
                    window.console.error("‚ùå [PYTHON] showAutosaveIndicator not found on window object")
            except Exception as notif_error:
                window.console.error(f"‚ö†Ô∏è [PYTHON] Error showing notification: {notif_error}")

        except Exception as e:
            window.console.error(f"Autosave failed: {e}")
            import traceback
            window.console.error(traceback.format_exc())

    def load_from_storage(self):
        """Load state from localStorage"""
        try:
            stored = window.localStorage.getItem(self.STORAGE_KEY)
            if not stored:
                return None
            data = json.loads(brotli.decompress(base64.b64decode(stored)).decode("utf-8"))
            desc_input = document.querySelector("#problemSetDescription")
            if desc_input and data.get("problem_set_description"):
                desc_input.value = data["problem_set_description"]
            return data.get("problems", data)
        except Exception as e:
            window.console.error(f"Load autosave failed: {e}")
            import traceback
            window.console.error(traceback.format_exc())
            return None

    def clear_autosave(self):
        """Clear autosaved data"""
        try:
            window.localStorage.removeItem(self.STORAGE_KEY)
            window.alert("Autosave cleared")
        except:
            window.alert("Failed to clear autosave")    

    # -----------------------------------------------------
    # ‚úÖ Export JSON (with validation + colored highlighting)
    # -----------------------------------------------------
    def export_json(self):
        """Export all problems with validation and structure rebuilding"""
        math_parser = self.problem_creator.math_parser
        problems = self.problem_creator.problems
        invalid_entries = []
        structures_rebuilt = 0

        # Reset all prior highlight states
        for prob in problems:
            prob_desc_container = prob.dom_element.querySelector(".prob-desc-editor")
            if prob_desc_container:
                prob_desc_container.classList.remove("input-empty", "input-invalid", "input-valid")
            for step in prob.steps:
                for sel in [".step-expr", ".step-expected", ".step-user", ".step-desc-editor"]:
                    el = step.dom_element.querySelector(sel)
                    if el:
                        el.classList.remove("input-empty", "input-invalid", "input-valid")

        # Validation loop with structure rebuilding
        for p_index, problem in enumerate(problems, start=1):
            # Check if description has content (Quill-aware)
            desc_blocks = serialize_quill_content(problem.description_editor_id)
            if not desc_blocks or not isinstance(desc_blocks, list):
                desc_blocks = []

            has_desc_content = any(
                isinstance(block, dict) and 
                block.get("type") in ["text", "math", "image"] and 
                (block.get("value", "").strip() if block.get("type") == "text" else True)
                for block in desc_blocks
            )

            if not has_desc_content:
                invalid_entries.append(f"Problem {p_index}: description is empty")
                desc_container = problem.dom_element.querySelector(".prob-desc-editor")
                if desc_container:
                    desc_container.classList.add("input-empty")

            for s_index, step in enumerate(problem.steps, start=1):
                # Check step description (Quill-aware)
                step_desc_blocks = serialize_quill_content(step.description_editor_id)
                if not step_desc_blocks or not isinstance(step_desc_blocks, list):
                    step_desc_blocks = []

                has_step_desc = any(
                    isinstance(block, dict) and
                    block.get("type") in ["text", "math", "image"] and
                    (block.get("value", "").strip() if block.get("type") == "text" else True)
                    for block in step_desc_blocks
                )

                if not has_step_desc:
                    invalid_entries.append(f"Problem {p_index}, Step {s_index}: description is empty")
                    step_desc_container = step.dom_element.querySelector(".step-desc-editor")
                    if step_desc_container:
                        step_desc_container.classList.add("input-empty")

                # ‚úÖ NEW: Handle validation based on step type
                if step.step_type == "step-by-step":
                    # Original validation logic for step-by-step questions
                    expr_tex = step.expr_mf.latex().strip() if step.expr_mf else ""
                    exp_tex = step.expected_mf.latex().strip() if step.expected_mf else ""

                    expr_el = step.dom_element.querySelector(".step-expr")
                    exp_el = step.dom_element.querySelector(".step-expected")

                    # Check and rebuild structure if needed
                    structure_rebuilt = False
                    if exp_tex:
                        try:
                            parsed = math_parser.parse_latex(exp_tex)
                            if parsed is not None:
                                computed_structure = math_parser.extract_structure(parsed)

                                if (hasattr(step, 'loaded_expected_structure') and 
                                    step.loaded_expected_structure and 
                                    computed_structure):

                                    def structures_match(stored, computed):
                                        if not stored or not computed:
                                            return False
                                        stored_ops = stored.get("operators", {})
                                        computed_ops = computed.get("operators", {})
                                        if stored_ops != computed_ops:
                                            return False
                                        stored_operands = stored.get("operands", {})
                                        computed_operands = computed.get("operands", {})
                                        if stored_operands != computed_operands:
                                            return False
                                        return True

                                    if not structures_match(step.loaded_expected_structure, computed_structure):
                                        window.console.log(f"üîß Rebuilding structure for Problem {p_index}, Step {s_index}")
                                        try:
                                            step.loaded_expected_structure = math_parser.structure_to_json_serializable(
                                                computed_structure
                                            )
                                            structure_rebuilt = True
                                            structures_rebuilt += 1
                                            window.console.log(f"‚úÖ Structure rebuilt and serialized")
                                        except Exception as e:
                                            window.console.error(f"‚ùå Failed to serialize rebuilt structure: {e}")
                                            import traceback
                                            window.console.error(traceback.format_exc())
                                elif not hasattr(step, 'loaded_expected_structure') or not step.loaded_expected_structure:
                                    step.loaded_expected_structure = computed_structure
                                    structure_rebuilt = True
                                    structures_rebuilt += 1
                        except Exception as e:
                            window.console.log(f"Error rebuilding structure: {e}")

                    # Get updated step data
                    step_data = step.get_data()
                    stored_expected_structure = step_data.get("expected_structure")
                    has_expected_structure = stored_expected_structure is not None

                    # Expression empty
                    if not expr_tex:
                        invalid_entries.append(f"Problem {p_index}, Step {s_index}: expression empty")
                        if expr_el:
                            expr_el.classList.add("input-empty")
                        continue

                    # Expected empty BUT check if we have expected_structure
                    if not exp_tex and not has_expected_structure:
                        invalid_entries.append(f"Problem {p_index}, Step {s_index}: expected answer empty and no structure")
                        if exp_el:
                            exp_el.classList.add("input-empty")
                        continue
                    elif not exp_tex and has_expected_structure:
                        if expr_el:
                            expr_el.classList.add("input-valid")
                        if exp_el:
                            exp_el.classList.add("input-valid")
                        continue

                    # Parse and validate
                    try:
                        expr_val = math_parser.parse_latex(expr_tex)
                        exp_val = math_parser.parse_latex(exp_tex) if exp_tex else None

                        if expr_val is None:
                            invalid_entries.append(f"Problem {p_index}, Step {s_index}: could not parse expression")
                            if expr_el:
                                expr_el.classList.add("input-invalid")
                            continue

                        if exp_tex and exp_val is None:
                            invalid_entries.append(f"Problem {p_index}, Step {s_index}: could not parse expected answer")
                            if exp_el:
                                exp_el.classList.add("input-invalid")
                            continue

                        # Validate limit for expression
                        is_expr_valid, expr_error_msg = math_parser.validate_limit(expr_val)
                        if not is_expr_valid:
                            invalid_entries.append(f"Problem {p_index}, Step {s_index}: invalid limit in expression - {expr_error_msg}")
                            if expr_el:
                                expr_el.classList.add("input-invalid")
                            continue

                        if exp_val:
                            # Validate limit for expected answer
                            is_exp_valid, exp_error_msg = math_parser.validate_limit(exp_val)
                            if not is_exp_valid:
                                invalid_entries.append(f"Problem {p_index}, Step {s_index}: invalid limit in expected answer - {exp_error_msg}")
                                if exp_el:
                                    exp_el.classList.add("input-invalid")
                                continue

                            # Normalize and compare
                            expr_norm = math_parser.normalize_expr(expr_val)
                            exp_norm = math_parser.normalize_expr(exp_val)

                            if math_parser.final_eq(expr_norm, exp_norm):
                                if expr_el:
                                    expr_el.classList.add("input-valid")
                                if exp_el:
                                    exp_el.classList.add("input-valid")
                            else:
                                invalid_entries.append(f"Problem {p_index}, Step {s_index}: expression ‚â† expected")
                                if expr_el:
                                    expr_el.classList.add("input-invalid")
                                if exp_el:
                                    exp_el.classList.add("input-invalid")
                        else:
                            if expr_el:
                                expr_el.classList.add("input-valid")

                    except Exception as e:
                        invalid_entries.append(f"Problem {p_index}, Step {s_index}: {e}")
                        if expr_el:
                            expr_el.classList.add("input-invalid")
                        if exp_el:
                            exp_el.classList.add("input-invalid")

                elif step.step_type == "multiple-choice-single":
                    # ‚úÖ Validate multiple choice single
                    step_data = step.get_data()
                    options = step_data.get("options", [])
                    correct_answer = step_data.get("correct_answer", "")

                    if len(options) == 0:
                        invalid_entries.append(f"Problem {p_index}, Step {s_index}: no options defined")
                    elif not correct_answer:
                        invalid_entries.append(f"Problem {p_index}, Step {s_index}: no correct answer selected")
                    else:
                        # Check if options have content
                        empty_options = []
                        for opt in options:
                            content = opt.get("content", [])
                            has_content = any(
                                isinstance(block, dict) and
                                block.get("type") in ["text", "math", "image"] and
                                (block.get("value", "").strip() if block.get("type") == "text" else True)
                                for block in content
                            )
                            if not has_content:
                                empty_options.append(opt.get("label", ""))

                        if empty_options:
                            invalid_entries.append(f"Problem {p_index}, Step {s_index}: empty option(s): {', '.join(empty_options)}")

                elif step.step_type == "multiple-choice-multiple":
                    # ‚úÖ Validate multiple choice multiple
                    step_data = step.get_data()
                    options = step_data.get("options", [])
                    correct_answers = step_data.get("correct_answers", [])

                    if len(options) == 0:
                        invalid_entries.append(f"Problem {p_index}, Step {s_index}: no options defined")
                    elif len(correct_answers) == 0:
                        invalid_entries.append(f"Problem {p_index}, Step {s_index}: no correct answers selected")
                    else:
                        # Check if options have content
                        empty_options = []
                        for opt in options:
                            content = opt.get("content", [])
                            has_content = any(
                                isinstance(block, dict) and
                                block.get("type") in ["text", "math", "image"] and
                                (block.get("value", "").strip() if block.get("type") == "text" else True)
                                for block in content
                            )
                            if not has_content:
                                empty_options.append(opt.get("label", ""))

                        if empty_options:
                            invalid_entries.append(f"Problem {p_index}, Step {s_index}: empty option(s): {', '.join(empty_options)}")

                elif step.step_type == "true-false":
                    # ‚úÖ Validate true/false
                    step_data = step.get_data()
                    correct_answer = step_data.get("correct_answer")

                    if correct_answer is None:
                        invalid_entries.append(f"Problem {p_index}, Step {s_index}: no answer selected (True or False)")

                elif step.step_type == "fill-blank":
                    # ‚úÖ Validate fill in the blank
                    step_data = step.get_data()
                    correct_answers = step_data.get("correct_answers", [])

                    if len(correct_answers) == 0:
                        invalid_entries.append(f"Problem {p_index}, Step {s_index}: no correct answers defined")
                    else:
                        # Check if answers have content
                        empty_count = sum(1 for ans in correct_answers if not ans.get("value", "").strip())
                        if empty_count > 0:
                            invalid_entries.append(f"Problem {p_index}, Step {s_index}: {empty_count} empty answer(s)")

        # If invalid entries found
        if invalid_entries:
            self._show_popup(
                "‚ö†Ô∏è Export blocked",
                "Some fields are empty or incorrect.\n\nüüß Orange = Missing field\nüî¥ Red = Incorrect answer\n\n"
                + "\n".join(invalid_entries[:10])
                + ("\n...and more." if len(invalid_entries) > 10 else "")
            )
            return

        # Save to storage after structure rebuilds
        if structures_rebuilt > 0:
            self.save_to_storage()
            window.console.log(f"Rebuilt {structures_rebuilt} structure(s) during export")

        # All valid ‚Üí proceed with export
        desc_input = document.querySelector("#problemSetDescription")
        problem_set_description = desc_input.value.strip() if desc_input else ""
        if not problem_set_description:
            problem_set_description = f"Problem Set {window.Date.new().toLocaleString()}"

        problem_set_uuid = str(uuid.uuid4())
        uuid_display = document.querySelector("#problemSetUuid")
        if uuid_display:
            uuid_display.textContent = problem_set_uuid
            uuid_display.style.color = "#0369a1"

        export_data = {
            "problem_set_id": problem_set_uuid,
            "problem_set_description": problem_set_description,
            "problems": [p.get_data() for p in problems],
            "metadata": {
                "created": window.Date.new().toISOString(),
                "version": "1.1",
                "problem_count": len(problems),
            },
        }

        # ‚úÖ NEW: Final safety check - ensure all structures are serializable
        window.console.log("üîç Validating JSON serializability...")
        try:
            # Test serialize the export_data
            test_json = json.dumps(export_data)
            window.console.log("‚úÖ Export data is valid JSON")
        except Exception as e:
            window.console.error(f"‚ùå Export data contains non-serializable objects: {e}")

            # Try to identify the problem
            for p_idx, prob_data in enumerate(export_data["problems"], 1):
                for s_idx, step_data in enumerate(prob_data.get("steps", []), 1):
                    try:
                        json.dumps(step_data.get("expected_structure", {}))
                    except Exception as step_error:
                        self._show_popup(
                            "‚ùå Export Failed",
                            f"Problem {p_idx}, Step {s_idx} contains non-serializable data:\n{step_error}\n\nPlease use 'Analyze Structure' button to rebuild."
                        )
                        return

            # Generic error if we can't pinpoint it
            self._show_popup("‚ùå Export Failed", f"Data contains non-serializable objects:\n{e}")
            return

        json_str = json.dumps(export_data, indent=2)
        try:
          compressed = brotli.compress(json_str.encode("utf-8"))
          b64 = base64.b64encode(compressed).decode("utf-8")
        except Exception:
          b64 = base64.b64encode(json_str.encode("utf-8")).decode("utf-8")

        # Display & copy
        document.querySelector("#exportedJson").innerText = b64
        try:
          window.navigator.clipboard.writeText(b64)
          success_msg = f"üìù {problem_set_description}\nüìä {len(problems)} problem(s)\nüîë UUID: {problem_set_uuid}"
          if structures_rebuilt > 0:
              success_msg += f"\nüîß Rebuilt {structures_rebuilt} structure(s)"
          self._show_popup("‚úÖ Export successful", success_msg)
        except:
          self._show_popup(
              "‚úÖ Export successful (manual copy)",
              f"üìù {problem_set_description}\nüìä {len(problems)} problem(s)\nüîë UUID: {problem_set_uuid}\n\nPlease copy the exported data manually."
          )
    # -----------------------------------------------------
    # ‚úÖ Download Exported JSON
    # -----------------------------------------------------
    def download_json(self):
        """Download exported Base64 JSON as file"""
        self.export_json()
        blob = window.Blob.new([document.querySelector("#exportedJson").innerText], {"type": "text/plain"})
        url = window.URL.createObjectURL(blob)
        a = document.createElement("a")
        a.href = url
        a.download = "problems_export.txt"
        document.body.appendChild(a)
        a.click()
        a.remove()
        window.setTimeout(create_proxy(lambda: window.URL.revokeObjectURL(url)), 1000)

    # -----------------------------------------------------
    # ‚úÖ Import Problem Sets
    # -----------------------------------------------------
    def import_problem(self):
        """Import problem set via pasted JSON or uploaded file with integrated examples"""
        backdrop = document.createElement("div")
        backdrop.style.cssText = (
            "position:fixed;top:0;left:0;right:0;bottom:0;"
            "background:rgba(0,0,0,0.6);z-index:1000;"
            "display:flex;align-items:center;justify-content:center;"
        )

        modal = document.createElement("div")
        modal.style.cssText = (
            "background:#fff;border-radius:12px;padding:20px;"
            "max-width:900px;width:95%;max-height:85vh;overflow-y:auto;"
            "box-shadow:0 20px 60px rgba(0,0,0,0.3);"
        )

        modal.innerHTML = """
            <h3 style='margin-top:0;color:#0b6efd;'>üì• Import Problem Set</h3>

            <!-- Tab Navigation -->
            <div style='display:flex;gap:8px;margin-bottom:16px;border-bottom:2px solid #e6eef8;'>
                <button id='pasteTabBtn' class='import-tab active' style='
                    padding:8px 16px;border:none;background:transparent;
                    color:#0b6efd;border-bottom:2px solid #0b6efd;
                    cursor:pointer;font-weight:600;margin-bottom:-2px;
                '>üìã Paste</button>
                <button id='uploadJsonTabBtn' class='import-tab' style='
                    padding:8px 16px;border:none;background:transparent;
                    color:#64748b;cursor:pointer;font-weight:600;
                '>üìÑ JSON File</button>
                <button id='uploadTextTabBtn' class='import-tab' style='
                    padding:8px 16px;border:none;background:transparent;
                    color:#64748b;cursor:pointer;font-weight:600;
                '>üìù Text File</button>
                <button id='examplesTabBtn' class='import-tab' style='
                    padding:8px 16px;border:none;background:transparent;
                    color:#64748b;cursor:pointer;font-weight:600;
                '>üí° Examples</button>
            </div>

            <!-- Paste Tab -->
            <div id='pasteTab' class='import-content' style='display:block;'>
                <div style="margin-bottom: 12px; padding: 10px; background: #f0f9ff; border-radius: 6px; font-size: 13px;">
                    <strong>Supported formats:</strong><br>
                    1. <strong>JSON format</strong>: Paste exported base64 string<br>
                    2. <strong>Text format</strong>: Use this structure:<br>
                    <code style="display: block; margin-top: 4px; padding: 8px; background: white; border-radius: 4px; font-size: 11px;">
    ###<br>
    Problem Title: Derivative of a Function<br>
    Problem Description: Solve `d/dx(x^3-2x^2)`<br>
    #<br>
    Step Description: Find the derivative<br>
    Step Expression: `d/dx(x^3-2x^2)`<br>
    Step Expected: `3x^2-4x`<br>
    ###
                    </code>
                    <div style="margin-top:8px; padding:8px; background:#fff4e6; border-radius:4px; border-left:3px solid #f59e0b;">
                        <strong>üìå New Field:</strong> For MC/True-False/Fill-blank questions, add:<br>
                        <code style="font-size:11px;">Must Be Correct: true</code> (or false)
                    </div>
                </div>
                <div style='margin-bottom:16px;'>
                    <label>Paste Base64 JSON or Formatted Plain Text</label>
                    <textarea id='importTextArea' style='width:100%;min-height:120px;padding:10px;border:1px solid #e6eef8;border-radius:8px;font-family:monospace;font-size:12px;'></textarea>
                </div>
            </div>

            <!-- Upload JSON Tab -->
            <div id='uploadJsonTab' class='import-content' style='display:none;'>
                <div style="margin-bottom: 12px; padding: 10px; background: #f0f9ff; border-radius: 6px; font-size: 13px;">
                    <strong>üìÑ JSON File Upload</strong><br>
                    Upload a .txt or .json file containing the compressed base64 JSON export.<br>
                    This is the same format you get from "Export All" or "Download JSON".
                </div>
                <div style='margin-bottom:20px;'>
                    <label>Upload JSON File</label>
                    <input type='file' id='importJsonFileInput' accept='.txt,.json,text/plain,application/json' style='width:100%;padding:10px;border:2px dashed #0b6efd;border-radius:8px;background:#f0f9ff;cursor:pointer;'/>
                    <div id='jsonFileInfo' style='margin-top:8px;font-size:12px;color:#64748b;'></div>
                </div>
            </div>

            <!-- Upload Text Tab -->
            <div id='uploadTextTab' class='import-content' style='display:none;'>
                <div style="margin-bottom: 12px; padding: 10px; background: #fff4e6; border-radius: 6px; font-size: 13px;">
                    <strong>üìù Plain Text File Upload</strong><br>
                    Upload a .txt file with the formatted plain text structure.<br>
                    Format: Problems separated by ###, steps separated by #<br>
                    <code style="display: block; margin-top: 4px; padding: 8px; background: white; border-radius: 4px; font-size: 11px;">
    ###<br>
    Problem Title: ...<br>
    Problem Description: ...<br>
    #<br>
    Step Description: ...<br>
    Step Expression: ...<br>
    Step Expected: ...<br>
    ###
                    </code>
                </div>
                <div style='margin-bottom:20px;'>
                    <label>Upload Text File</label>
                    <input type='file' id='importTextFileInput' accept='.txt,text/plain' style='width:100%;padding:10px;border:2px dashed #f59e0b;border-radius:8px;background:#fff4e6;cursor:pointer;'/>
                    <div id='textFileInfo' style='margin-top:8px;font-size:12px;color:#64748b;'></div>
                </div>
            </div>

            <!-- Examples Tab -->
            <div id='examplesTab' class='import-content' style='display:none;'>
                <div style="margin-bottom:12px;">
                    <label style="font-weight:600; display:block; margin-bottom:6px;">Select Example:</label>
                    <select id='exampleSelector' style='width:100%; padding:8px; border:2px solid #e6eef8; border-radius:8px; font-size:14px;'>
                        <option value="">-- Choose an example --</option>
                        <option value="math-only">Example 1: Math Only (Derivatives & Matrices)</option>
                        <option value="assessment-only">Example 2: Assessment Only (MC, T/F, Fill-blank)</option>
                        <option value="mixed">Example 3: Mixed (Math + Assessment)</option>
                    </select>
                </div>
                <div id='exampleDisplay' style='display:none; margin-top:12px;'>
                    <div style='display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;'>
                        <label style="font-weight:600;">Example Content:</label>
                        <button id='copyExampleBtn' style='
                            padding:6px 12px; background:#10b981; color:white; border:none;
                            border-radius:6px; cursor:pointer; font-size:13px; font-weight:600;
                        '>üìã Copy to Import Area</button>
                    </div>
                    <div id='exampleContent' style='
                        max-height:300px; overflow-y:auto; padding:12px; 
                        background:#f8fafc; border:2px solid #e6eef8; border-radius:8px;
                        font-family:monospace; font-size:11px; white-space:pre-wrap;
                        line-height:1.4;
                    '></div>
                </div>
            </div>

            <!-- Action Buttons -->
            <div style='display:flex;gap:8px;justify-content:flex-end; margin-top:16px;'>
                <button id='importCancelBtn' class='btn ghost'>Cancel</button>
                <button id='importProcessBtn' class='btn'>Import</button>
            </div>
        """
        backdrop.appendChild(modal)
        document.body.appendChild(backdrop)

        # Get references
        text_area = modal.querySelector("#importTextArea")
        json_file_input = modal.querySelector("#importJsonFileInput")
        text_file_input = modal.querySelector("#importTextFileInput")
        json_file_info = modal.querySelector("#jsonFileInfo")
        text_file_info = modal.querySelector("#textFileInfo")
        example_selector = modal.querySelector("#exampleSelector")
        example_display = modal.querySelector("#exampleDisplay")
        example_content = modal.querySelector("#exampleContent")
        copy_example_btn = modal.querySelector("#copyExampleBtn")

        # Tab elements
        paste_tab_btn = modal.querySelector("#pasteTabBtn")
        upload_json_tab_btn = modal.querySelector("#uploadJsonTabBtn")
        upload_text_tab_btn = modal.querySelector("#uploadTextTabBtn")
        examples_tab_btn = modal.querySelector("#examplesTabBtn")

        paste_tab = modal.querySelector("#pasteTab")
        upload_json_tab = modal.querySelector("#uploadJsonTab")
        upload_text_tab = modal.querySelector("#uploadTextTab")
        examples_tab = modal.querySelector("#examplesTab")

        # Define examples
        examples = {
            "math-only": self._get_math_only_example(),
            "assessment-only": self._get_assessment_only_example(),
            "mixed": self._get_mixed_example()
        }

        # Tab switching function
        def switch_tab(active_btn, active_content):
            # Reset all tabs
            for btn in [paste_tab_btn, upload_json_tab_btn, upload_text_tab_btn, examples_tab_btn]:
                btn.style.color = "#64748b"
                btn.style.borderBottom = "none"
                btn.classList.remove("active")

            for content in [paste_tab, upload_json_tab, upload_text_tab, examples_tab]:
                content.style.display = "none"

            # Activate selected tab
            active_btn.style.color = "#0b6efd"
            active_btn.style.borderBottom = "2px solid #0b6efd"
            active_btn.classList.add("active")
            active_content.style.display = "block"

        # Wire tab buttons
        paste_tab_btn.addEventListener("click", create_proxy(
            lambda e: switch_tab(paste_tab_btn, paste_tab)
        ))
        upload_json_tab_btn.addEventListener("click", create_proxy(
            lambda e: switch_tab(upload_json_tab_btn, upload_json_tab)
        ))
        upload_text_tab_btn.addEventListener("click", create_proxy(
            lambda e: switch_tab(upload_text_tab_btn, upload_text_tab)
        ))
        examples_tab_btn.addEventListener("click", create_proxy(
            lambda e: switch_tab(examples_tab_btn, examples_tab)
        ))

        # Example selector handler
        def on_example_change(e):
            selected = example_selector.value
            if selected and selected in examples:
                example_display.style.display = "block"
                example_content.textContent = examples[selected]
            else:
                example_display.style.display = "none"

        example_selector.addEventListener("change", create_proxy(on_example_change))

        # Copy example button handler
        def copy_example(e):
            selected = example_selector.value
            if selected and selected in examples:
                text_area.value = examples[selected]
                # Switch to paste tab
                switch_tab(paste_tab_btn, paste_tab)
                # Show success feedback
                copy_example_btn.textContent = "‚úÖ Copied!"
                copy_example_btn.style.background = "#10b981"
                window.setTimeout(create_proxy(lambda: (
                    copy_example_btn.style.setProperty("textContent", "üìã Copy to Import Area"),
                    copy_example_btn.style.setProperty("background", "#10b981")
                )), 1500)

        copy_example_btn.addEventListener("click", create_proxy(copy_example))

        # File info display handlers
        def show_json_file_info(e):
            if json_file_input.files and json_file_input.files.length > 0:
                file = json_file_input.files.item(0)
                size_kb = (file.size / 1024).toFixed(1)
                json_file_info.innerHTML = f"‚úì Selected: {file.name} ({size_kb} KB)"
                json_file_info.style.color = "#16a34a"

        def show_text_file_info(e):
            if text_file_input.files and text_file_input.files.length > 0:
                file = text_file_input.files.item(0)
                size_kb = (file.size / 1024).toFixed(1)
                text_file_info.innerHTML = f"‚úì Selected: {file.name} ({size_kb} KB)"
                text_file_info.style.color = "#16a34a"

        json_file_input.addEventListener("change", create_proxy(show_json_file_info))
        text_file_input.addEventListener("change", create_proxy(show_text_file_info))

        def close_modal():
            backdrop.remove()

        def process_import():
            # Determine active tab and process accordingly
            active_tab = modal.querySelector(".import-tab.active")

            if active_tab == paste_tab_btn:
                # Paste tab - existing logic
                if text_area.value.strip():
                    self._process_text_import(text_area.value.strip(), close_modal)
                else:
                    window.alert("Please paste JSON data or formatted text to import.")

            elif active_tab == upload_json_tab_btn:
                # JSON file upload
                if json_file_input.files and json_file_input.files.length > 0:
                    self._process_file_import(json_file_input.files.item(0), close_modal, file_type='json')
                else:
                    window.alert("Please select a JSON file to upload.")

            elif active_tab == upload_text_tab_btn:
                # Text file upload
                if text_file_input.files and text_file_input.files.length > 0:
                    self._process_file_import(text_file_input.files.item(0), close_modal, file_type='text')
                else:
                    window.alert("Please select a text file to upload.")

            elif active_tab == examples_tab_btn:
                # Examples tab - copy to paste tab
                selected = example_selector.value
                if selected and selected in examples:
                    text_area.value = examples[selected]
                    switch_tab(paste_tab_btn, paste_tab)
                    window.alert("‚úÖ Example copied to import area! Click 'Import' again to process.")
                else:
                    window.alert("Please select an example first.")

        modal.querySelector("#importCancelBtn").addEventListener("click", create_proxy(lambda e: close_modal()))
        modal.querySelector("#importProcessBtn").addEventListener("click", create_proxy(lambda e: process_import()))
        backdrop.addEventListener("click", create_proxy(lambda e: close_modal() if e.target == backdrop else None))

        # Add CSS for import tabs
        js_css = """
        (function() {
            if (!document.getElementById('import-tabs-css')) {
                const style = document.createElement('style');
                style.id = 'import-tabs-css';
                style.textContent = `
                    .import-tab {
                        transition: all 0.2s ease;
                    }
                    .import-tab:hover {
                        color: #0b6efd !important;
                        background: rgba(11, 110, 253, 0.05);
                    }
                    .import-tab.active {
                        color: #0b6efd !important;
                    }
                    #importJsonFileInput:hover,
                    #importTextFileInput:hover {
                        border-color: #0b6efd;
                        background: rgba(11, 110, 253, 0.05);
                    }
                    #copyExampleBtn:hover {
                        background: #059669 !important;
                        transform: translateY(-1px);
                        box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
                    }
                `;
                document.head.appendChild(style);
            }
        })();
        """
        window.eval(js_css)
    def _process_text_import(self, raw_text, close_modal):
      try:
          # Check if it's the text format or base64 format
          if '###' in raw_text and ('Problem Title:' in raw_text or 'Step Expression:' in raw_text):
              # It's the text format
              window.console.log("Detected text format import")
              data = self._parse_text_format(raw_text)
          else:
              # It's the base64/compressed format
              window.console.log("Detected base64 format import")
              cleaned = self._extract_base64_from_text(raw_text)
              decompressed = brotli.decompress(base64.b64decode(cleaned)).decode("utf-8")
              data = json.loads(decompressed)

          self._import_problem_data(data)
          close_modal()
      except Exception as e:
          window.console.error(f"Import error: {e}")
          window.alert(f"Import failed: {e}")

    def _process_file_import(self, file, close_modal):
        from js import FileReader
        reader = FileReader.new()

        def on_load(event):
            try:
                content = event.target.result
                cleaned = self._extract_base64_from_text(content)
                decompressed = brotli.decompress(base64.b64decode(cleaned)).decode("utf-8")
                data = json.loads(decompressed)
                self._import_problem_data(data)
                close_modal()
            except Exception as e:
                window.alert(f"Import failed: {e}")

        reader.onload = create_proxy(on_load)
        reader.readAsText(file)

    def _extract_base64_from_text(self, text):
        import re
        text = str(text).strip()
        if "=== EXPORT" in text:
            matches = re.findall(r"===.*?EXPORT.*?===(.*?)(?:===|$)", text, re.DOTALL)
            if matches:
                return re.sub(r"[\s\r\n]+", "", "".join(matches))
        return re.sub(r"[\s\r\n]+", "", text)

    def _parse_text_format(self, text):
        """
        Parse text format into problem data structure.
        Format:
        ###
        Problem Title: <title>
        Problem Description: <description with $$latex$$ or `asciimath` and \n>
        #
        Step Description: <description>
        Step Type: <type> (optional, defaults to step-by-step)
        Step Expression: <expression> (for step-by-step)
        Step Expected: <expected> (for step-by-step)
        Option A: <content> (for multiple choice)
        Correct Answer: <answer> (for all assessment types)
        Must Be Correct: true/false (optional)
        ###

        ‚≠ê Now supports all step types and "Must Be Correct" field
        ‚≠ê Preserves backticks when AsciiMathParser is not available
        """
        import re

        def parse_mixed_content(content):
            """Parse text with $$latex$$ or `asciimath` into blocks array"""
            if not content:
                return []

            # Replace literal \n with actual newlines
            content = content.replace('\\n', '\n')

            blocks = []
            current_pos = 0

            # Pattern to match $$...$$, `...`, or plain text
            pattern = r'(\$\$.*?\$\$|`.*?`)'
            matches = list(re.finditer(pattern, content, re.DOTALL))

            for match in matches:
                # Add text before the match
                if match.start() > current_pos:
                    text_before = content[current_pos:match.start()]
                    if text_before:
                        blocks.append({"type": "text", "value": text_before})

                # Add the math content
                matched_str = match.group(0)
                if matched_str.startswith('$$') and matched_str.endswith('$$'):
                    # LaTeX
                    latex_content = matched_str[2:-2].strip()
                    blocks.append({"type": "math", "latex": latex_content})
                elif matched_str.startswith('`') and matched_str.endswith('`'):
                    # AsciiMath - store as text with backticks for now
                    blocks.append({"type": "text", "value": matched_str})

                current_pos = match.end()

            # Add remaining text
            if current_pos < len(content):
                remaining = content[current_pos:]
                if remaining:
                    blocks.append({"type": "text", "value": remaining})

            return blocks if blocks else [{"type": "text", "value": content}]

        def convert_math_to_latex(math_string):
            """
            Convert math string to LaTeX.
            If enclosed in backticks: use AsciiMathParser to convert, but protect matrices
            If AsciiMathParser is not available: return original with backticks
            If enclosed in $$: extract the LaTeX
            Otherwise: return as-is
            """
            if not math_string:
                return ""

            math_string = math_string.strip()

            # Check if it's AsciiMath (enclosed in backticks)
            if math_string.startswith('`') and math_string.endswith('`'):
                # Extract AsciiMath content
                asciimath_content = math_string[1:-1].strip()

                # ‚≠ê First check if AsciiMathParser is available
                js_check = """
                (function() {
                    return typeof AsciiMathParser !== 'undefined';
                })();
                """

                parser_available = window.eval(js_check)

                if not parser_available:
                    window.console.warn(f"‚ö†Ô∏è AsciiMathParser not available, keeping original: {math_string}")
                    return math_string  # ‚úÖ Return original with backticks

                # ‚≠ê Extract and protect matrices
                matrices = []
                protected_content = asciimath_content

                # Find all matrices using bracket counting
                i = 0
                while i < len(protected_content):
                    if protected_content[i:i+2] == '[[':
                        # Found start of matrix, find the matching ]]
                        bracket_count = 0
                        start = i
                        j = i

                        while j < len(protected_content):
                            if protected_content[j] == '[':
                                bracket_count += 1
                            elif protected_content[j] == ']':
                                bracket_count -= 1
                                if bracket_count == 0:
                                    # Found the closing ]]
                                    end = j + 1
                                    matrix_str = protected_content[start:end]
                                    # ‚≠ê Use text marker that won't be interpreted
                                    placeholder = f"text(MATRIX{len(matrices)})"
                                    matrices.append(matrix_str)
                                    protected_content = protected_content[:start] + placeholder + protected_content[end:]
                                    i = start + len(placeholder)
                                    break
                            j += 1
                        else:
                            i += 1
                    else:
                        i += 1

                # Escape for JavaScript
                escaped_content = protected_content.replace("\\", "\\\\").replace("'", "\\'")

                # Convert non-matrix parts using AsciiMathParser
                js_code = f"""
                (function() {{
                    try {{
                        if (typeof AsciiMathParser === 'undefined') {{
                            console.error('AsciiMathParser not found');
                            return null;
                        }}

                        const parser = new AsciiMathParser();
                        const asciimath = '{escaped_content}';
                        const latex = parser.parse(asciimath);

                        return latex;

                    }} catch(e) {{
                        console.error('‚ùå AsciiMath conversion error:', e);
                        return null;
                    }}
                }})();
                """

                latex_result = window.eval(js_code)

                if not latex_result:
                    window.console.warn(f"‚ö†Ô∏è Failed to convert AsciiMath, keeping original: {math_string}")
                    return math_string  # ‚úÖ Return original with backticks

                # Remove spaces between \left/\right and brackets
                latex_result = re.sub(r'\\left\s+\[', r'\\left[', latex_result)
                latex_result = re.sub(r'\\right\s+\]', r'\\right]', latex_result)

                # ‚≠ê Process matrices - convert elements individually
                latex_matrices = []
                for matrix_str in matrices:
                    # Parse: [[1,0],[0,1]] -> rows
                    inner = matrix_str[2:-2]  # Strip the [[ ]] from the matrix
                    row_pattern = r'\[([^\]]*)\]'  # Match rows
                    rows = re.findall(row_pattern, inner)

                    converted_rows = []
                    for row in rows:
                        row_content = row.strip()
                        elements = row_content.split(',')

                        # Convert each element
                        converted_elements = []
                        for elem in elements:
                            elem = elem.strip()
                            # Escape the elements properly for JavaScript evaluation
                            escaped_elem = elem.replace("\\", "\\\\").replace("'", "\\'")

                            elem_js = f"""
                            (function() {{
                                try {{
                                    if (typeof AsciiMathParser === 'undefined') {{
                                        return '{escaped_elem}';
                                    }}
                                    const parser = new AsciiMathParser();
                                    return parser.parse('{escaped_elem}');
                                }} catch(e) {{
                                    return '{escaped_elem}';
                                }}
                            }})();
                            """

                            try:
                                converted_elem = str(window.eval(elem_js))
                                converted_elements.append(converted_elem)
                            except:
                                converted_elements.append(elem)

                        converted_row = '[' + ','.join(converted_elements) + ']'
                        converted_rows.append(converted_row)

                    latex_matrix = '[' + ','.join(converted_rows) + ']'
                    latex_matrices.append(latex_matrix)

                # ‚≠ê Restore matrices - look for the text() wrapper in LaTeX output
                for i, latex_matrix in enumerate(latex_matrices):
                    # AsciiMathParser converts text(MATRIX0) to \text{MATRIX0}
                    placeholder_latex = f"\\text{{MATRIX{i}}}"
                    latex_result = latex_result.replace(placeholder_latex, latex_matrix)

                return latex_result

            # Check if it's LaTeX (enclosed in $$)
            elif math_string.startswith('$$') and math_string.endswith('$$'):
                return math_string[2:-2].strip()

            # Otherwise, assume it's already LaTeX
            else:
                return math_string

        def extract_field(lines, prefix):
            """Extract field value from lines starting with prefix"""
            for i, line in enumerate(lines):
                stripped_line = line.strip()  # ‚úÖ Strip once and reuse
                if stripped_line.startswith(prefix):
                    # Get everything after the prefix from the stripped line
                    value = stripped_line[len(prefix):].strip()

                    # Check if value continues on next lines (multi-line)
                    j = i + 1
                    while j < len(lines) and not any(
                        lines[j].strip().startswith(p) for p in 
                        ['Problem Title:', 'Problem Description:', 'Step Description:', 
                         'Step Type:', 'Step Expression:', 'Step Expected:', 
                         'Option A:', 'Option B:', 'Option C:', 'Option D:', 
                         'Option E:', 'Option F:', 'Option G:', 'Option H:',
                         'Correct Answer:', 'Must Be Correct:', 'Answer Type:', 
                         'Alternative Answer:', 'Explanation:', '#', '###']
                    ):
                        if lines[j].strip():
                            value += ' ' + lines[j].strip()
                        j += 1
                    return value
            return None

        def extract_options(lines):
            """Extract multiple choice options from lines"""
            options = []
            option_labels = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']

            for label in option_labels:
                option_content = extract_field(lines, f'Option {label}:')
                if option_content:
                    # Parse option content as mixed content (may contain math)
                    content_blocks = parse_mixed_content(option_content)
                    options.append({
                        'label': label,
                        'content': content_blocks,
                        'content_type': 'rich'
                    })

            return options

        try:
            # Split by ### to get problems
            problem_sections = text.strip().split('###')
            problem_sections = [p.strip() for p in problem_sections if p.strip()]

            problems = []

            for prob_section in problem_sections:
                # Split by # to separate problem header from steps
                parts = prob_section.split('#')
                parts = [p.strip() for p in parts if p.strip()]

                if not parts:
                    continue

                # First part is problem info
                problem_lines = parts[0].split('\n')

                title = extract_field(problem_lines, 'Problem Title:')
                description_text = extract_field(problem_lines, 'Problem Description:')

                # Parse description into blocks
                description_blocks = parse_mixed_content(description_text) if description_text else []

                # Remaining parts are steps
                steps = []
                for step_section in parts[1:]:
                    step_lines = step_section.split('\n')

                    step_desc = extract_field(step_lines, 'Step Description:')
                    step_type = extract_field(step_lines, 'Step Type:')

                    # Default to step-by-step if no type specified
                    if not step_type:
                        step_type = "step-by-step"
                    else:
                        step_type = step_type.strip().lower()

                    # Parse step description
                    step_desc_blocks = parse_mixed_content(step_desc) if step_desc else []

                    # Initialize step data with common fields
                    step_data = {
                        "step_type": step_type,
                        "description": step_desc_blocks
                    }

                    # ‚úÖ Parse "Must Be Correct" field (common to all assessment types)
                    must_be_correct_str = extract_field(step_lines, 'Must Be Correct:')
                    must_be_correct = None
                    if must_be_correct_str:
                        must_be_correct = must_be_correct_str.strip().lower() == 'true'

                    # ========================================
                    # STEP-BY-STEP (Expression & Answer)
                    # ========================================
                    if step_type == "step-by-step":
                        step_expr = extract_field(step_lines, 'Step Expression:')
                        step_expected = extract_field(step_lines, 'Step Expected:')

                        if not step_expr:
                            continue

                        # Handle expression (keep asciimath format or convert)
                        if step_expr and step_expr.startswith('`') and step_expr.endswith('`'):
                            step_expr_final = step_expr  # Keep as asciimath
                            window.console.log(f"üìå Keeping expression as asciimath: {step_expr}")
                        else:
                            step_expr_final = convert_math_to_latex(step_expr)
                            window.console.log(f"üìå Converted expression to LaTeX: {step_expr_final}")

                        # Handle expected answer
                        expected_structure = None
                        step_expected_final = None

                        if step_expected:
                            if step_expected.startswith('`') and step_expected.endswith('`'):
                                step_expected_final = step_expected  # Keep as asciimath
                                window.console.log(f"üìå Keeping expected as asciimath: {step_expected}")

                                # Still compute expected_structure by temporarily converting to LaTeX
                                try:
                                    temp_latex = convert_math_to_latex(step_expected)
                                    # Only parse if conversion succeeded (not still in backticks)
                                    if not (temp_latex.startswith('`') and temp_latex.endswith('`')):
                                        parsed = self.problem_creator.math_parser.parse_latex(temp_latex)
                                        if parsed is not None:
                                            expected_structure = self.problem_creator.math_parser.extract_structure(parsed)
                                            window.console.log(f"‚úÖ Computed expected_structure from asciimath")
                                    else:
                                        window.console.log(f"‚ö†Ô∏è Skipping structure computation, parser not available")
                                except Exception as e:
                                    window.console.warn(f"Could not parse expected answer: {e}")
                            else:
                                step_expected_final = convert_math_to_latex(step_expected)
                                window.console.log(f"üìå Converted expected to LaTeX: {step_expected_final}")

                                try:
                                    # Only parse if not in backtick format
                                    if not (step_expected_final.startswith('`') and step_expected_final.endswith('`')):
                                        parsed = self.problem_creator.math_parser.parse_latex(step_expected_final)
                                        if parsed is not None:
                                            expected_structure = self.problem_creator.math_parser.extract_structure(parsed)
                                            window.console.log(f"‚úÖ Computed expected_structure from LaTeX")
                                    else:
                                        window.console.log(f"‚ö†Ô∏è Skipping structure computation, parser not available")
                                except Exception as e:
                                    window.console.warn(f"Could not parse expected answer: {e}")

                        step_data.update({
                            "expression": step_expr_final,
                            "expected": step_expected_final,
                            "expected_structure": expected_structure
                        })

                    # ========================================
                    # MULTIPLE CHOICE (SINGLE)
                    # ========================================
                    elif step_type == "multiple-choice-single":
                        options = extract_options(step_lines)
                        correct_answer = extract_field(step_lines, 'Correct Answer:')

                        if not options:
                            window.console.warn(f"No options found for MC single question")
                            continue

                        step_data.update({
                            "options": options,
                            "correct_answer": correct_answer.strip() if correct_answer else ""
                        })

                        if must_be_correct is not None:
                            step_data["requireCorrect"] = must_be_correct

                    # ========================================
                    # MULTIPLE CHOICE (MULTIPLE)
                    # ========================================
                    elif step_type == "multiple-choice-multiple":
                        options = extract_options(step_lines)
                        correct_answer_str = extract_field(step_lines, 'Correct Answer:')

                        if not options:
                            window.console.warn(f"No options found for MC multiple question")
                            continue

                        # Parse comma-separated correct answers
                        correct_answers = []
                        if correct_answer_str:
                            # Split by comma and clean up
                            answers = [a.strip() for a in correct_answer_str.split(',')]
                            correct_answers = [a for a in answers if a]

                        step_data.update({
                            "options": options,
                            "correct_answers": correct_answers
                        })

                        if must_be_correct is not None:
                            step_data["requireCorrect"] = must_be_correct

                    # ========================================
                    # TRUE/FALSE
                    # ========================================
                    elif step_type == "true-false":
                        correct_answer_str = extract_field(step_lines, 'Correct Answer:')
                        explanation = extract_field(step_lines, 'Explanation:')

                        correct_answer = None
                        if correct_answer_str:
                            answer_lower = correct_answer_str.strip().lower()
                            if answer_lower == 'true':
                                correct_answer = True
                            elif answer_lower == 'false':
                                correct_answer = False

                        step_data["correct_answer"] = correct_answer

                        # Optional explanation field (not used in current implementation but stored)
                        if explanation:
                            step_data["explanation"] = explanation

                        if must_be_correct is not None:
                            step_data["requireCorrect"] = must_be_correct

                    # ========================================
                    # FILL IN THE BLANK
                    # ========================================
                    elif step_type == "fill-blank":
                        answer_type = extract_field(step_lines, 'Answer Type:')
                        correct_answer = extract_field(step_lines, 'Correct Answer:')

                        # Default to math if not specified
                        if not answer_type:
                            answer_type = "math"
                        else:
                            answer_type = answer_type.strip().lower()

                        # Collect all alternative answers
                        correct_answers = []

                        if correct_answer:
                            # Handle math vs text
                            if answer_type == "math":
                                # Keep backticks for math answers or convert
                                value = convert_math_to_latex(correct_answer)
                                correct_answers.append({"value": value, "display": value})
                            else:
                                # Text answer
                                correct_answers.append({"value": correct_answer.strip(), "display": correct_answer.strip()})

                        # Check for alternative answers
                        alt_answer = extract_field(step_lines, 'Alternative Answer:')
                        if alt_answer:
                            if answer_type == "math":
                                value = convert_math_to_latex(alt_answer)
                                correct_answers.append({"value": value, "display": value})
                            else:
                                correct_answers.append({"value": alt_answer.strip(), "display": alt_answer.strip()})

                        step_data.update({
                            "blank_config": {
                                "content_type": answer_type,
                                "position": "end"
                            },
                            "correct_answers": correct_answers
                        })

                        if must_be_correct is not None:
                            step_data["requireCorrect"] = must_be_correct

                    # ========================================
                    # UNKNOWN STEP TYPE
                    # ========================================
                    else:
                        window.console.warn(f"Unknown step type: {step_type}, skipping")
                        continue

                    steps.append(step_data)

                problem_data = {
                    "title": title or "Untitled Problem",
                    "description": description_blocks,
                    "steps": steps
                }

                problems.append(problem_data)

            return {
                "problems": problems,
                "problem_set_description": "",
                "problem_set_id": ""
            }

        except Exception as e:
            window.console.error(f"Text format parsing error: {e}")
            import traceback
            tb = traceback.format_exc()
            window.console.error(tb)

            # Provide more helpful error message
            if "split" in str(e) or "index" in str(e):
                raise Exception(
                    "Failed to parse text format: Invalid structure detected. "
                    "Please ensure problems are separated by ### and steps by #"
                )
            elif "KeyError" in str(e) or "get" in str(e):
                raise Exception(
                    "Failed to parse text format: Missing required field. "
                    "Each problem needs: Problem Title, Problem Description. "
                    "Each step needs appropriate fields based on step type."
                )
            else:
                raise Exception(f"Failed to parse text format: {e}")
    def _import_problem_data(self, data):
        if isinstance(data, dict) and "problems" in data:
            problems = data["problems"]
            description = data.get("problem_set_description", "")
            uuid_str = data.get("problem_set_id", "")
        else:
            window.alert("Invalid problem data format")
            return

        # Store import data for the dialog
        window._import_data = {
            'problems': problems,
            'description': description,
            'uuid': uuid_str
        }

        # Check if there are existing problems
        if len(self.problem_creator.problems) > 0:
            # Show choice dialog
            self._show_import_choice_dialog()
        else:
            # No existing problems, import directly
            self._execute_import_choice('replace')

    def _show_import_choice_dialog(self):
        """Show dialog for import choice"""
        current_count = len(self.problem_creator.problems)
        js_code = f"""
        (function(){{
            let existing = document.querySelector('#importChoiceDialog');
            if(existing) existing.remove();
            
            let overlay = document.createElement('div');
            overlay.id = 'importChoiceDialog';
            overlay.style.cssText = `
                position: fixed; top: 0; left: 0; right: 0; bottom: 0;
                background: rgba(0, 0, 0, 0.7); z-index: 10000;
                display: flex; align-items: center; justify-content: center;
            `;
            
            let dialog = document.createElement('div');
            dialog.style.cssText = `
                background: #ffffff; border-radius: 12px; padding: 32px;
                max-width: 500px; width: 90%; box-shadow: 0 25px 50px rgba(0, 0, 0, 0.4);
                text-align: center; font-family: Inter, system-ui, Arial;
            `;
            
            dialog.innerHTML = `
                <h2 style="margin: 0 0 20px 0; color: #0f172a; font-size: 24px; font-weight: 700;">
                    üì• Import Problem Set
                </h2>
                <p style="margin: 0 0 16px 0; color: #374151; font-size: 16px;">
                    You have <strong>{current_count} existing problem(s)</strong> in your current set.
                </p>
                <p style="margin: 0 0 32px 0; color: #6b7280; font-size: 14px;">
                    How would you like to handle the imported problems?
                </p>
                <div style="display: flex; gap: 16px; justify-content: center; flex-wrap: wrap;">
                    <button id="replaceBtn" style="
                        padding: 16px 24px; border: none; border-radius: 8px;
                        background: #dc2626; color: white; font-weight: 600;
                        cursor: pointer; transition: all 0.2s; min-width: 140px;
                        text-align: center; line-height: 1.3;
                    ">üîÑ Replace<br><small>Clear current and import new</small></button>
                    <button id="mergeBtn" style="
                        padding: 16px 24px; border: none; border-radius: 8px;
                        background: #0b6efd; color: white; font-weight: 600;
                        cursor: pointer; transition: all 0.2s; min-width: 140px;
                        text-align: center; line-height: 1.3;
                    ">‚ûï Merge<br><small>Add to existing problems</small></button>
                    <button id="cancelBtn" style="
                        padding: 16px 24px; border: 2px solid #d1d5db; border-radius: 8px;
                        background: white; color: #374151; font-weight: 600;
                        cursor: pointer; transition: all 0.2s; min-width: 140px;
                        text-align: center; line-height: 1.3;
                    ">‚úñ Cancel<br><small>Don't import</small></button>
                </div>
            `;
            
            overlay.appendChild(dialog);
            document.body.appendChild(overlay);
            
            // Event handlers
            dialog.querySelector('#replaceBtn').onclick = () => {{
                overlay.remove();
                window.problem_creator.data_manager._execute_import_choice('replace');
            }};
            dialog.querySelector('#mergeBtn').onclick = () => {{
                overlay.remove();
                window.problem_creator.data_manager._execute_import_choice('merge');
            }};
            dialog.querySelector('#cancelBtn').onclick = () => {{
                overlay.remove();
                delete window._import_data;
            }};
        }})();
        """
        window.eval(js_code)

    def _execute_import_choice(self, choice):
        """Execute the import based on user choice"""
        if not hasattr(window, '_import_data'):
            window.alert("‚ùå No import data found.")
            return
        
        import_data = window._import_data
        problems = import_data['problems']
        description = import_data['description']
        uuid_str = import_data['uuid']
        
        if choice == 'replace':
            # Update metadata and clear existing problems
            desc_input = document.querySelector("#problemSetDescription")
            if desc_input:
                desc_input.value = description
            uuid_display = document.querySelector("#problemSetUuid")
            if uuid_display:
                uuid_display.textContent = uuid_str
            
            self.problem_creator.clear_all_problems()
        
        # Add problems (for both replace and merge)
        for prob in problems:
            self.problem_creator.add_problem(skip_initial_steps=True)  # ‚úÖ NEW: Skip initial steps when importing
            self.problem_creator.problems[-1].load_data(prob)

        self.save_to_storage()
        
        if choice == 'replace':
            window.alert("‚úÖ Problem set replaced successfully!")
        else:
            window.alert(f"‚úÖ Problems merged! Added {len(problems)} problem(s) to existing set.")
        
        # Cleanup
        del window._import_data
        
    # -----------------------------------------------------
    # ‚úÖ Popup
    # -----------------------------------------------------
    def _show_popup(self, title, message):
        safe_title = title.replace("`", "'").replace("\\", "\\\\")
        safe_message = message.replace("`", "'").replace("\\", "\\\\").replace("\n", "\\n")
        js_code = f"""
        (function(){{
            let old = document.querySelector('#exportPopup');
            if(old) old.remove();
            let popup = document.createElement('div');
            popup.id = 'exportPopup';
            popup.style.cssText = `
                position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);
                background:#f8fafc;color:#0f172a;
                border:2px solid #f59e0b;border-radius:12px;
                padding:24px;max-width:480px;white-space:pre-wrap;
                box-shadow:0 10px 30px rgba(0,0,0,0.2);z-index:9999;
            `;
            let btn = document.createElement('button');
            btn.textContent='‚úñ';btn.style.cssText=`
                position:absolute;top:8px;right:10px;
                border:none;background:transparent;color:#f59e0b;
                font-size:18px;font-weight:bold;cursor:pointer;
            `;
            btn.onclick=()=>popup.remove();
            let h=document.createElement('h3');
            h.textContent='{safe_title}';
            h.style.cssText='margin:0 0 10px 0;color:#0f172a;font-weight:700;';
            let p=document.createElement('div');
            p.textContent='{safe_message}';
            p.style.cssText='font-family:monospace;font-size:13px;white-space:pre-wrap;';
            popup.appendChild(btn);popup.appendChild(h);popup.appendChild(p);
            document.body.appendChild(popup);
        }})();
        """
        window.eval(js_code)

class ProblemCreator:
    """Main application class"""
    
    def __init__(self):
        self.problems = []
        self.math_parser = MathParser()
        self.data_manager = DataManager(self)
        self._init()
    
    def _init(self):
      """Initialize the application"""
      self.update_status("‚è≥ Wiring UI...")
      ensure_mq()

      # Wire up main button (only this one exists)
      document.querySelector("#addProblemBtn").addEventListener(
          "click", create_proxy(lambda e: self.add_problem())
      )

      # ‚úÖ REMOVED: Import, Export, Download, and Clear buttons
      # These are now handled by the toolbar via window.toolbarActions

      # Wire up UUID copy button
      copy_btn = document.querySelector("#copyUuidBtn")
      if copy_btn:
          copy_btn.addEventListener(
              "click", create_proxy(self._copy_uuid)
          )

      # ‚úÖ NEW: Wire up Problem Set Description for autosave
      desc_input = document.querySelector("#problemSetDescription")
      if desc_input:
          def on_desc_change(e):
              if hasattr(window, 'problem_creator'):
                  window.problem_creator.data_manager.save_to_storage()
          desc_input.addEventListener("input", create_proxy(on_desc_change))

      self.update_status("‚úì Ready!")

      # Wire up UUID copy button
      copy_btn = document.querySelector("#copyUuidBtn")
      if copy_btn:
          copy_btn.addEventListener(
              "click", create_proxy(self._copy_uuid)
          )

      self.update_status("‚úì Ready!")

      # ‚úÖ CRITICAL FIX: Delay autosave restoration to allow libraries to load
      def delayed_restore():
            """Restore autosave after libraries are ready"""
            window.console.log("üîç Checking for autosaved data...")
            saved = self.data_manager.load_from_storage()
            if saved:
                window.console.log(f"üíæ Found autosaved data with {len(saved)} problem(s)")
                if window.confirm("üíæ Restore autosaved problems?"):
                    window.console.log("‚úì User confirmed restoration")
                    self._restore_saved_problems(saved)
                else:
                    window.console.log("‚úó User declined restoration")
                    # Add initial problem if user declined
                    if len(self.problems) == 0:
                        window.setTimeout(create_proxy(lambda: self.add_problem()), 200)
            else:
                window.console.log("‚ÑπÔ∏è No autosaved data found")
                # Add initial problem if none exist
                if len(self.problems) == 0:
                    window.setTimeout(create_proxy(lambda: self.add_problem()), 200)

      # Delay restoration to ensure Quill and MathQuill are ready
      window.setTimeout(create_proxy(delayed_restore), 800)

      # Hide loading overlay after everything is ready
      window.setTimeout(create_proxy(hide_loading), 1200)

    def update_status(self, msg):
        """Update loading status"""
        self.math_parser.update_status(msg)
    
    def add_problem(self, skip_initial_steps=False):
        """Add a new problem"""
        container = document.querySelector("#problemsContainer")
        problem_index = len(self.problems) + 1
        problem = Problem(container, problem_index, self.math_parser, skip_initial_steps=skip_initial_steps)
        self.problems.append(problem)
        # ‚úÖ Only autosave if not restoring
        if not self.data_manager.is_restoring:
            self.data_manager.save_to_storage()
    
    def clear_all_problems(self):
        """Clear all existing problems"""
        container = document.querySelector("#problemsContainer")
        container.innerHTML = ""
        self.problems = []
    
    def _restore_saved_problems(self, saved):
        """Restore problems from saved data with improved timing and autosave control"""
        # ‚úÖ CRITICAL: Disable autosave during restoration
        self.data_manager.is_restoring = True

        try:
            window.console.log(f"üîÑ Starting to restore {len(saved)} problem(s)")
            window.console.log("‚è∏Ô∏è Autosave disabled during restoration")

            if not isinstance(saved, list):
                window.console.error(f"‚ùå Expected list, got {type(saved)}")
                self.data_manager.is_restoring = False
                return

            # Clear any existing problems first
            self.clear_all_problems()

            # Store reference for closures
            creator_ref = self

            # Load problems sequentially with proper delays
            def load_problem_at_index(index):
                if index >= len(saved):
                    window.console.log(f"‚úÖ‚úÖ‚úÖ All {len(saved)} problem(s) restored successfully")

                    # ‚úÖ CRITICAL: Re-enable autosave after restoration complete
                    def finish_restoration():
                        creator_ref.data_manager.is_restoring = False
                        creator_ref.data_manager.restore_complete = True
                        window.console.log("‚ñ∂Ô∏è Autosave re-enabled after restoration")
                        # Trigger one final save with complete data
                        creator_ref.data_manager.save_to_storage()

                    window.setTimeout(create_proxy(finish_restoration), 1000)
                    return

                prob_data = saved[index]
                window.console.log(f"üìù Restoring problem {index + 1}/{len(saved)}")

                # Create empty problem
                creator_ref.add_problem(skip_initial_steps=True)  # ‚úÖ NEW: Skip initial steps when restoring

                # Get the problem we just added
                if len(creator_ref.problems) > 0:
                    last_problem = creator_ref.problems[-1]

                    # Wait for problem UI to be ready before loading data
                    def wait_and_load(attempt=0):
                        max_attempts = 20

                        # Check if problem's description editor is ready
                        is_ready = (
                            hasattr(last_problem, 'description_editor_id') and
                            last_problem.description_editor_id is not None and
                            hasattr(last_problem, 'steps_container') and
                            last_problem.steps_container is not None
                        )

                        if is_ready:
                            window.console.log(f"‚úì Problem {index + 1} UI ready, loading data...")
                            try:
                                last_problem.load_data(prob_data)
                                window.console.log(f"‚úÖ Problem {index + 1} data loaded")
                            except Exception as e:
                                window.console.error(f"‚ùå Problem {index + 1} load error: {e}")
                                import traceback
                                window.console.error(traceback.format_exc())

                            # Schedule next problem
                            next_index = index + 1
                            window.setTimeout(
                                create_proxy(lambda idx=next_index: load_problem_at_index(idx)),
                                500  # Delay between problems
                            )
                        elif attempt < max_attempts:
                            window.console.log(f"‚è≥ Problem {index + 1} - waiting for UI (attempt {attempt + 1}/{max_attempts})")
                            window.setTimeout(
                                create_proxy(lambda: wait_and_load(attempt + 1)),
                                100
                            )
                        else:
                            window.console.error(f"‚ùå Problem {index + 1} - UI never ready, skipping")
                            # Move to next problem anyway
                            next_index = index + 1
                            window.setTimeout(
                                create_proxy(lambda idx=next_index: load_problem_at_index(idx)),
                                200
                            )

                    # Start waiting for this problem's UI
                    window.setTimeout(create_proxy(lambda: wait_and_load(0)), 300)
                else:
                    window.console.error(f"‚ùå Failed to add problem {index + 1}")
                    # Try next problem
                    next_index = index + 1
                    window.setTimeout(
                        create_proxy(lambda idx=next_index: load_problem_at_index(idx)),
                        200
                    )

            # Start loading first problem
            window.setTimeout(create_proxy(lambda: load_problem_at_index(0)), 500)

        except Exception as e:
            window.console.error(f"‚ùå Failed to restore saved problems: {e}")
            import traceback
            window.console.error(traceback.format_exc())
            # Re-enable autosave even if restoration failed
            self.data_manager.is_restoring = False
    
    def _copy_uuid(self, e):
        """Copy problem set UUID to clipboard"""
        uuid_display = document.querySelector("#problemSetUuid")
        if uuid_display and uuid_display.textContent != "No problem set loaded":
            try:
                window.navigator.clipboard.writeText(uuid_display.textContent)
                window.alert("üìã UUID copied to clipboard!")
            except:
                window.alert("Failed to copy UUID")


# ============================================================================
# HELPER FUNCTIONS
# ============================================================================

def update_status(msg):
    """Update loading status (global function for initialization)"""
    container = document.querySelector("#loadingStatus")
    if container:
        div = document.createElement("div")
        div.appendChild(document.createTextNode(msg))
        container.appendChild(div)

def ensure_mq():
    """Ensure MathQuill is loaded"""
    global MQ
    if MQ is None:
        if hasattr(window, 'MathQuill') and window.MathQuill:
            MQ = window.MathQuill.getInterface(2)
        else:
            window.setTimeout(create_proxy(ensure_mq), 600)
            return False
    return True

def create_math_field(el):
    """Create a MathQuill math field"""
    ensure_mq()
    try:
        mf = MQ.MathField(el, {"spaceBehavesLikeTab": True})
        el.setAttribute("data-mq", "1")
        return mf
    except:
        return None

def init_quill_blots():
    """Initialize custom Quill blots for MathQuill (called once)"""
    js_code = """
    (function() {
        if (!window.Quill) {
            console.error('Quill not loaded');
            return;
        }
        
        //const Inline = Quill.import('blots/inline');
        const Embed = Quill.import('blots/embed');
        
        class MathQuillBlot extends Embed {
            static create(value) {
                let node = super.create();
                node.setAttribute('contenteditable', 'false');
                node.className = 'math-block-wrapper';
                
                let span = document.createElement('span');
                span.className = 'math-inline';
                node.appendChild(span);
                
                // Initialize MathQuill
                setTimeout(() => {
                    if (window.MQ) {
                        const mf = window.MQ.MathField(span, {spaceBehavesLikeTab: true});
                        if (value && value.latex) {
                            mf.latex(value.latex);
                        }
                        span.setAttribute('data-mq', '1');
                        
                        // Auto-save on change
                        mf.config({
                            handlers: {
                                edit: function() {
                                    if (window.problem_creator) {
                                        window.problem_creator.data_manager.save_to_storage();
                                    }
                                }
                            }
                        });
                    }
                }, 50);
                
                return node;
            }
            
                    static value(node) {
                        const text = node.getAttribute('data-math') || '';
                        const mode = node.getAttribute('data-mode') || 'latex';
                        console.log('MathStringBlot.value() called:', { text, mode });
                        return {
                            text: text,
                            mode: mode
                        };
                    }
        }
        
        MathQuillBlot.blotName = 'mathquill';
        MathQuillBlot.tagName = 'span';
        MathQuillBlot.className = 'math-block-wrapper';
        
        Quill.register(MathQuillBlot);
        console.log('‚úì Quill MathQuill blot registered');
    })();
    """
    window.eval(js_code)

def create_quill_editor(editor_id, placeholder="Type here..."):
    """Create a Quill editor instance"""
    js_code = f"""
    (function() {{
        try {{
            console.log('üîß Starting Quill initialization for:', '{editor_id}');
            
            const container = document.getElementById('{editor_id}');
            if (!container) {{
                console.error('‚ùå Container not found:', '{editor_id}');
                return;
            }}
            
            console.log('‚úì Container found:', container);
            
            // Check if Quill is available
            if (!window.Quill) {{
                console.error('‚ùå Quill is not loaded!');
                return;
            }}
            
            console.log('‚úì Quill is available');
            
            // ========================================
            // Ensure MathQuill is ready
            // ========================================
            if (!window.MQ) {{
                if (window.MathQuill) {{
                    window.MQ = window.MathQuill.getInterface(2);
                    console.log('‚úì MathQuill interface initialized');
                }} else {{
                    console.error('‚ùå MathQuill not available');
                }}
            }}
            
            // ========================================
            // Register Math String Blot (FIXED - using Embed base)
            // ========================================
            if (!window.MathStringBlotFixed) {{
                const Embed = window.Quill.import('blots/embed');
                
                class MathStringBlot extends Embed {{
                    static create(value) {{
                        console.log('‚ú® MathStringBlot.create() called with:', value);
                        
                        const node = super.create();
                        
                        // Store data in attributes
                        node.setAttribute('data-math', value.text || '');
                        node.setAttribute('data-mode', value.mode || 'latex');
                        node.setAttribute('contenteditable', 'false');
                        
                        // Set display text
                        node.textContent = value.text || '';
                        
                        // Apply styling
                        node.className = 'math-string-inline';
                        node.style.cssText = `
                            background: #e0f2fe;
                            color: #0369a1;
                            padding: 2px 6px;
                            border-radius: 4px;
                            font-family: 'Courier New', monospace;
                            font-size: 0.95em;
                            cursor: pointer;
                            border: 1px solid #bae6fd;
                            display: inline-block;
                            margin: 0 2px;
                        `;
                        
                        console.log('‚úÖ MathStringBlot node created');
                        
                        // Add hover preview
                        node.addEventListener('mouseenter', function(e) {{
                            console.log('üéØ Mouse entered mathstring blot');
                            
                            if (node.previewTimeout) clearTimeout(node.previewTimeout);
                            
                            node.previewTimeout = setTimeout(() => {{
                                // Remove any existing preview
                                const existingPreview = document.querySelector('.math-hover-preview');
                                if (existingPreview) existingPreview.remove();
                                
                                // Create preview element
                                const preview = document.createElement('div');
                                preview.className = 'math-hover-preview';
                                preview.style.cssText = `
                                    position: fixed;
                                    background: white;
                                    border: 2px solid #0369a1;
                                    border-radius: 8px;
                                    padding: 16px 20px;
                                    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
                                    z-index: 10000;
                                    min-width: 120px;
                                    max-width: 500px;
                                    font-size: 20px;
                                    pointer-events: none;
                                `;
                                
                                const mathText = node.getAttribute('data-math');
                                const mode = node.getAttribute('data-mode');
                                
                                // Create preview content
                                const previewContent = document.createElement('div');
                                previewContent.className = 'tex2jax_process';
                                
                                if (mode === 'latex') {{
                                    previewContent.textContent = '\\\\(' + mathText + '\\\\)';
                                }} else {{
                                    previewContent.textContent = '`' + mathText + '`';
                                }}
                                
                                preview.appendChild(previewContent);
                                document.body.appendChild(preview);
                                
                                // Position the preview
                                const rect = node.getBoundingClientRect();
                                preview.style.left = rect.left + 'px';
                                preview.style.top = (rect.bottom + 8) + 'px';
                                
                                // Adjust if preview goes off-screen
                                setTimeout(() => {{
                                    const previewRect = preview.getBoundingClientRect();
                                    if (previewRect.right > window.innerWidth) {{
                                        preview.style.left = (window.innerWidth - previewRect.width - 10) + 'px';
                                    }}
                                    if (previewRect.bottom > window.innerHeight) {{
                                        preview.style.top = (rect.top - previewRect.height - 8) + 'px';
                                    }}
                                }}, 10);
                                
                                // Render with MathJax
                                if (window.MathJax && window.MathJax.typesetPromise) {{
                                    window.MathJax.typesetPromise([preview]).catch(err => {{
                                        console.error('MathJax error:', err);
                                    }});
                                }}
                                
                                node.currentPreview = preview;
                            }}, 200);
                        }});
                        
                        node.addEventListener('mouseleave', function(e) {{
                            if (node.previewTimeout) clearTimeout(node.previewTimeout);
                            if (node.currentPreview) {{
                                node.currentPreview.remove();
                                node.currentPreview = null;
                            }}
                        }});
                        
                        // Add double-click to edit
                        node.addEventListener('dblclick', function(e) {{
                            e.preventDefault();
                            e.stopPropagation();
                            
                            if (node.currentPreview) {{
                                node.currentPreview.remove();
                                node.currentPreview = null;
                            }}
                            
                            const mathText = node.getAttribute('data-math');
                            const mode = node.getAttribute('data-mode');
                            
                            // Find Quill instance
                            let quillInstance = null;
                            let currentNode = node;
                            while (currentNode && !quillInstance) {{
                                if (currentNode.classList && currentNode.classList.contains('ql-editor')) {{
                                    for (let editorId in window.quillEditors) {{
                                        if (window.quillEditors[editorId].root === currentNode) {{
                                            quillInstance = window.quillEditors[editorId];
                                            break;
                                        }}
                                    }}
                                    break;
                                }}
                                currentNode = currentNode.parentNode;
                            }}
                            
                            if (!quillInstance) {{
                                console.error('Could not find Quill instance');
                                return;
                            }}
                            
                            const blotToUpdate = node;
                            
                            if (window.showMathTextEditDialog) {{
                                window.showMathTextEditDialog(quillInstance, mode, mathText, function(newMathText) {{
                                    if (newMathText && newMathText.trim()) {{
                                        const blot = window.Quill.find(blotToUpdate);
                                        if (blot) {{
                                            const index = quillInstance.getIndex(blot);
                                            const length = blot.length();
                                            
                                            quillInstance.deleteText(index, length, window.Quill.sources.USER);
                                            quillInstance.insertEmbed(index, 'mathstring', {{
                                                text: newMathText,
                                                mode: mode
                                            }}, window.Quill.sources.USER);
                                            
                                            quillInstance.setSelection(index + 1, window.Quill.sources.SILENT);
                                            console.log('‚úì Math string updated');
                                        }}
                                    }} else if (newMathText === '') {{
                                        const blot = window.Quill.find(blotToUpdate);
                                        if (blot) {{
                                            const index = quillInstance.getIndex(blot);
                                            const length = blot.length();
                                            quillInstance.deleteText(index, length, window.Quill.sources.USER);
                                            console.log('‚úì Math string deleted');
                                        }}
                                    }}
                                }});
                            }}
                        }});
                        
                        return node;
                    }}
                    
                    static value(node) {{
                        const value = {{
                            text: node.getAttribute('data-math') || '',
                            mode: node.getAttribute('data-mode') || 'latex'
                        }};
                        console.log('üì§ MathStringBlot.value() returning:', value);
                        return value;
                    }}
                }}
                
                MathStringBlot.blotName = 'mathstring';
                MathStringBlot.tagName = 'span';
                MathStringBlot.className = 'math-string-inline';
                
                window.Quill.register(MathStringBlot);
                window.MathStringBlotFixed = true;
                console.log('‚úÖ MathString blot registered as Embed');
            }}
               
            
            // ========================================
            // Create Quill Instance
            // ========================================
            const quill = new window.Quill(container, {{
                theme: 'snow',
                placeholder: '{placeholder}',
                modules: {{
                    toolbar: [
                        [{{ 'header': [1, 2, 3, false] }}],
                        ['bold', 'italic', 'underline', 'strike'],
                        [{{ 'list': 'ordered' }}, {{ 'list': 'bullet' }}],
                        [{{ 'script': 'sub' }}, {{ 'script': 'super' }}],
                        [{{ 'color': [] }}, {{ 'background': [] }}],
                        ['link'],
                        ['clean']
                    ]
                }}
            }});
            
            // Store globally
            if (!window.quillEditors) {{
                window.quillEditors = {{}};
            }}
            window.quillEditors['{editor_id}'] = quill;
            
            console.log('‚úì Quill instance created for:', '{editor_id}');
            
            // ========================================
            // Show MathQuill Visual Editor Dialog (for ∆í(x) button)
            // ========================================
            if (!window.showMathQuillDialog) {{
                window.showMathQuillDialog = function(quillInstance, initialLatex = '') {{
                    const overlay = document.createElement('div');
                    overlay.style.cssText = `
                        position: fixed;
                        top: 0;
                        left: 0;
                        right: 0;
                        bottom: 0;
                        background: rgba(0, 0, 0, 0.5);
                        z-index: 10000;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                    `;
                    
                    const popup = document.createElement('div');
                    popup.style.cssText = `
                        background: white;
                        padding: 24px;
                        border-radius: 12px;
                        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
                        max-width: 600px;
                        width: 90%;
                    `;
                    
                    popup.innerHTML = `
                        <h3 style="margin: 0 0 16px 0; color: #0f172a;">Insert Math Expression</h3>
                        <div style="margin-bottom: 16px;">
                            <label style="display: block; font-weight: 600; margin-bottom: 6px;">Expression Editor:</label>
                            <div id="mathQuillInput" style="
                                border: 2px solid #e6eef8;
                                border-radius: 8px;
                                padding: 16px;
                                min-height: 60px;
                                font-size: 20px;
                                background: white;
                            "></div>
                            <div style="font-size: 12px; color: #64748b; margin-top: 8px;">
                                Type your math expression. Use ^ for superscript, _ for subscript, / for fractions.
                            </div>
                        </div>
                        <div style="margin-bottom: 16px;">
                            <label style="display: block; font-weight: 600; margin-bottom: 6px;">Preview:</label>
                            <div id="mathQuillPreview" style="
                                border: 1px solid #e2e8f0;
                                border-radius: 8px;
                                padding: 16px;
                                min-height: 60px;
                                background: #f8fafc;
                                font-size: 20px;
                            "></div>
                        </div>
                        <div style="display: flex; gap: 8px; justify-content: flex-end;">
                            <button id="mathQuillCancelBtn" style="
                                padding: 8px 16px;
                                border: 1px solid #dbe9ff;
                                background: white;
                                color: #0b6efd;
                                border-radius: 8px;
                                cursor: pointer;
                                font-size: 14px;
                                font-weight: 500;
                            ">Cancel</button>
                            <button id="mathQuillInsertBtn" style="
                                padding: 8px 16px;
                                border: none;
                                background: #0b6efd;
                                color: white;
                                border-radius: 8px;
                                cursor: pointer;
                                font-size: 14px;
                                font-weight: 500;
                            ">Insert</button>
                        </div>
                    `;
                    
                    overlay.appendChild(popup);
                    document.body.appendChild(overlay);
                    
                    // Initialize MathQuill editor
                    const inputDiv = document.getElementById('mathQuillInput');
                    const previewDiv = document.getElementById('mathQuillPreview');
                    
                    if (!window.MQ) {{
                        console.error('‚ùå MathQuill (MQ) not available');
                        alert('MathQuill is not loaded. Please refresh the page.');
                        overlay.remove();
                        return;
                    }}
                    
                    const mathField = window.MQ.MathField(inputDiv, {{
                        spaceBehavesLikeTab: true,
                        leftRightIntoCmdGoes: 'up',
                        restrictMismatchedBrackets: true,
                        handlers: {{
                            edit: function() {{
                                const latex = mathField.latex();
                                // Update preview
                                if (previewDiv) {{
                                    previewDiv.textContent = '';
                                    const previewMQ = window.MQ.StaticMath(previewDiv);
                                    previewMQ.latex(latex);
                                }}
                            }}
                        }}
                    }});
                    
                    // Set initial value if provided
                    if (initialLatex) {{
                        mathField.latex(initialLatex);
                        const previewMQ = window.MQ.StaticMath(previewDiv);
                        previewMQ.latex(initialLatex);
                    }}
                    
                    // Focus the editor
                    setTimeout(() => mathField.focus(), 100);
                    
                    // Insert button
                    document.getElementById('mathQuillInsertBtn').onclick = function() {{
                        const latex = mathField.latex().trim();
                        if (latex) {{
                            const range = quillInstance.getSelection(true);
                            if (range) {{
                                console.log('üìù Inserting MathQuill with latex:', latex);
                                quillInstance.insertEmbed(range.index, 'mathquill', {{ latex: latex }}, window.Quill.sources.USER);
                                quillInstance.insertText(range.index + 1, ' ', window.Quill.sources.USER);
                                quillInstance.setSelection(range.index + 2, window.Quill.sources.SILENT);
                                console.log('‚úì MathQuill inserted successfully');
                            }}
                            overlay.remove();
                        }} else {{
                            alert('Please enter a math expression');
                        }}
                    }};
                    
                    // Cancel button
                    document.getElementById('mathQuillCancelBtn').onclick = function() {{
                        overlay.remove();
                    }};
                    
                    // Click outside to close
                    overlay.onclick = function(e) {{
                        if (e.target === overlay) overlay.remove();
                    }};
                    
                    // ESC key to close
                    const escHandler = function(e) {{
                        if (e.key === 'Escape') {{
                            overlay.remove();
                            document.removeEventListener('keydown', escHandler);
                        }}
                    }};
                    document.addEventListener('keydown', escHandler);
                }};
            }}
            
            // ========================================
            // Show text input dialog with MathJax preview (for LaTeX/AsciiMath buttons)
            // ========================================
            if (!window.showMathTextDialog) {{
                window.showMathTextDialog = function(quillInstance, mode) {{
                    const overlay = document.createElement('div');
                    overlay.style.cssText = `
                        position: fixed;
                        top: 0;
                        left: 0;
                        right: 0;
                        bottom: 0;
                        background: rgba(0, 0, 0, 0.5);
                        z-index: 10000;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                    `;
                    
                    const popup = document.createElement('div');
                    popup.style.cssText = `
                        background: white;
                        padding: 24px;
                        border-radius: 12px;
                        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
                        max-width: 600px;
                        width: 90%;
                    `;
                    
                    const title = mode === 'latex' ? 'Insert LaTeX Math' : 'Insert AsciiMath';
                    const placeholder = mode === 'latex' ? 'x^{{2}} + y^{{2}} = r^{{2}}' : 'x^2 + y^2 = r^2';
                    const example = mode === 'latex' 
                        ? 'Examples: \\\\frac{{a}}{{b}}, \\\\sqrt{{x}}, x^{{2}}, \\\\int_{{0}}^{{\\\\infty}}' 
                        : 'Examples: a/b, sqrt(x), x^2, int_0^oo';
                    
                    popup.innerHTML = `
                        <h3 style="margin: 0 0 16px 0; color: #0f172a;">${{title}}</h3>
                        <div style="margin-bottom: 16px;">
                            <label style="display: block; font-weight: 600; margin-bottom: 6px;">Math Expression:</label>
                            <textarea id="mathTextInput" placeholder="${{placeholder}}" style="
                                width: 100%;
                                padding: 12px;
                                border: 2px solid #e6eef8;
                                border-radius: 8px;
                                font-size: 16px;
                                font-family: 'Courier New', monospace;
                                min-height: 100px;
                                resize: vertical;
                            "></textarea>
                            <div style="font-size: 12px; color: #64748b; margin-top: 6px;">
                                ${{example}}
                            </div>
                        </div>
                        <div style="margin-bottom: 16px;">
                            <label style="display: block; font-weight: 600; margin-bottom: 6px;">Preview:</label>
                            <div id="mathTextPreview" style="
                                border: 1px solid #e2e8f0;
                                border-radius: 8px;
                                padding: 16px;
                                min-height: 80px;
                                background: #f8fafc;
                                font-size: 18px;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                            ">
                                <span style="color: #94a3b8; font-style: italic;">Type above to see preview</span>
                            </div>
                        </div>
                        <div style="display: flex; gap: 8px; justify-content: flex-end;">
                            <button id="mathTextCancelBtn" style="
                                padding: 8px 16px;
                                border: 1px solid #dbe9ff;
                                background: white;
                                color: #0b6efd;
                                border-radius: 8px;
                                cursor: pointer;
                                font-size: 14px;
                                font-weight: 500;
                            ">Cancel</button>
                            <button id="mathTextInsertBtn" style="
                                padding: 8px 16px;
                                border: none;
                                background: #0b6efd;
                                color: white;
                                border-radius: 8px;
                                cursor: pointer;
                                font-size: 14px;
                                font-weight: 500;
                            ">Insert</button>
                        </div>
                    `;
                    
                    overlay.appendChild(popup);
                    document.body.appendChild(overlay);
                    
                    const input = document.getElementById('mathTextInput');
                    const preview = document.getElementById('mathTextPreview');
                    
                    
                    // Update preview as user types
                    let previewTimeout;
                    input.oninput = function() {{
                        clearTimeout(previewTimeout);
                        previewTimeout = setTimeout(() => {{
                            const text = input.value.trim();
                            if (text) {{
                                // Clear previous MathJax content
                                preview.innerHTML = '';
                                
                                // Create a wrapper with the processing class
                                const mathSpan = document.createElement('span');
                                mathSpan.className = 'tex2jax_process';
                                
                                // Add the math content based on mode
                                if (mode === 'latex') {{
                                    mathSpan.textContent = '\\\\(' + text + '\\\\)';
                                }} else {{
                                    mathSpan.textContent = '`' + text + '`';
                                }}
                                
                                preview.appendChild(mathSpan);
                                
                                // Render with MathJax
                                if (window.MathJax && window.MathJax.typesetPromise) {{
                                    console.log('Rendering preview with MathJax...');
                                    window.MathJax.typesetPromise([preview]).then(() => {{
                                        console.log('‚úì Preview rendered');
                                    }}).catch(err => {{
                                        console.error('MathJax preview error:', err);
                                        preview.innerHTML = '<span style="color: #ef4444; font-size: 14px;">Preview error: ' + err.message + '</span>';
                                    }});
                                }} else if (window.MathJax && window.MathJax.Hub) {{
                                    // MathJax 2.x fallback
                                    window.MathJax.Hub.Queue(['Typeset', window.MathJax.Hub, preview]);
                                }} else {{
                                    console.warn('MathJax not available for preview');
                                    preview.innerHTML = '<span style="color: #f59e0b; font-size: 14px;">MathJax not loaded - preview unavailable</span>';
                                }}
                            }} else {{
                                preview.innerHTML = '<span style="color: #94a3b8; font-style: italic;">Type above to see preview</span>';
                            }}
                        }}, 500);  // Increased debounce to 500ms for better performance
                    }};
                    
                    input.focus();
                    
                    // Insert button
                    document.getElementById('mathTextInsertBtn').onclick = function() {{
                        let mathString = input.value.trim();
                        if (mathString) {{
                            const range = quillInstance.getSelection(true);
                            if (range) {{
                                // Insert as custom math string blot (with hover preview)
                                quillInstance.insertEmbed(range.index, 'mathstring', {{
                                    text: mathString,
                                    mode: mode
                                }}, window.Quill.sources.USER);
                                
                                // Add space after
                                quillInstance.insertText(range.index + 1, ' ', window.Quill.sources.USER);
                                quillInstance.setSelection(range.index + 2, window.Quill.sources.SILENT);
                                
                                console.log(`‚úì Math string (${{mode}}) inserted:`, mathString);
                            }}
                            overlay.remove();
                        }} else {{
                            alert('Please enter a math expression');
                        }}
                    }};
                    
                    // Cancel button
                    document.getElementById('mathTextCancelBtn').onclick = function() {{
                        overlay.remove();
                    }};
                    
                    // Click outside to close
                    overlay.onclick = function(e) {{
                        if (e.target === overlay) overlay.remove();
                    }};
                    
                    // ESC key to close
                    const escHandler = function(e) {{
                        if (e.key === 'Escape') {{
                            overlay.remove();
                            document.removeEventListener('keydown', escHandler);
                        }}
                    }};
                    document.addEventListener('keydown', escHandler);
                }};
            }}
            
            // ========================================
            // Show edit dialog for existing math string (with callback)
            // ========================================
            if (!window.showMathTextEditDialog) {{
                window.showMathTextEditDialog = function(quillInstance, mode, initialText, updateCallback) {{
                    const overlay = document.createElement('div');
                    overlay.style.cssText = `
                        position: fixed;
                        top: 0;
                        left: 0;
                        right: 0;
                        bottom: 0;
                        background: rgba(0, 0, 0, 0.5);
                        z-index: 10000;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                    `;
                    
                    const popup = document.createElement('div');
                    popup.style.cssText = `
                        background: white;
                        padding: 24px;
                        border-radius: 12px;
                        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
                        max-width: 600px;
                        width: 90%;
                    `;
                    
                    const title = mode === 'latex' ? 'Edit LaTeX Math' : 'Edit AsciiMath';
                    const placeholder = mode === 'latex' ? 'x^{{2}} + y^{{2}} = r^{{2}}' : 'x^2 + y^2 = r^2';
                    const example = mode === 'latex' 
                        ? 'Examples: \\\\frac{{a}}{{b}}, \\\\sqrt{{x}}, x^{{2}}, \\\\int_{{0}}^{{\\\\infty}}' 
                        : 'Examples: a/b, sqrt(x), x^2, int_0^oo';
                    
                    popup.innerHTML = `
                        <h3 style="margin: 0 0 16px 0; color: #0f172a;">${{title}}</h3>
                        <div style="margin-bottom: 16px;">
                            <label style="display: block; font-weight: 600; margin-bottom: 6px;">Math Expression:</label>
                            <textarea id="mathTextEditInput" placeholder="${{placeholder}}" style="
                                width: 100%;
                                padding: 12px;
                                border: 2px solid #e6eef8;
                                border-radius: 8px;
                                font-size: 16px;
                                font-family: 'Courier New', monospace;
                                min-height: 100px;
                                resize: vertical;
                            ">${{initialText}}</textarea>
                            <div style="font-size: 12px; color: #64748b; margin-top: 6px;">
                                ${{example}}
                            </div>
                        </div>
                        <div style="margin-bottom: 16px;">
                            <label style="display: block; font-weight: 600; margin-bottom: 6px;">Preview:</label>
                            <div id="mathTextEditPreview" style="
                                border: 1px solid #e2e8f0;
                                border-radius: 8px;
                                padding: 16px;
                                min-height: 80px;
                                background: #f8fafc;
                                font-size: 18px;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                            ">
                                <span style="color: #94a3b8; font-style: italic;">Loading preview...</span>
                            </div>
                        </div>
                        <div style="display: flex; gap: 8px; justify-content: space-between;">
                            <button id="mathTextDeleteBtn" style="
                                padding: 8px 16px;
                                border: 1px solid #dc2626;
                                background: white;
                                color: #dc2626;
                                border-radius: 8px;
                                cursor: pointer;
                                font-size: 14px;
                                font-weight: 500;
                            ">üóëÔ∏è Delete</button>
                            <div style="display: flex; gap: 8px;">
                                <button id="mathTextEditCancelBtn" style="
                                    padding: 8px 16px;
                                    border: 1px solid #dbe9ff;
                                    background: white;
                                    color: #0b6efd;
                                    border-radius: 8px;
                                    cursor: pointer;
                                    font-size: 14px;
                                    font-weight: 500;
                                ">Cancel</button>
                                <button id="mathTextEditUpdateBtn" style="
                                    padding: 8px 16px;
                                    border: none;
                                    background: #0b6efd;
                                    color: white;
                                    border-radius: 8px;
                                    cursor: pointer;
                                    font-size: 14px;
                                    font-weight: 500;
                                ">Update</button>
                            </div>
                        </div>
                    `;
                    
                    overlay.appendChild(popup);
                    document.body.appendChild(overlay);
                    
                    const input = document.getElementById('mathTextEditInput');
                    const preview = document.getElementById('mathTextEditPreview');
                    
                    // Function to update preview
                    function updatePreview() {{
                        const text = input.value.trim();
                        if (text) {{
                            preview.innerHTML = '';
                            const mathSpan = document.createElement('span');
                            mathSpan.className = 'tex2jax_process';
                            
                            if (mode === 'latex') {{
                                mathSpan.textContent = '\\\\(' + text + '\\\\)';
                            }} else {{
                                mathSpan.textContent = '`' + text + '`';
                            }}
                            
                            preview.appendChild(mathSpan);
                            
                            if (window.MathJax && window.MathJax.typesetPromise) {{
                                window.MathJax.typesetPromise([preview]).catch(err => {{
                                    console.error('Preview error:', err);
                                    preview.innerHTML = '<span style="color: #ef4444; font-size: 14px;">Preview error</span>';
                                }});
                            }}
                        }} else {{
                            preview.innerHTML = '<span style="color: #94a3b8; font-style: italic;">Type above to see preview</span>';
                        }}
                    }}
                    
                    // Update preview on input
                    let previewTimeout;
                    input.oninput = function() {{
                        clearTimeout(previewTimeout);
                        previewTimeout = setTimeout(updatePreview, 300);
                    }};
                    
                    // Initial preview
                    setTimeout(updatePreview, 100);
                    
                    // Focus and select all text
                    input.focus();
                    input.select();
                    
                    // Update button
                    document.getElementById('mathTextEditUpdateBtn').onclick = function() {{
                        const newText = input.value.trim();
                        if (newText) {{
                            updateCallback(newText);
                            overlay.remove();
                        }} else {{
                            alert('Please enter a math expression');
                        }}
                    }};
                    
                    // Delete button
                    document.getElementById('mathTextDeleteBtn').onclick = function() {{
                        if (confirm('Delete this math expression?')) {{
                            updateCallback('');  // Empty string signals deletion
                            overlay.remove();
                        }}
                    }};
                    
                    // Cancel button
                    document.getElementById('mathTextEditCancelBtn').onclick = function() {{
                        overlay.remove();
                    }};
                    
                    // Click outside to close
                    overlay.onclick = function(e) {{
                        if (e.target === overlay) overlay.remove();
                    }};
                    
                    // ESC key to close
                    const escHandler = function(e) {{
                        if (e.key === 'Escape') {{
                            overlay.remove();
                            document.removeEventListener('keydown', escHandler);
                        }}
                    }};
                    document.addEventListener('keydown', escHandler);
                }};
            }}
            
            // ========================================
            // Show text input dialog that creates mathstring blots (with hover preview)
            // ========================================
            if (!window.showMathStringInputDialog) {{
                window.showMathStringInputDialog = function(quillInstance, mode) {{
                    const overlay = document.createElement('div');
                    overlay.style.cssText = `
                        position: fixed;
                        top: 0;
                        left: 0;
                        right: 0;
                        bottom: 0;
                        background: rgba(0, 0, 0, 0.5);
                        z-index: 10000;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                    `;
                    
                    const popup = document.createElement('div');
                    popup.style.cssText = `
                        background: white;
                        padding: 24px;
                        border-radius: 12px;
                        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
                        max-width: 600px;
                        width: 90%;
                    `;
                    
                    const title = mode === 'latex' ? 'Insert LaTeX Math' : 'Insert AsciiMath';
                    const placeholder = mode === 'latex' ? 'x^{{2}} + y^{{2}} = r^{{2}}' : 'x^2 + y^2 = r^2';
                    const example = mode === 'latex' 
                        ? 'Examples: \\\\frac{{a}}{{b}}, \\\\sqrt{{x}}, x^{{2}}, \\\\int_{{0}}^{{\\\\infty}}' 
                        : 'Examples: a/b, sqrt(x), x^2, int_0^oo';
                    
                    popup.innerHTML = `
                        <h3 style="margin: 0 0 16px 0; color: #0f172a;">${{title}}</h3>
                        <div style="margin-bottom: 16px;">
                            <label style="display: block; font-weight: 600; margin-bottom: 6px;">Math Expression:</label>
                            <textarea id="mathStringInput" placeholder="${{placeholder}}" style="
                                width: 100%;
                                padding: 12px;
                                border: 2px solid #e6eef8;
                                border-radius: 8px;
                                font-size: 16px;
                                font-family: 'Courier New', monospace;
                                min-height: 100px;
                                resize: vertical;
                            "></textarea>
                            <div style="font-size: 12px; color: #64748b; margin-top: 6px;">
                                ${{example}}
                            </div>
                        </div>
                        <div style="margin-bottom: 16px;">
                            <label style="display: block; font-weight: 600; margin-bottom: 6px;">Preview:</label>
                            <div id="mathStringPreview" style="
                                border: 1px solid #e2e8f0;
                                border-radius: 8px;
                                padding: 16px;
                                min-height: 80px;
                                background: #f8fafc;
                                font-size: 18px;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                            ">
                                <span style="color: #94a3b8; font-style: italic;">Type above to see preview</span>
                            </div>
                        </div>
                        <div style="display: flex; gap: 8px; justify-content: flex-end;">
                            <button id="mathStringCancelBtn" style="
                                padding: 8px 16px;
                                border: 1px solid #dbe9ff;
                                background: white;
                                color: #0b6efd;
                                border-radius: 8px;
                                cursor: pointer;
                                font-size: 14px;
                                font-weight: 500;
                            ">Cancel</button>
                            <button id="mathStringInsertBtn" style="
                                padding: 8px 16px;
                                border: none;
                                background: #0b6efd;
                                color: white;
                                border-radius: 8px;
                                cursor: pointer;
                                font-size: 14px;
                                font-weight: 500;
                            ">Insert</button>
                        </div>
                    `;
                    
                    overlay.appendChild(popup);
                    document.body.appendChild(overlay);
                    
                    const input = document.getElementById('mathStringInput');
                    const preview = document.getElementById('mathStringPreview');
                    
                    // Update preview as user types
                    let previewTimeout;
                    input.oninput = function() {{
                        clearTimeout(previewTimeout);
                        previewTimeout = setTimeout(() => {{
                            const text = input.value.trim();
                            if (text) {{
                                preview.innerHTML = '';
                                const mathSpan = document.createElement('span');
                                mathSpan.className = 'tex2jax_process';
                                
                                if (mode === 'latex') {{
                                    mathSpan.textContent = '\\\\(' + text + '\\\\)';
                                }} else {{
                                    mathSpan.textContent = '`' + text + '`';
                                }}
                                
                                preview.appendChild(mathSpan);
                                
                                if (window.MathJax && window.MathJax.typesetPromise) {{
                                    window.MathJax.typesetPromise([preview]).catch(err => {{
                                        console.error('Preview error:', err);
                                        preview.innerHTML = '<span style="color: #ef4444; font-size: 14px;">Preview error</span>';
                                    }});
                                }}
                            }} else {{
                                preview.innerHTML = '<span style="color: #94a3b8; font-style: italic;">Type above to see preview</span>';
                            }}
                        }}, 500);
                    }};
                    
                    input.focus();
                    
                    // Insert button - creates mathstring blot
                    document.getElementById('mathStringInsertBtn').onclick = function() {{
                        const mathText = input.value.trim();
                        if (mathText) {{
                            const range = quillInstance.getSelection(true);
                            if (range) {{
                                // Insert as mathstring blot (with hover preview)
                                quillInstance.insertEmbed(range.index, 'mathstring', {{
                                    text: mathText,
                                    mode: mode
                                }}, window.Quill.sources.USER);
                                
                                quillInstance.insertText(range.index + 1, ' ', window.Quill.sources.USER);
                                quillInstance.setSelection(range.index + 2, window.Quill.sources.SILENT);
                                
                                console.log(`‚úì MathString blot (${{mode}}) inserted:`, mathText);
                            }}
                            overlay.remove();
                        }} else {{
                            alert('Please enter a math expression');
                        }}
                    }};
                    
                    // Cancel button
                    document.getElementById('mathStringCancelBtn').onclick = function() {{
                        overlay.remove();
                    }};
                    
                    // Click outside to close
                    overlay.onclick = function(e) {{
                        if (e.target === overlay) overlay.remove();
                    }};
                    
                    // ESC key to close
                    const escHandler = function(e) {{
                        if (e.key === 'Escape') {{
                            overlay.remove();
                            document.removeEventListener('keydown', escHandler);
                        }}
                    }};
                    document.addEventListener('keydown', escHandler);
                }};
            }}
            
            // ========================================
            // Add Math Buttons to Toolbar
            // ========================================
            function addMathButtons(retries = 0) {{
                console.log('üîç Looking for toolbar, attempt:', retries + 1);
                
                let toolbar = container.querySelector('.ql-toolbar');
                if (!toolbar) toolbar = document.querySelector('#{editor_id} .ql-toolbar');
                if (!toolbar) {{
                    const parent = container.parentElement;
                    if (parent) toolbar = parent.querySelector('.ql-toolbar');
                }}
                
                if (toolbar) {{
                    console.log('‚úì Toolbar found:', toolbar);
                    
                    const btnWrapper = document.createElement('span');
                    btnWrapper.className = 'ql-formats';
                    // ‚úÖ ADD THIS STYLING FOR EVEN SPACING
                    //btnWrapper.style.cssText = 'display: flex; gap: 4px;';
                    // 1. Visual Math Editor Button (∆í(x)) - Opens MathQuill visual editor
                    const mathBtn = document.createElement('button');
                    mathBtn.type = 'button';
                    mathBtn.className = 'ql-math';
                    mathBtn.innerHTML = '<span style="font-weight:bold;font-size:18px;">∆í(x)</span>';
                    mathBtn.title = 'Insert Editable Math (Visual Editor)';
                    // ‚úÖ ADD CONSISTENT WIDTH
                    mathBtn.style.width = '40px';
                    
                    mathBtn.addEventListener('click', function(e) {{
                        e.preventDefault();
                        console.log('Math button clicked - opening visual editor');
                        window.showMathQuillDialog(quill, '');
                    }});
                    
                    // 2. LaTeX Button - Opens text input dialog that creates mathstring blots
                    const latexBtn = document.createElement('button');
                    latexBtn.type = 'button';
                    latexBtn.className = 'ql-math-latex';
                    latexBtn.innerHTML = '<span style="font-weight:bold;font-size:14px;">TeX</span>';
                    latexBtn.title = 'Insert LaTeX String (with hover preview)';
                    
                    latexBtn.addEventListener('click', function(e) {{
                        e.preventDefault();
                        console.log('LaTeX button clicked - opening text dialog');
                        if (window.showMathStringInputDialog) {{
                            window.showMathStringInputDialog(quill, 'latex');
                        }} else {{
                            console.error('showMathStringInputDialog not found');
                        }}
                    }});
                    
                    // 3. AsciiMath Button - Opens text input dialog that creates mathstring blots
                    const asciiBtn = document.createElement('button');
                    asciiBtn.type = 'button';
                    asciiBtn.className = 'ql-math-ascii';
                    asciiBtn.innerHTML = '<span style="font-weight:bold;font-size:18px;">Œ£</span>';
                    asciiBtn.title = 'Insert AsciiMath String (with hover preview)';
                    
                    asciiBtn.addEventListener('click', function(e) {{
                        e.preventDefault();
                        console.log('AsciiMath button clicked - opening text dialog');
                        if (window.showMathStringInputDialog) {{
                            window.showMathStringInputDialog(quill, 'asciimath');
                        }} else {{
                            console.error('showMathStringInputDialog not found');
                        }}
                    }});
                    
                    btnWrapper.appendChild(mathBtn);
                    btnWrapper.appendChild(latexBtn);
                    btnWrapper.appendChild(asciiBtn);
                    toolbar.appendChild(btnWrapper);
                    
                    console.log('‚úì Math buttons added to toolbar');
                }} else if (retries < 10) {{
                    console.log('‚è≥ Toolbar not found, retrying...');
                    setTimeout(() => addMathButtons(retries + 1), 300);
                }} else {{
                    console.error('‚ùå Toolbar not found after multiple retries');
                }}
            }}
            
            setTimeout(() => addMathButtons(), 500);
            
            // ========================================
            // Add Image Button to Toolbar
            // ========================================
            function addImageButton(retries = 0) {{
                let toolbar = container.querySelector('.ql-toolbar');
                if (!toolbar) toolbar = document.querySelector('#{editor_id} .ql-toolbar');
                if (!toolbar) {{
                    const parent = container.parentElement;
                    if (parent) toolbar = parent.querySelector('.ql-toolbar');
                }}
                
                if (toolbar) {{
                    const btnWrapper = document.createElement('span');
                    btnWrapper.className = 'ql-formats';
                    
                    const imageBtn = document.createElement('button');
                    imageBtn.type = 'button';
                    imageBtn.className = 'ql-image';
                    imageBtn.innerHTML = '<svg viewBox="0 0 18 18"><rect class="ql-stroke" height="10" width="12" x="3" y="4"></rect><circle class="ql-fill" cx="6" cy="7" r="1"></circle><polyline class="ql-even ql-fill" points="5 12 5 11 7 9 8 10 11 7 13 9 13 12 5 12"></polyline></svg>';
                    imageBtn.title = 'Insert Image';
                    
                    imageBtn.addEventListener('click', function(e) {{
                        e.preventDefault();
                        if (window.showImageDialog) {{
                            window.showImageDialog(quill);
                        }}
                    }});
                    
                    btnWrapper.appendChild(imageBtn);
                    toolbar.appendChild(btnWrapper);
                    
                    console.log('‚úì Image button added to toolbar');
                }} else if (retries < 10) {{
                    setTimeout(() => addImageButton(retries + 1), 300);
                }}
            }}
            
            setTimeout(() => addImageButton(), 500);
            
            // CRITICAL: Only save on text-change, DO NOT render MathJax
            quill.on('text-change', function() {{
                if (window.problem_creator) {{
                    window.problem_creator.data_manager.save_to_storage();
                }}
            }});
            
            console.log('‚úì Quill editor fully configured:', '{editor_id}');
        }} catch(e) {{
            console.error('‚ùå Failed to create Quill editor:', e);
            console.error('Stack:', e.stack);
        }}
    }})();
    
    // ========================================
    // Image Dialog Function (Global)
    // ========================================
    if (!window.showImageDialog) {{
        window.showImageDialog = function(quillInstance) {{
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, 0.5);
                z-index: 10000;
                display: flex;
                align-items: center;
                justify-content: center;
            `;
            
            const popup = document.createElement('div');
            popup.style.cssText = `
                background: white;
                padding: 24px;
                border-radius: 12px;
                box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
                max-width: 500px;
                width: 90%;
            `;
            
            popup.innerHTML = `
                <h3 style="margin: 0 0 16px 0; color: #0f172a;">Insert Image</h3>
                <div style="display: flex; gap: 8px; margin-bottom: 16px; border-bottom: 2px solid #e6eef8;">
                    <button id="urlTabBtn" style="padding: 8px 16px; border: none; background: transparent; color: #0b6efd; border-bottom: 2px solid #0b6efd; cursor: pointer; font-weight: 600; margin-bottom: -2px;">URL</button>
                    <button id="uploadTabBtn" style="padding: 8px 16px; border: none; background: transparent; color: #64748b; cursor: pointer; font-weight: 600;">Upload File</button>
                </div>
                <div id="urlTab" style="display: block;">
                    <div style="margin-bottom: 16px;">
                        <label style="display: block; font-weight: 600; margin-bottom: 6px;">Image URL:</label>
                        <input id="imageUrl" type="text" placeholder="https://example.com/image.jpg" style="width: 100%; padding: 8px; border: 2px solid #e6eef8; border-radius: 6px; font-size: 14px;">
                    </div>
                </div>
                <div id="uploadTab" style="display: none;">
                    <div style="margin-bottom: 16px;">
                        <label style="display: block; font-weight: 600; margin-bottom: 6px;">Choose Image File:</label>
                        <input id="imageFile" type="file" accept="image/*" style="width: 100%; padding: 8px; border: 2px solid #e6eef8; border-radius: 6px; font-size: 14px;">
                        <div id="filePreview" style="margin-top: 8px; text-align: center;"></div>
                    </div>
                </div>
                <div style="margin-bottom: 16px;">
                    <label style="display: block; font-weight: 600; margin-bottom: 6px;">Size:</label>
                    <select id="imageSize" style="width: 100%; padding: 8px; border: 2px solid #e6eef8; border-radius: 6px; font-size: 14px;">
                        <option value="small">Small (80√ó60px)</option>
                        <option value="medium" selected>Medium (160√ó120px)</option>
                        <option value="large">Large (240√ó180px)</option>
                        <option value="xlarge">Extra Large (320√ó240px)</option>
                        <option value="full">Full Width</option>
                    </select>
                </div>
                <div style="display: flex; gap: 8px; justify-content: flex-end;">
                    <button id="imageCancelBtn" style="padding: 8px 16px; border: 1px solid #dbe9ff; background: white; color: #0b6efd; border-radius: 8px; cursor: pointer; font-size: 14px; font-weight: 500;">Cancel</button>
                    <button id="imageInsertBtn" style="padding: 8px 16px; border: none; background: #0b6efd; color: white; border-radius: 8px; cursor: pointer; font-size: 14px; font-weight: 500;">Insert</button>
                </div>
            `;
            
            overlay.appendChild(popup);
            document.body.appendChild(overlay);
            
            const urlTab = document.getElementById('urlTab');
            const uploadTab = document.getElementById('uploadTab');
            const urlTabBtn = document.getElementById('urlTabBtn');
            const uploadTabBtn = document.getElementById('uploadTabBtn');
            
            urlTabBtn.onclick = function() {{
                urlTab.style.display = 'block';
                uploadTab.style.display = 'none';
                urlTabBtn.style.color = '#0b6efd';
                urlTabBtn.style.borderBottom = '2px solid #0b6efd';
                uploadTabBtn.style.color = '#64748b';
                uploadTabBtn.style.borderBottom = 'none';
            }};
            
            uploadTabBtn.onclick = function() {{
                urlTab.style.display = 'none';
                uploadTab.style.display = 'block';
                uploadTabBtn.style.color = '#0b6efd';
                uploadTabBtn.style.borderBottom = '2px solid #0b6efd';
                urlTabBtn.style.color = '#64748b';
                urlTabBtn.style.borderBottom = 'none';
            }};
            
            let uploadedImageData = null;
            const fileInput = document.getElementById('imageFile');
            const filePreview = document.getElementById('filePreview');
            
            fileInput.onchange = function(e) {{
                const file = e.target.files[0];
                if (file && file.type.startsWith('image/')) {{
                    const reader = new FileReader();
                    reader.onload = function(event) {{
                        uploadedImageData = event.target.result;
                        filePreview.innerHTML = `<img src="${{uploadedImageData}}" style="max-width: 200px; max-height: 150px; border: 2px solid #e6eef8; border-radius: 6px; margin-top: 8px;"><div style="font-size: 12px; color: #64748b; margin-top: 4px;">${{file.name}} (${{(file.size / 1024).toFixed(1)}} KB)</div>`;
                    }};
                    reader.readAsDataURL(file);
                }} else {{
                    filePreview.innerHTML = '<div style="color: #ef4444; font-size: 12px;">Please select a valid image file</div>';
                    uploadedImageData = null;
                }}
            }};
            
            document.getElementById('imageInsertBtn').onclick = function() {{
                const urlInput = document.getElementById('imageUrl');
                const size = document.getElementById('imageSize').value;
                
                let imageSource = urlInput.value.trim() || uploadedImageData;
                
                if (!imageSource) {{
                    alert('Please enter a URL or upload a file');
                    return;
                }}
                
                if (imageSource) {{
                    const range = quillInstance.getSelection(true);
                    if (range) {{
                        quillInstance.insertEmbed(range.index, 'image', imageSource, window.Quill.sources.USER);
                        
                        setTimeout(() => {{
                            const imgs = quillInstance.root.querySelectorAll('img');
                            const lastImg = imgs[imgs.length - 1];
                            if (lastImg && (lastImg.src === imageSource || lastImg.src.startsWith('data:image'))) {{
                                lastImg.setAttribute('data-size-class', size);
                                const sizeStyles = {{
                                    'small': {{ maxWidth: '80px', maxHeight: '60px' }},
                                    'medium': {{ maxWidth: '160px', maxHeight: '120px' }},
                                    'large': {{ maxWidth: '240px', maxHeight: '180px' }},
                                    'xlarge': {{ maxWidth: '320px', maxHeight: '240px' }},
                                    'full': {{ maxWidth: '100%', maxHeight: 'auto' }}
                                }};
                                const style = sizeStyles[size] || sizeStyles['medium'];
                                lastImg.style.maxWidth = style.maxWidth;
                                lastImg.style.maxHeight = style.maxHeight;
                                lastImg.style.height = 'auto';
                                lastImg.style.display = 'inline-block';
                                lastImg.style.verticalAlign = 'middle';
                                lastImg.style.margin = '4px';
                            }}
                        }}, 50);
                        
                        quillInstance.setSelection(range.index + 1, window.Quill.sources.SILENT);
                    }}
                    overlay.remove();
                }} else {{
                    alert('Please enter a URL or upload a file');
                }}
            }};
            
            document.getElementById('imageCancelBtn').onclick = function() {{ overlay.remove(); }};
            overlay.onclick = function(e) {{ if (e.target === overlay) overlay.remove(); }};
            const escHandler = function(e) {{ if (e.key === 'Escape') {{ overlay.remove(); document.removeEventListener('keydown', escHandler); }} }};
            document.addEventListener('keydown', escHandler);
        }};
    }}
    """
    window.eval(js_code)

def serialize_quill_content(editor_id):
    """Serialize Quill editor content to blocks"""
    js_code = """
    (function() {
        const quill = window.quillEditors && window.quillEditors['""" + editor_id + """'];
        if (!quill) {
            console.warn('Editor not found for serialization:', '""" + editor_id + """');
            return '[]';
        }
        
        const delta = quill.getContents();
        const blocks = [];
        let textBuffer = '';
        
        console.log('üì¶ Serializing editor:', '""" + editor_id + """');
        console.log('üì¶ Delta:', delta);
        
        delta.ops.forEach((op, idx) => {
            console.log('Op ' + idx + ':', op);
            
            if (typeof op.insert === 'string') {
                textBuffer += op.insert;
            } else if (op.insert && typeof op.insert === 'object') {
                // Flush text buffer before handling embeds
                if (textBuffer.trim()) {
                    blocks.push({ type: 'text', value: textBuffer });
                    textBuffer = '';
                }
                
                // Handle different embed types
                if (op.insert.mathquill) {
                    console.log('  ‚Üí Found mathquill embed');
                    blocks.push({ 
                        type: 'math', 
                        latex: op.insert.mathquill.latex || '' 
                    });
                } else if (op.insert.mathstring) {
                    console.log('  ‚Üí Found mathstring embed:', op.insert.mathstring);
                    blocks.push({
                        type: 'mathstring',
                        text: op.insert.mathstring.text || '',
                        mode: op.insert.mathstring.mode || 'latex'
                    });
                } else if (op.insert.image) {
                    console.log('  ‚Üí Found image embed');
                    const images = quill.root.querySelectorAll('img');
                    let sizeClass = 'medium';
                    
                    for (let img of images) {
                        if (img.src === op.insert.image || img.src.includes(op.insert.image.substring(0, 50))) {
                            sizeClass = img.getAttribute('data-size-class') || 'medium';
                            break;
                        }
                    }
                    
                    blocks.push({ 
                        type: 'image', 
                        src: op.insert.image,
                        size: sizeClass
                    });
                } else {
                    console.warn('  ‚Üí Unknown embed type:', Object.keys(op.insert));
                }
            }
        });
        
        // Flush remaining text
        if (textBuffer.trim()) {
            blocks.push({ type: 'text', value: textBuffer });
        }
        
        console.log('üì¶ Serialized ' + blocks.length + ' blocks');
        blocks.forEach((block, idx) => {
            if (block.type === 'mathstring') {
                console.log('  Block ' + idx + ' (mathstring): "' + block.text + '" mode=' + block.mode);
            } else {
                console.log('  Block ' + idx + ' (' + block.type + ')');
            }
        });
        
        return JSON.stringify(blocks);
    })();
    """
    
    try:
        result = window.eval(js_code)
        if result:
            import json
            parsed = json.loads(result)
            window.console.log(f"‚úì Serialization complete: {len(parsed)} blocks")
            return parsed
        return []
    except Exception as e:
        window.console.error(f"Error serializing Quill content: {e}")
        import traceback
        window.console.error(traceback.format_exc())
        return []
                              
def restore_quill_content(editor_id, blocks):
    """Restore content blocks into Quill editor with retry logic and inline math detection"""
    if not blocks:
        return
    
    # Separate image data for later processing
    image_data = []
    delta_ops = []
    
    print(f"üì• Restoring {len(blocks)} blocks to editor {editor_id}")
    
    for block in blocks:
        print(f"  Block type: {block['type']}")
        
        if block["type"] == "text":
            # ‚≠ê Parse text for inline math (backticks or $$)
            text = block["value"]
            
            # Find all math expressions in the text
            import re
            # Pattern to match $$...$$ or `...`
            math_pattern = r'(\$\$.*?\$\$|`.*?`)'
            parts = re.split(math_pattern, text)
            
            for part in parts:
                if not part:
                    continue
                    
                if part.startswith('`') and part.endswith('`'):
                    # AsciiMath - extract content and create mathstring blot
                    asciimath_content = part[1:-1]  # Remove backticks
                    delta_ops.append({"insert": {"mathstring": {
                        "text": asciimath_content,
                        "mode": "asciimath"
                    }}})
                    print(f"    Found AsciiMath blot: {asciimath_content}")
                elif part.startswith('$$') and part.endswith('$$'):
                    # LaTeX - extract content and create mathstring blot
                    latex_content = part[2:-2].strip()
                    delta_ops.append({"insert": {"mathstring": {
                        "text": latex_content,
                        "mode": "latex"
                    }}})
                    print(f"    Found LaTeX blot: {latex_content}")
                else:
                    # Regular text
                    if part:
                        delta_ops.append({"insert": part})
                        
        elif block["type"] == "math":
            # Already structured math block - convert to mathstring blot
            delta_ops.append({"insert": {"mathstring": {
                "text": block.get("latex", ""),
                "mode": "latex"
            }}})
            print(f"    Math block (as mathstring): {block.get('latex', '')}")
            
        elif block["type"] == "mathstring":
            # CRITICAL: Ensure mathstring is properly formatted
            delta_ops.append({"insert": {"mathstring": {
                "text": block.get("text", ""),
                "mode": block.get("mode", "latex")
            }}})
            print(f"    Mathstring: {block.get('text', '')} (mode: {block.get('mode', 'latex')})")
            
        elif block["type"] == "image":
            delta_ops.append({"insert": {"image": block["src"]}})
            image_data.append({
                "src": block["src"],
                "size": block.get("size", "medium")
            })
    
    # Serialize to JSON for JS
    import json
    delta_json = json.dumps(delta_ops)
    image_data_json = json.dumps(image_data)
    
    # Use string concatenation instead of f-string for complex JavaScript
    js_code = """
    (function() {
        const editorId = '""" + editor_id + """';
        const deltaOps = """ + delta_json + """;
        const imageData = """ + image_data_json + """;
        let attempts = 0;
        const maxAttempts = 20;
        
        console.log('üì• Attempting to restore content to:', editorId);
        console.log('Delta ops:', deltaOps);
        
        function applyImageSizes(quill) {
            const images = quill.root.querySelectorAll('img');
            
            console.log('üì∏ Found ' + images.length + ' images, have ' + imageData.length + ' size records');
            
            imageData.forEach((data, index) => {
                if (index < images.length) {
                    const img = images[index];
                    const size = data.size || 'medium';
                    
                    img.setAttribute('data-size-class', size);
                    
                    const sizeStyles = {
                        'small': { maxWidth: '80px', maxHeight: '60px' },
                        'medium': { maxWidth: '160px', maxHeight: '120px' },
                        'large': { maxWidth: '240px', maxHeight: '180px' },
                        'xlarge': { maxWidth: '320px', maxHeight: '240px' },
                        'full': { maxWidth: '100%', maxHeight: 'auto' }
                    };
                    
                    const style = sizeStyles[size] || sizeStyles['medium'];
                    img.style.maxWidth = style.maxWidth;
                    img.style.maxHeight = style.maxHeight;
                    img.style.height = 'auto';
                    img.style.display = 'inline-block';
                    img.style.verticalAlign = 'middle';
                    img.style.margin = '4px';
                    
                    console.log('‚úì Image ' + (index + 1) + ': Applied size "' + size + '"');
                }
            });
        }
        
        function tryRestore() {
            const quill = window.quillEditors && window.quillEditors[editorId];
            
            if (quill) {
                console.log('‚úÖ Found Quill editor:', editorId);
                
                // CRITICAL: Ensure MathString blot is registered before restoring
                if (!window.MathStringBlotFixed) {
                    console.error('‚ùå MathString blot not registered! Content may not restore properly.');
                }
                
                // Restore content
                try {
                    quill.setContents(deltaOps);
                    console.log('‚úì Content restored to', editorId);
                    
                    // Verify mathstring blots were created
                    const mathStrings = quill.root.querySelectorAll('.math-string-inline');
                    console.log('‚úì Found ' + mathStrings.length + ' mathstring blot(s) after restoration');
                    
                    if (mathStrings.length > 0) {
                        mathStrings.forEach((el, idx) => {
                            console.log('  MathString ' + (idx + 1) + ': "' + el.textContent + '" (mode: ' + el.getAttribute('data-mode') + ')');
                        });
                    }
                    
                } catch (err) {
                    console.error('‚ùå Error restoring content:', err);
                }
                
                // Apply image sizes after a delay
                setTimeout(() => applyImageSizes(quill), 150);
                setTimeout(() => applyImageSizes(quill), 500);
                
                return true;
            } else {
                attempts++;
                if (attempts < maxAttempts) {
                    setTimeout(tryRestore, 100);
                    return false;
                } else {
                    console.warn('‚ö†Ô∏è Editor not found after', maxAttempts, 'attempts:', editorId);
                    return false;
                }
            }
        }
        
        tryRestore();
    })();
    """
    window.eval(js_code)
                              
def hide_loading():
    """Hide loading overlay"""
    overlay = document.querySelector("#loadingOverlay")
    if overlay:
        overlay.style.opacity = "0"
        window.setTimeout(create_proxy(lambda: overlay.remove()), 400)


                              
# ============================================================================
# INITIALIZATION
# ============================================================================

# Global MathQuill reference
MQ = None

# Initialize the application
update_status("‚úì PyScript loaded")
update_status("‚è≥ Importing libraries...")

# Create and store the main app instance
window.problem_creator = ProblemCreator()

</script>
<script>
// ============================================================================
// ASCIIMATH TO MATHQUILL KEYSTROKE PARSER
// ============================================================================

function parseSmartKeystrokes(text) {
    const MAX_DEPTH = 5;

    const greekLetters = {
        'alpha': '\\alpha', 'beta': '\\beta', 'gamma': '\\gamma', 'delta': '\\delta',
        'epsilon': '\\epsilon', 'zeta': '\\zeta', 'eta': '\\eta', 'theta': '\\theta',
        'iota': '\\iota', 'kappa': '\\kappa', 'lambda': '\\lambda', 'mu': '\\mu',
        'nu': '\\nu', 'xi': '\\xi', 'pi': '\\pi', 'rho': '\\rho', 'sigma': '\\sigma',
        'tau': '\\tau', 'upsilon': '\\upsilon', 'phi': '\\phi', 'chi': '\\chi',
        'psi': '\\psi', 'omega': '\\omega', 'Gamma': '\\Gamma', 'Delta': '\\Delta',
        'Theta': '\\Theta', 'Lambda': '\\Lambda', 'Xi': '\\Xi', 'Pi': '\\Pi',
        'Sigma': '\\Sigma', 'Phi': '\\Phi', 'Psi': '\\Psi', 'Omega': '\\Omega'
    };

    function pushInfty(keystrokes) {
        for (const c of '\\infty') keystrokes.push(c);
        keystrokes.push('{Tab}');
    }

    function unwrapParentheses(expr) {
        expr = expr.trim();
        if (expr.startsWith('(') && expr.endsWith(')')) {
            let depth = 0;
            for (let i = 0; i < expr.length; i++) {
                if (expr[i] === '(') depth++;
                else if (expr[i] === ')') depth--;
                if (depth === 0 && i < expr.length - 1) return expr;
            }
            return expr.slice(1, -1);
        }
        return expr;
    }

    function extractParenContent(text, startIndex) {
        let depth = 1, i = startIndex, content = '';
        while (i < text.length && depth > 0) {
            const c = text[i++];
            if (c === '(') depth++;
            else if (c === ')') depth--;
            if (depth > 0) content += c;
        }
        return { content, end: i };
    }

    // ‚úÖ NEW: Process denominator after / (handles variables, exponents, parentheses)
    function processDenominator(text, startPos, keystrokes) {
        let i = startPos;
        
        // Handle parenthesized denominator: /(...)
        if (i < text.length && text[i] === '(') {
            const { content, end } = extractParenContent(text, i + 1);
            
            // Check if there's an exponent/subscript after closing paren
            const hasExponentAfter = end < text.length && (text[end] === '^' || text[end] === '_');
            
            if (hasExponentAfter) {
                // Keep parentheses if there's an exponent after them
                keystrokes.push('(');
                processComplexParenContent(content, keystrokes, 0);
                keystrokes.push(')');
            } else {
                // Unwrap parentheses if no exponent (cleaner notation)
                processComplexParenContent(content, keystrokes, 0);
            }
            
            i = end;
            
            // Process exponent after closing paren
            if (hasExponentAfter) {
                i = handleSubSuperAtIndex(text, i, keystrokes, 0);
            }
            
            return i;
        }
        
        // Handle simple denominator: digits, variables, possibly with exponents
        // Read the base (digits or variable)
        let base = '';
        
        // Read digits
        while (i < text.length && /\d/.test(text[i])) {
            base += text[i++];
        }
        
        // If no digits, try reading a variable
        if (base === '' && i < text.length && /[a-zA-Z]/.test(text[i])) {
            base += text[i++];
        }
        
        // Type the base
        for (const c of base) keystrokes.push(c);
        
        // Check for exponent or subscript
        if (i < text.length && (text[i] === '^' || text[i] === '_')) {
            i = handleSubSuperAtIndex(text, i, keystrokes, 0);
        }
        
        return i;
    }

    // ‚úÖ Recursively process complex parenthetical content
    function processComplexParenContent(content, keystrokes, depth = 0) {
        if (depth > MAX_DEPTH) {
            for (const c of content) keystrokes.push(c);
            return;
        }

        let j = 0;
        while (j < content.length) {
            const ch = content[j];
            
            // Handle sub/superscripts
            if ((ch === '^' || ch === '_') && depth < MAX_DEPTH) {
                keystrokes.push(ch);
                j++;
                if (j < content.length && content[j] === '(') {
                    const { content: subContent, end } = extractParenContent(content, j + 1);
                    processComplexParenContent(subContent, keystrokes, depth + 1);
                    keystrokes.push('{Right}');
                    j = end;
                } else {
                    let token = '';
                    while (j < content.length && /[0-9a-zA-Z]/.test(content[j])) token += content[j++];
                    if (token === 'inf') pushInfty(keystrokes);
                    else for (const c of token) keystrokes.push(c);
                    keystrokes.push('{Right}');
                }
                continue;
            }

            // Handle negative fractions: -digit(s)/...
            if (ch === '-' && j + 1 < content.length && /\d/.test(content[j + 1])) {
                keystrokes.push('-');
                j++;
                
                let num = '';
                while (j < content.length && /\d/.test(content[j])) {
                    num += content[j++];
                }
                
                if (j < content.length && content[j] === '/') {
                    for (const c of num) keystrokes.push(c);
                    keystrokes.push('/');
                    j++;
                    
                    // ‚úÖ Use robust denominator processor
                    j = processDenominatorFromString(content, j, keystrokes);
                    keystrokes.push('{Right}');
                } else {
                    for (const c of num) keystrokes.push(c);
                }
                continue;
            }
            
            // Handle nested parentheses recursively
            if (ch === '(') {
                keystrokes.push('(');
                const { content: subContent, end } = extractParenContent(content, j + 1);
                processComplexParenContent(subContent, keystrokes, depth + 1);
                keystrokes.push(')');
                j = end;
                continue;
            }

            // Handle simple fractions: digit(s)/...
            if (/\d/.test(ch)) {
                let num = '';
                while (j < content.length && /\d/.test(content[j])) {
                    num += content[j++];
                }
                
                if (j < content.length && content[j] === '/') {
                    for (const c of num) keystrokes.push(c);
                    keystrokes.push('/');
                    j++;
                    
                    // ‚úÖ Use robust denominator processor
                    j = processDenominatorFromString(content, j, keystrokes);
                    keystrokes.push('{Right}');
                } else {
                    for (const c of num) keystrokes.push(c);
                }
                continue;
            }
            
            // Default: push character
            keystrokes.push(ch);
            j++;
        }
    }

    // ‚úÖ Process denominator from a substring
    function processDenominatorFromString(str, startPos, keystrokes) {
        let j = startPos;
        
        // Handle parenthesized denominator
        if (j < str.length && str[j] === '(') {
            const { content, end } = extractParenContent(str, j + 1);
            
            // Check if there's an exponent/subscript after closing paren
            const hasExponentAfter = end < str.length && (str[end] === '^' || str[end] === '_');
            
            if (hasExponentAfter) {
                // Keep parentheses if there's an exponent after them
                keystrokes.push('(');
                processComplexParenContent(content, keystrokes, 0);
                keystrokes.push(')');
            } else {
                // Unwrap parentheses if no exponent
                processComplexParenContent(content, keystrokes, 0);
            }
            
            j = end;
            
            // Process exponent after closing paren
            if (hasExponentAfter) {
                const char = str[j];
                keystrokes.push(char);
                j++;
                if (j < str.length && str[j] === '(') {
                    const { content: subContent, end } = extractParenContent(str, j + 1);
                    processComplexParenContent(subContent, keystrokes, 0);
                    keystrokes.push('{Right}');
                    j = end;
                } else {
                    let token = '';
                    while (j < str.length && /[0-9a-zA-Z]/.test(str[j])) token += str[j++];
                    if (token === 'inf') pushInfty(keystrokes);
                    else for (const c of token) keystrokes.push(c);
                    keystrokes.push('{Right}');
                }
            }
            
            return j;
        }
        
        // Handle simple denominator
        let base = '';
        
        // Read digits
        while (j < str.length && /\d/.test(str[j])) {
            base += str[j++];
        }
        
        // If no digits, try reading a variable
        if (base === '' && j < str.length && /[a-zA-Z]/.test(str[j])) {
            base += str[j++];
        }
        
        // Type the base
        for (const c of base) keystrokes.push(c);
        
        // Check for exponent or subscript
        if (j < str.length && (str[j] === '^' || str[j] === '_')) {
            const char = str[j];
            keystrokes.push(char);
            j++;
            if (j < str.length && str[j] === '(') {
                const { content: subContent, end } = extractParenContent(str, j + 1);
                processComplexParenContent(subContent, keystrokes, 0);
                keystrokes.push('{Right}');
                j = end;
            } else {
                let token = '';
                while (j < str.length && /[0-9a-zA-Z]/.test(str[j])) token += str[j++];
                if (token === 'inf') pushInfty(keystrokes);
                else for (const c of token) keystrokes.push(c);
                keystrokes.push('{Right}');
            }
        }
        
        return j;
    }

    function processInlineContent(str, keystrokes, depth = 0) {
        let j = 0;
        while (j < str.length) {
            if (str.substring(j, j + 2) === '->') {
                for (const c of '\\to') keystrokes.push(c);
                j += 2;
                continue;
            }
            if (str.substring(j, j + 3) === 'inf') {
                pushInfty(keystrokes);
                j += 3;
                continue;
            }

            const ch = str[j];
            
            if (ch === '/' && j + 1 < str.length && str[j + 1] === '(') {
                keystrokes.push('/');
                const { content, end } = extractParenContent(str, j + 2);
                
                // Check if there's an exponent after closing paren
                const hasExponentAfter = end < str.length && (str[end] === '^' || str[end] === '_');
                
                if (hasExponentAfter) {
                    // Keep parentheses
                    keystrokes.push('(');
                    processInlineContent(unwrapParentheses('(' + content + ')'), keystrokes, depth + 1);
                    keystrokes.push(')');
                    j = end;
                    j = handleSubSuperAtIndexInline(str, j, keystrokes, depth);
                } else {
                    // Unwrap parentheses
                    processInlineContent(unwrapParentheses('(' + content + ')'), keystrokes, depth + 1);
                    j = end;
                }
                
                keystrokes.push('{Right}');
                continue;
            }
            
            if ((ch === '^' || ch === '_') && depth < MAX_DEPTH) {
                keystrokes.push(ch);
                j++;
                if (j < str.length && str[j] === '(') {
                    const { content, end } = extractParenContent(str, j + 1);
                    processInlineContent(unwrapParentheses('(' + content + ')'), keystrokes, depth + 1);
                    keystrokes.push('{Right}');
                    j = end;
                } else {
                    let token = '';
                    while (j < str.length && /[0-9a-zA-Z]/.test(str[j])) token += str[j++];
                    if (token === 'inf') pushInfty(keystrokes);
                    else for (const c of token) keystrokes.push(c);
                    keystrokes.push('{Right}');
                }
                continue;
            }

            keystrokes.push(ch);
            j++;
        }
    }

    function handleSubSuperAtIndexInline(str, i, keystrokes, depth = 0) {
        const char = str[i];
        keystrokes.push(char);
        i++;
        if (i >= str.length) return i;

        if (str.substring(i, i + 3) === 'inf') {
            pushInfty(keystrokes);
            i += 3;
            keystrokes.push('{Right}');
            return i;
        }

        if (str[i] === '(') {
            const { content, end } = extractParenContent(str, i + 1);
            processInlineContent(unwrapParentheses('(' + content + ')'), keystrokes, depth + 1);
            keystrokes.push('{Right}');
            return end;
        }

        let token = '';
        while (i < str.length && /[0-9a-zA-Z]/.test(str[i])) token += str[i++];
        if (token === 'inf') pushInfty(keystrokes);
        else for (const c of token) keystrokes.push(c);
        keystrokes.push('{Right}');
        return i;
    }

    function handleSubSuperAtIndex(text, i, keystrokes, depth = 0) {
        const char = text[i];
        keystrokes.push(char);
        i++;
        if (i >= text.length) return i;

        if (text.substring(i, i + 3) === 'inf') {
            pushInfty(keystrokes);
            i += 3;
            return i;
        }

        if (text[i] === '(') {
            const { content, end } = extractParenContent(text, i + 1);
            processInlineContent(unwrapParentheses('(' + content + ')'), keystrokes, depth + 1);
            keystrokes.push('{Right}');
            return end;
        }

        let token = '';
        while (i < text.length && /[0-9a-zA-Z]/.test(text[i])) token += text[i++];
        if (token === 'inf') pushInfty(keystrokes);
        else for (const c of token) keystrokes.push(c);
        keystrokes.push('{Right}');
        return i;
    }

    const keystrokes = [];
    let i = 0;

    while (i < text.length) {
        // Handle pipe for row operations
        if (text[i] === '|') {
            keystrokes.push('|');
            i++;
            continue;
        }

        // Handle LaTeX arrows
        if (text.substring(i, i + 3) === '\\to') {
            for (const c of '\\to') keystrokes.push(c);
            keystrokes.push('{Tab}');
            i += 3;
            continue;
        }
        if (text.substring(i, i + 10) === '\\leftarrow') {
            for (const c of '\\leftarrow') keystrokes.push(c);
            keystrokes.push('{Tab}');
            i += 10;
            continue;
        }
        if (text.substring(i, i + 11) === '\\rightarrow') {
            for (const c of '\\rightarrow') keystrokes.push(c);
            keystrokes.push('{Tab}');
            i += 11;
            continue;
        }
        if (text.substring(i, i + 15) === '\\leftrightarrow') {
            for (const c of '\\leftrightarrow') keystrokes.push(c);
            keystrokes.push('{Tab}');
            i += 15;
            continue;
        }

        // Handle R_ subscripts
        if (text[i] === 'R' && i + 1 < text.length && text[i + 1] === '_') {
            keystrokes.push('R');
            keystrokes.push('_');
            i += 2;
            let subscript = '';
            while (i < text.length && /[0-9]/.test(text[i])) {
                subscript += text[i];
                i++;
            }
            for (const c of subscript) keystrokes.push(c);
            keystrokes.push('{Right}');
            continue;
        }

        // Handle parentheses with complex recursive processing
        if (text[i] === '(') {
            keystrokes.push('(');
            const { content, end } = extractParenContent(text, i + 1);
            processComplexParenContent(content, keystrokes, 0);
            keystrokes.push(')');
            i = end;
            
            // Check for exponent immediately after closing paren
            if (i < text.length && text[i] === '^') {
                i = handleSubSuperAtIndex(text, i, keystrokes, 0);
            }
            
            continue;
        }

        // Handle matrix brackets
        if (text.substring(i, i + 2) === '[[') {
            keystrokes.push('[');
            keystrokes.push('[');
            i += 2;
            continue;
        }
        if (text.substring(i, i + 2) === ']]') {
            keystrokes.push(']');
            keystrokes.push(']');
            i += 2;
            continue;
        }

        if (text[i] === '[') {
            keystrokes.push('[');
            i++;
            continue;
        }
        if (text[i] === ']') {
            keystrokes.push(']');
            i++;
            continue;
        }

        if (text[i] === ',') {
            keystrokes.push(',');
            i++;
            continue;
        }

        // ‚úÖ FIXED: Handle negative fractions globally with robust denominator
        if (text[i] === '-' && i + 1 < text.length && /\d/.test(text[i + 1])) {
            keystrokes.push('-');
            i++;
            
            let num = '';
            while (i < text.length && /\d/.test(text[i])) {
                num += text[i++];
            }
            
            if (i < text.length && text[i] === '/') {
                for (const c of num) keystrokes.push(c);
                keystrokes.push('/');
                i++;
                
                // ‚úÖ Use robust denominator processor
                i = processDenominator(text, i, keystrokes);
                keystrokes.push('{Right}');
            } else {
                for (const c of num) keystrokes.push(c);
            }
            continue;
        }

        // ‚úÖ FIXED: Handle positive fractions globally with robust denominator
        if (/\d/.test(text[i])) {
            let num = '';
            while (i < text.length && /\d/.test(text[i])) {
                num += text[i++];
            }
            
            if (i < text.length && text[i] === '/') {
                for (const c of num) keystrokes.push(c);
                keystrokes.push('/');
                i++;
                
                // ‚úÖ Use robust denominator processor
                i = processDenominator(text, i, keystrokes);
                keystrokes.push('{Right}');
            } else {
                for (const c of num) keystrokes.push(c);
            }
            continue;
        }

        // Handle inf
        if (text.substring(i, i + 3) === 'inf') {
            pushInfty(keystrokes);
            i += 3;
            continue;
        }

        // Greek letters
        let greekMatched = false;
        for (const [name, latex] of Object.entries(greekLetters)) {
            if (text.substring(i, i + name.length) === name) {
                const nextPos = i + name.length;
                if (nextPos >= text.length || !/[a-zA-Z]/.test(text[nextPos])) {
                    for (const c of latex) keystrokes.push(c);
                    keystrokes.push('{Tab}');
                    i += name.length;
                    greekMatched = true;
                    break;
                }
            }
        }
        if (greekMatched) continue;

        // derivative
        if (text.substring(i, i + 3) === 'd/d' && i + 3 < text.length && /[a-zA-Z]/.test(text[i + 3])) {
            const v = text[i + 3];
            keystrokes.push('d');
            keystrokes.push('/');
            keystrokes.push('d');
            keystrokes.push(v);
            keystrokes.push('{Tab}');
            i += 4;
            if (i < text.length && text[i] === '(') {
                keystrokes.push('(');
                const { content, end } = extractParenContent(text, i + 1);
                processInlineContent(unwrapParentheses('(' + content + ')'), keystrokes);
                keystrokes.push(')');
                i = end;
            }
            continue;
        }

        // abs
        if (text.substring(i, i + 4) === 'abs(') {
            const { content, end } = extractParenContent(text, i + 4);
            keystrokes.push('|');
            processInlineContent(unwrapParentheses('(' + content + ')'), keystrokes);
            keystrokes.push('|');
            i = end;
            continue;
        }

        // sqrt
        if (text.substring(i, i + 5) === 'sqrt(') {
            for (const c of '\\sqrt') keystrokes.push(c);
            keystrokes.push('{Tab}');
            const { content, end } = extractParenContent(text, i + 5);
            processInlineContent(unwrapParentheses('(' + content + ')'), keystrokes);
            keystrokes.push('{Right}');
            i = end;
            continue;
        }

        // ln
        if (text.substring(i, i + 3) === 'ln(') {
            for (const c of '\\ln') keystrokes.push(c);
            keystrokes.push('{Tab}');
            const { content, end } = extractParenContent(text, i + 3);
            processInlineContent(unwrapParentheses('(' + content + ')'), keystrokes);
            keystrokes.push('{Right}');
            i = end;
            continue;
        }

        // lim_
        if (text.substring(i, i + 4) === 'lim_' && text[i + 4] === '(') {
            for (const c of '\\lim') keystrokes.push(c);
            keystrokes.push('{Tab}');
            const { content, end } = extractParenContent(text, i + 5);
            processInlineContent(unwrapParentheses('(' + content + ')'), keystrokes);
            keystrokes.push('{Right}');
            keystrokes.push('{Right}');
            i = end;
            continue;
        }

        // sum_
        if (text.substring(i, i + 4) === 'sum_' && text[i + 4] === '(') {
            for (const c of '\\sum') keystrokes.push(c);
            keystrokes.push('{Tab}');
            const { content, end } = extractParenContent(text, i + 5);
            processInlineContent(unwrapParentheses('(' + content + ')'), keystrokes);
            i = end;
            keystrokes.push('{Tab}');
            
            if (i < text.length && text[i] === '^') {
                i++;
                if (text[i] === '(') {
                    const { content, end } = extractParenContent(text, i + 1);
                    processInlineContent(unwrapParentheses('(' + content + ')'), keystrokes);
                    i = end;
                } else {
                    if (text.substring(i, i + 3) === 'inf') {
                        pushInfty(keystrokes);
                        i += 3;
                    } else {
                        let token = '';
                        while (i < text.length && /[0-9a-zA-Z]/.test(text[i])) token += text[i++];
                        if (token === 'inf') pushInfty(keystrokes);
                        else for (const c of token) keystrokes.push(c);
                    }
                }
            }
            
            keystrokes.push('{Tab}');
            continue;
        }

        // prod_
        if (text.substring(i, i + 5) === 'prod_' && text[i + 5] === '(') {
            for (const c of '\\prod') keystrokes.push(c);
            keystrokes.push('{Tab}');
            const { content, end } = extractParenContent(text, i + 6);
            processInlineContent(unwrapParentheses('(' + content + ')'), keystrokes);
            i = end;
            keystrokes.push('{Tab}');
            
            if (i < text.length && text[i] === '^') {
                i++;
                if (text[i] === '(') {
                    const { content, end } = extractParenContent(text, i + 1);
                    processInlineContent(unwrapParentheses('(' + content + ')'), keystrokes);
                    i = end;
                } else {
                    if (text.substring(i, i + 3) === 'inf') {
                        pushInfty(keystrokes);
                        i += 3;
                    } else {
                        let token = '';
                        while (i < text.length && /[0-9a-zA-Z]/.test(text[i])) token += text[i++];
                        if (token === 'inf') pushInfty(keystrokes);
                        else for (const c of token) keystrokes.push(c);
                    }
                }
            }
            
            keystrokes.push('{Tab}');
            continue;
        }

        // int_
        if (text.substring(i, i + 4) === 'int_') {
            for (const c of '\\int') keystrokes.push(c);
            keystrokes.push('{Tab}');
            i += 4;
            
            if (text[i] === '(') {
                const { content, end } = extractParenContent(text, i + 1);
                processInlineContent(unwrapParentheses('(' + content + ')'), keystrokes);
                i = end;
            } else {
                if (text.substring(i, i + 3) === 'inf') {
                    pushInfty(keystrokes);
                    i += 3;
                } else {
                    keystrokes.push(text[i++]);
                }
            }
            
            keystrokes.push('{Tab}');
            
            if (i < text.length && text[i] === '^') {
                i++;
                if (text[i] === '(') {
                    const { content, end } = extractParenContent(text, i + 1);
                    processInlineContent(unwrapParentheses('(' + content + ')'), keystrokes);
                    i = end;
                } else {
                    if (text.substring(i, i + 3) === 'inf') {
                        pushInfty(keystrokes);
                        i += 3;
                    } else {
                        let token = '';
                        while (i < text.length && /[0-9a-zA-Z]/.test(text[i])) token += text[i++];
                        if (token === 'inf') pushInfty(keystrokes);
                        else for (const c of token) keystrokes.push(c);
                    }
                }
            }
            
            keystrokes.push('{Tab}');
            continue;
        }

        // log_
        if (text.substring(i, i + 4) === 'log_') {
            for (const c of '\\log') keystrokes.push(c);
            keystrokes.push('{Tab}');
            keystrokes.push('_');
            i += 4;
            if (text[i] === '(') {
                const { content, end } = extractParenContent(text, i + 1);
                const inner = unwrapParentheses('(' + content + ')');
                if (inner === 'inf') pushInfty(keystrokes);
                else processInlineContent(inner, keystrokes);
                i = end;
            } else {
                let base = '';
                while (/[0-9a-zA-Z]/.test(text[i])) base += text[i++];
                if (base === 'inf') pushInfty(keystrokes);
                else for (const c of base) keystrokes.push(c);
            }
            keystrokes.push('{Right}');
            if (text[i] === '(') {
                const { content, end } = extractParenContent(text, i + 1);
                processInlineContent(unwrapParentheses('(' + content + ')'), keystrokes);
                i = end;
            }
            keystrokes.push('{Right}');
            keystrokes.push('{Right}');
            continue;
        }

        // division with parentheses - check for exponent before exiting fraction
        if (text[i] === '/' && i + 1 < text.length && text[i + 1] === '(') {
            keystrokes.push('/');
            const { content, end } = extractParenContent(text, i + 2);
            
            // Check if there's an exponent/subscript after closing paren (before exiting fraction)
            let finalPos = end;
            const hasExponentAfter = finalPos < text.length && (text[finalPos] === '^' || text[finalPos] === '_');
            
            if (hasExponentAfter) {
                // Keep parentheses if there's an exponent after them
                keystrokes.push('(');
                processInlineContent(unwrapParentheses('(' + content + ')'), keystrokes);
                keystrokes.push(')');
                finalPos = handleSubSuperAtIndex(text, finalPos, keystrokes);
            } else {
                // Unwrap parentheses if no exponent (cleaner notation)
                processInlineContent(unwrapParentheses('(' + content + ')'), keystrokes);
            }
            
            keystrokes.push('{Right}'); // Exit fraction AFTER processing any exponent
            i = finalPos;
            continue;
        }

        // generic ^/_ handling
        if (text[i] === '^' || text[i] === '_') {
            i = handleSubSuperAtIndex(text, i, keystrokes);
            continue;
        }

        keystrokes.push(text[i++]);
    }

    return keystrokes;
}

// Export for Python access
window.parseSmartKeystrokes = parseSmartKeystrokes;

// ============================================================================
// MATHQUILL KEYSTROKE SENDER
// ============================================================================

function sendKeystrokesToMathQuill(mathField, keystrokes) {
    if (!mathField) {
        console.error('MathField is null or undefined');
        return false;
    }
    
    const cmdMap = {
        'Right': 'Right',
        'Left': 'Left',
        'Up': 'Up',
        'Down': 'Down',
        'Tab': 'Tab',
        'Enter': 'Enter',
        'Backspace': 'Backspace'
    };
    
    function isCmdToken(s) {
        return typeof s === 'string' && s.length > 2 && s[0] === '{' && s[s.length - 1] === '}';
    }
    
    try {
        mathField.latex(''); // Clear first
        
        for (const k of keystrokes) {
            if (isCmdToken(k)) {
                const cmd = k.slice(1, -1);
                const mapped = cmdMap[cmd] || cmd;
                try {
                    mathField.keystroke(mapped);
                } catch (err) {
                    console.warn(`MathQuill keystroke failed for ${mapped}:`, err);
                }
            } else {
                mathField.typedText(k);
            }
        }
        
        return true;
    } catch (error) {
        console.error('Error sending keystrokes:', error);
        return false;
    }
}

// Export for Python access
window.parseSmartKeystrokes = parseSmartKeystrokes;
window.sendKeystrokesToMathQuill = sendKeystrokesToMathQuill;

// ============================================================================
// AUTOSAVE INDICATOR
// ============================================================================

function showAutosaveIndicator(duration = 2000) {
  console.log('üîî [AUTOSAVE] Notification triggered, duration:', duration);
  
  const indicator = document.getElementById('autosaveIndicator');
  if (!indicator) {
    console.error('‚ùå [AUTOSAVE] Element #autosaveIndicator not found in DOM!');
    createAutosaveIndicator();
    return;
  }
  
  console.log('‚úÖ [AUTOSAVE] Element found, showing notification');
  
  // Remove any existing classes to reset state
  indicator.classList.remove('show', 'saving');
  
  // Force reflow to ensure animation restarts
  void indicator.offsetWidth;
  
  // Show as "saving" state first (blue)
  indicator.classList.add('show', 'saving');
  console.log('üìò [AUTOSAVE] State: SAVING (blue)');
  
  // After 300ms, switch to "saved" state (green)
  setTimeout(() => {
    indicator.classList.remove('saving');
    console.log('üìó [AUTOSAVE] State: SAVED (green)');
  }, 300);
  
  // Hide after specified duration
  setTimeout(() => {
    indicator.classList.remove('show');
    console.log('üëã [AUTOSAVE] Notification hidden');
  }, duration);
}

// Fallback: Create indicator if missing
function createAutosaveIndicator() {
  if (document.getElementById('autosaveIndicator')) return;
  
  console.warn('‚ö†Ô∏è [AUTOSAVE] Creating missing indicator element');
  const indicator = document.createElement('div');
  indicator.id = 'autosaveIndicator';
  indicator.style.cssText = `
    position: fixed;
    bottom: 20px;
    right: 20px;
    background: linear-gradient(135deg, #10b981 0%, #059669 100%);
    color: white;
    padding: 10px 16px;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 14px;
    font-weight: 600;
    opacity: 0;
    transform: translateY(20px);
    transition: all 0.3s ease;
    pointer-events: none;
    z-index: 10000;
  `;
  indicator.innerHTML = `
    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path>
      <polyline points="17 21 17 13 7 13 7 21"></polyline>
      <polyline points="7 3 7 8 15 8"></polyline>
    </svg>
    <span>Saved</span>
  `;
  document.body.appendChild(indicator);
}

// Make it globally accessible
window.showAutosaveIndicator = showAutosaveIndicator;

// Test function for manual testing
window.testAutosaveNotification = function() {
  console.log('üß™ [TEST] Manual autosave notification test');
  showAutosaveIndicator(3000);
};

// Log that the function is registered
console.log('‚úì [INIT] Autosave notification system loaded');



</script>

</body>
</html>
